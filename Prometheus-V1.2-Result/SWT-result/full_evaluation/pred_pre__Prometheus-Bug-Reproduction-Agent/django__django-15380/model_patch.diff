diff --git a/tests/migrations/test_autodetector_rename_model_and_field.py b/tests/migrations/test_autodetector_rename_model_and_field.py
new file mode 100644
index 0000000000..e3924af41a
--- /dev/null
+++ b/tests/migrations/test_autodetector_rename_model_and_field.py
@@ -0,0 +1,115 @@
+from django.db import models
+from django.db.migrations.autodetector import MigrationAutodetector
+from django.db.migrations.questioner import MigrationQuestioner
+from django.db.migrations.state import ModelState, ProjectState
+from django.test import TestCase
+
+
+class AutodetectorRenameModelAndFieldTests(TestCase):
+    """
+    Tests for the migration autodetector focused on a bug when renaming
+    a model and a field in the same step.
+    """
+
+    def repr_changes(self, changes):
+        output = ""
+        for app_label, migrations_ in sorted(changes.items()):
+            output += "  %s:\n" % app_label
+            for migration in migrations_:
+                output += "    %s\n" % migration.name
+                for operation in migration.operations:
+                    output += "      %s\n" % operation
+        return output
+
+    def assertNumberMigrations(self, changes, app_label, number):
+        if len(changes.get(app_label, [])) != number:
+            self.fail("Incorrect number of migrations (%s) for %s (expected %s)\n%s" % (
+                len(changes.get(app_label, [])),
+                app_label,
+                number,
+                self.repr_changes(changes),
+            ))
+
+    def assertOperationTypes(self, changes, app_label, position, types):
+        if not changes.get(app_label):
+            self.fail("No migrations found for %s\n%s" % (app_label, self.repr_changes(changes)))
+        if len(changes[app_label]) < position + 1:
+            self.fail("No migration at index %s for %s\n%s" % (position, app_label, self.repr_changes(changes)))
+        migration = changes[app_label][position]
+        real_types = [operation.__class__.__name__ for operation in migration.operations]
+        if types != real_types:
+            self.fail("Operation type mismatch for %s.%s (expected %s):\n%s" % (
+                app_label,
+                migration.name,
+                types,
+                self.repr_changes(changes),
+            ))
+
+    def assertOperationAttributes(self, changes, app_label, position, operation_position, **attrs):
+        if not changes.get(app_label):
+            self.fail("No migrations found for %s\n%s" % (app_label, self.repr_changes(changes)))
+        if len(changes[app_label]) < position + 1:
+            self.fail("No migration at index %s for %s\n%s" % (position, app_label, self.repr_changes(changes)))
+        migration = changes[app_label][position]
+        if len(migration.operations) < operation_position + 1:
+            self.fail("No operation at index %s for %s.%s\n%s" % (
+                operation_position,
+                app_label,
+                migration.name,
+                self.repr_changes(changes),
+            ))
+        operation = migration.operations[operation_position]
+        for attr, value in attrs.items():
+            if getattr(operation, attr, None) != value:
+                self.fail("Attribute mismatch for %s.%s op #%s, %s (expected %r, got %r):\n%s" % (
+                    app_label,
+                    migration.name,
+                    operation_position,
+                    attr,
+                    value,
+                    getattr(operation, attr, None),
+                    self.repr_changes(changes),
+                ))
+
+    def make_project_state(self, model_states):
+        "Shortcut to make ProjectStates from lists of predefined models"
+        project_state = ProjectState()
+        for model_state in model_states:
+            project_state.add_model(model_state.clone())
+        return project_state
+
+    def get_changes(self, before_states, after_states, questioner=None):
+        if not isinstance(before_states, ProjectState):
+            before_states = self.make_project_state(before_states)
+        if not isinstance(after_states, ProjectState):
+            after_states = self.make_project_state(after_states)
+        return MigrationAutodetector(
+            before_states,
+            after_states,
+            questioner,
+        )._detect_changes()
+
+    def test_rename_model_and_field(self):
+        """
+        Tests that the autodetector doesn't crash when a model and a field on
+        it are renamed.
+        """
+        before_states = self.make_project_state([
+            ModelState('test_one', 'MyModel', [
+                ('id', models.AutoField(primary_key=True)),
+                ('field', models.IntegerField()),
+            ]),
+        ])
+        after_states = self.make_project_state([
+            ModelState('test_one', 'MyModel2', [
+                ('id', models.AutoField(primary_key=True)),
+                ('renamed_field', models.IntegerField()),
+            ]),
+        ])
+        questioner = MigrationQuestioner({'ask_rename_model': True, 'ask_rename': True})
+        changes = self.get_changes(before_states, after_states, questioner)
+
+        self.assertNumberMigrations(changes, 'test_one', 1)
+        self.assertOperationTypes(changes, 'test_one', 0, ['RenameField', 'RenameModel'])
+        self.assertOperationAttributes(changes, 'test_one', 0, 0, model_name='mymodel', old_name='field', new_name='renamed_field')
+        self.assertOperationAttributes(changes, 'test_one', 0, 1, old_name='MyModel', new_name='MyModel2')
