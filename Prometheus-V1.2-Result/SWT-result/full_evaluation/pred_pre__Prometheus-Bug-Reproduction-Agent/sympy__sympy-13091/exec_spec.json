{"instance_id": "sympy__sympy-13091", "repo": "sympy/sympy", "version": "1.1", "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3", "patch_list": ["diff --git a/sympy/core/tests/test_rich_comparison.py b/sympy/core/tests/test_rich_comparison.py\nnew file mode 100644\nindex 0000000000..9ece0b8512\n--- /dev/null\n+++ b/sympy/core/tests/test_rich_comparison.py\n@@ -0,0 +1,31 @@\n+from sympy import S, Symbol\n+from sympy.core.basic import Basic\n+\n+\n+def test_rich_comparison_not_implemented():\n+    \"\"\"\n+    Test that comparisons with unknown types return NotImplemented, allowing\n+    the other type to handle the comparison.\n+    \"\"\"\n+    class Foo:\n+        def __init__(self, value):\n+            self.value = value\n+\n+        def __eq__(self, other):\n+            if isinstance(other, Basic):\n+                return self.value == other\n+            return NotImplemented\n+\n+        def __ne__(self, other):\n+            eq = self.__eq__(other)\n+            if eq is not NotImplemented:\n+                return not eq\n+            return NotImplemented\n+\n+    f = Foo(1)\n+    s = S(1)\n+\n+    # s == f calls Basic.__eq__(s, f). The bug is that this returns False\n+    # instead of NotImplemented. If it returned NotImplemented, Python would\n+    # then try the reflected operation, f.__eq__(s), which would return True.\n+    assert s == f\n"], "arch": "x86_64", "base_commit": "d1320814eda6549996190618a21eaf212cfd4d1e", "test_directives": ["sympy/core/tests/test_rich_comparison.py"], "coverage_files": ["sympy/utilities/enumerative.py", "sympy/physics/optics/medium.py", "sympy/geometry/entity.py", "sympy/polys/domains/pythonrational.py", "sympy/polys/agca/modules.py", "sympy/polys/monomials.py", "sympy/tensor/array/ndim_array.py", "sympy/polys/domains/quotientring.py", "sympy/core/numbers.py", "sympy/polys/domains/domain.py", "sympy/polys/domains/expressiondomain.py", "sympy/polys/rings.py", "sympy/core/exprtools.py", "sympy/physics/vector/frame.py", "sympy/polys/rootoftools.py", "sympy/core/basic.py", "sympy/polys/polytools.py", "sympy/physics/vector/vector.py", "sympy/physics/vector/dyadic.py", "sympy/polys/polyclasses.py", "sympy/polys/fields.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.9", "packages": "mpmath flake8", "pip_packages": ["mpmath==1.3.0", "flake8-comprehensions"], "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "PYTHONWARNINGS='ignore::UserWarning,ignore::SyntaxWarning' python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(sympy/utilities/enumerative\\.py|sympy/physics/optics/medium\\.py|sympy/geometry/entity\\.py|sympy/polys/domains/pythonrational\\.py|sympy/polys/agca/modules\\.py|sympy/polys/monomials\\.py|sympy/tensor/array/ndim_array\\.py|sympy/polys/domains/quotientring\\.py|sympy/core/numbers\\.py|sympy/polys/domains/domain\\.py|sympy/polys/domains/expressiondomain\\.py|sympy/polys/rings\\.py|sympy/core/exprtools\\.py|sympy/physics/vector/frame\\.py|sympy/polys/rootoftools\\.py|sympy/core/basic\\.py|sympy/polys/polytools\\.py|sympy/physics/vector/vector\\.py|sympy/physics/vector/dyadic\\.py|sympy/polys/polyclasses\\.py|sympy/polys/fields\\.py)' bin/test -C --verbose sympy/core/tests/test_rich_comparison.p", "req_install_commands": ["conda create -n testbed python=3.9 mpmath flake8 -y"]}