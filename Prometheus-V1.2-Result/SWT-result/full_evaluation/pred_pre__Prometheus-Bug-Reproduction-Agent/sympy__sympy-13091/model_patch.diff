diff --git a/sympy/core/tests/test_rich_comparison.py b/sympy/core/tests/test_rich_comparison.py
new file mode 100644
index 0000000000..9ece0b8512
--- /dev/null
+++ b/sympy/core/tests/test_rich_comparison.py
@@ -0,0 +1,31 @@
+from sympy import S, Symbol
+from sympy.core.basic import Basic
+
+
+def test_rich_comparison_not_implemented():
+    """
+    Test that comparisons with unknown types return NotImplemented, allowing
+    the other type to handle the comparison.
+    """
+    class Foo:
+        def __init__(self, value):
+            self.value = value
+
+        def __eq__(self, other):
+            if isinstance(other, Basic):
+                return self.value == other
+            return NotImplemented
+
+        def __ne__(self, other):
+            eq = self.__eq__(other)
+            if eq is not NotImplemented:
+                return not eq
+            return NotImplemented
+
+    f = Foo(1)
+    s = S(1)
+
+    # s == f calls Basic.__eq__(s, f). The bug is that this returns False
+    # instead of NotImplemented. If it returned NotImplemented, Python would
+    # then try the reflected operation, f.__eq__(s), which would return True.
+    assert s == f
