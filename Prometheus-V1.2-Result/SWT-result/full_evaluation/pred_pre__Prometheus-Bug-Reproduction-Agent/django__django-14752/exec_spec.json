{"instance_id": "django__django-14752", "repo": "django/django", "version": "4.0", "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4", "patch_list": ["diff --git a/tests/admin_views/test_autocomplete_extensibility.py b/tests/admin_views/test_autocomplete_extensibility.py\nnew file mode 100644\nindex 0000000000..934fb2acbd\n--- /dev/null\n+++ b/tests/admin_views/test_autocomplete_extensibility.py\n@@ -0,0 +1,197 @@\n+import json\n+from contextlib import contextmanager\n+\n+from django.contrib import admin\n+from django.contrib.admin.tests import AdminSeleniumTestCase\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+from django.contrib.auth.models import Permission, User\n+from django.contrib.contenttypes.models import ContentType\n+from django.core.exceptions import PermissionDenied\n+from django.http import Http404\n+from django.test import RequestFactory, override_settings\n+from django.urls import reverse, reverse_lazy\n+\n+from .admin import AnswerAdmin, QuestionAdmin\n+from .models import (\n+    Answer, Author, Authorship, Bonus, Book, Employee, Manager, Parent,\n+    PKChild, Question, Toy, WorkHour,\n+)\n+from .tests import AdminViewBasicTestCase\n+\n+PAGINATOR_SIZE = AutocompleteJsonView.paginate_by\n+\n+\n+class AuthorAdmin(admin.ModelAdmin):\n+    ordering = ['id']\n+    search_fields = ['id']\n+\n+\n+class AuthorshipInline(admin.TabularInline):\n+    model = Authorship\n+    autocomplete_fields = ['author']\n+\n+\n+class BookAdmin(admin.ModelAdmin):\n+    inlines = [AuthorshipInline]\n+\n+\n+site = admin.AdminSite(name='autocomplete_admin')\n+site.register(Question, QuestionAdmin)\n+site.register(Answer, AnswerAdmin)\n+site.register(Author, AuthorAdmin)\n+site.register(Book, BookAdmin)\n+site.register(Employee, search_fields=['name'])\n+site.register(WorkHour, autocomplete_fields=['employee'])\n+site.register(Manager, search_fields=['name'])\n+site.register(Bonus, autocomplete_fields=['recipient'])\n+site.register(PKChild, search_fields=['name'])\n+site.register(Toy, autocomplete_fields=['child'])\n+\n+\n+@contextmanager\n+def model_admin(model, model_admin, admin_site=site):\n+    org_admin = admin_site._registry.get(model)\n+    if org_admin:\n+        admin_site.unregister(model)\n+    admin_site.register(model, model_admin)\n+    try:\n+        yield\n+    finally:\n+        if org_admin:\n+            admin_site._registry[model] = org_admin\n+\n+\n+class AutocompleteJsonViewTests(AdminViewBasicTestCase):\n+    as_view_args = {'admin_site': site}\n+    opts = {\n+        'app_label': Answer._meta.app_label,\n+        'model_name': Answer._meta.model_name,\n+        'field_name': 'question'\n+    }\n+    factory = RequestFactory()\n+    url = reverse_lazy('autocomplete_admin:autocomplete')\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.user = User.objects.create_user(\n+            username='user', password='secret',\n+            email='user@example.com', is_staff=True,\n+        )\n+        super().setUpTestData()\n+\n+    def test_success(self):\n+        q = Question.objects.create(question='Is this a question?')\n+        request = self.factory.get(self.url, {'term': 'is', **self.opts})\n+        request.user = self.superuser\n+        response = AutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [{'id': str(q.pk), 'text': q.question}],\n+            'pagination': {'more': False},\n+        })\n+\n+    def test_custom_to_field(self):\n+        q = Question.objects.create(question='Is this a question?')\n+        request = self.factory.get(self.url, {'term': 'is', **self.opts, 'field_name': 'question_with_to_field'})\n+        request.user = self.superuser\n+        response = AutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [{'id': str(q.uuid), 'text': q.question}],\n+            'pagination': {'more': False},\n+        })\n+\n+    def test_custom_to_field_permission_denied(self):\n+        Question.objects.create(question='Is this a question?')\n+        request = self.factory.get(self.url, {'term': 'is', **self.opts, 'field_name': 'question_with_to_field'})\n+        request.user = self.user\n+        with self.assertRaises(PermissionDenied):\n+            AutocompleteJsonView.as_view(**self.as_view_args)(request)\n+\n+    def test_custom_to_field_custom_pk(self):\n+        q = Question.objects.create(question='Is this a question?')\n+        opts = {\n+            'app_label': Question._meta.app_label,\n+            'model_name': Question._meta.model_name,\n+            'field_name': 'related_questions',\n+        }\n+        request = self.factory.get(self.url, {'term': 'is', **opts})\n+        request.user = self.superuser\n+        response = AutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [{'id': str(q.big_id), 'text': q.question}],\n+            'pagination': {'more': False},\n+        })\n+\n+    def test_to_field_resolution_with_mti(self):\n+        \"\"\"\n+        to_field resolution should correctly resolve for target models using\n+        MTI. Tests for single and multi-level cases.\n+        \"\"\"\n+        tests = [\n+            (Employee, WorkHour, 'employee'),\n+            (Manager, Bonus, 'recipient'),\n+        ]\n+        for Target, Remote, related_name in tests:\n+            with self.subTest(target_model=Target, remote_model=Remote, related_name=related_name):\n+                o = Target.objects.create(name=\"Frida Kahlo\", gender=2, code=\"painter\", alive=False)\n+                opts = {\n+                    'app_label': Remote._meta.app_label,\n+                    'model_name': Remote._meta.model_name,\n+                    'field_name': related_name,\n+                }\n+                request = self.factory.get(self.url, {'term': 'frida', **opts})\n+                request.user = self.superuser\n+                response = AutocompleteJsonView.as_view(**self.as_view_args)(request)\n+                self.assertEqual(response.status_code, 200)\n+                data = json.loads(response.content.decode('utf-8'))\n+                self.assertEqual(data, {\n+                    'results': [{'id': str(o.pk), 'text': o.name}],\n+                    'pagination': {'more': False},\n+                })\n+\n+    def test_to_field_resolution_with_fk_pk(self):\n+        p = Parent.objects.create(name=\"Bertie\")\n+        c = PKChild.objects.create(parent=p, name=\"Anna\")\n+        opts = {\n+            'app_label': Toy._meta.app_label,\n+            'model_name': Toy._meta.model_name,\n+            'field_name': 'child',\n+        }\n+        request = self.factory.get(self.url, {'term': 'anna', **opts})\n+        request.user = self.superuser\n+        response = AutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [{'id': str(c.pk), 'text': c.name}],\n+            'pagination': {'more': False},\n+        })\n+\n+    def test_serialize_result_hook(self):\n+        \"\"\"\n+        AutocompleteJsonView should have a `serialize_result` hook to allow\n+        easy customization of the result data, as proposed in the issue.\n+        \"\"\"\n+        class CustomAutocompleteJsonView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                return super().serialize_result(obj, to_field_name) | {'notes': str(obj.uuid)}\n+\n+        q = Question.objects.create(question='Is this a question?')\n+        request = self.factory.get(self.url, {'term': 'is', **self.opts})\n+        request.user = self.superuser\n+        response = CustomAutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [{\n+                'id': str(q.pk),\n+                'text': q.question,\n+                'notes': str(q.uuid),\n+            }],\n+            'pagination': {'more': False},\n+        })\n"], "arch": "x86_64", "base_commit": "b64db05b9cedd96905d637a2d824cbbf428e40e7", "test_directives": ["admin_views.test_autocomplete_extensibility"], "coverage_files": ["django/contrib/admin/views/autocomplete.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.8", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/contrib/admin/views/autocomplete\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 admin_views.test_autocomplete_extensibility", "req_install_commands": ["conda create -n testbed python=3.8 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}