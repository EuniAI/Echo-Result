{"instance_id": "django__django-13809", "repo": "django/django", "version": "4.0", "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4", "patch_list": ["diff --git a/tests/builtin_server/test_runserver_command.py b/tests/builtin_server/test_runserver_command.py\nnew file mode 100644\nindex 0000000000..ed124934eb\n--- /dev/null\n+++ b/tests/builtin_server/test_runserver_command.py\n@@ -0,0 +1,190 @@\n+import sys\n+import traceback\n+from io import BytesIO\n+from unittest import TestCase, mock\n+from wsgiref import simple_server\n+\n+from django.core.management import call_command\n+from django.core.servers.basehttp import get_internal_wsgi_application\n+from django.core.signals import request_finished\n+from django.test import RequestFactory, SimpleTestCase, override_settings\n+\n+from .views import FILE_RESPONSE_HOLDER\n+\n+# If data is too large, socket will choke, so write chunks no larger than 32MB\n+# at a time. The rationale behind the 32MB can be found in #5596#comment:4.\n+MAX_SOCKET_CHUNK_SIZE = 32 * 1024 * 1024  # 32 MB\n+\n+\n+class ServerHandler(simple_server.ServerHandler):\n+    error_status = \"500 INTERNAL SERVER ERROR\"\n+\n+    def write(self, data):\n+        \"\"\"'''write()''' callable as specified by PEP 3333\"\"\"\n+\n+        assert isinstance(data, bytes), \"write() argument must be bytestring\"\n+\n+        if not self.status:\n+            raise AssertionError(\"write() before start_response()\")\n+\n+        elif not self.headers_sent:\n+            # Before the first output, send the stored headers\n+            self.bytes_sent = len(data)    # make sure we know content-length\n+            self.send_headers()\n+        else:\n+            self.bytes_sent += len(data)\n+\n+        # XXX check Content-Length and truncate if too many bytes written?\n+        data = BytesIO(data)\n+        for chunk in iter(lambda: data.read(MAX_SOCKET_CHUNK_SIZE), b''):\n+            self._write(chunk)\n+            self._flush()\n+\n+    def error_output(self, environ, start_response):\n+        super().error_output(environ, start_response)\n+        return ['\\n'.join(traceback.format_exception(*sys.exc_info()))]\n+\n+\n+class DummyHandler:\n+    def log_request(self, *args, **kwargs):\n+        pass\n+\n+\n+class FileWrapperHandler(ServerHandler):\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.request_handler = DummyHandler()\n+        self._used_sendfile = False\n+\n+    def sendfile(self):\n+        self._used_sendfile = True\n+        return True\n+\n+\n+def wsgi_app(environ, start_response):\n+    start_response('200 OK', [('Content-Type', 'text/plain')])\n+    return [b'Hello World!']\n+\n+\n+def wsgi_app_file_wrapper(environ, start_response):\n+    start_response('200 OK', [('Content-Type', 'text/plain')])\n+    return environ['wsgi.file_wrapper'](BytesIO(b'foo'))\n+\n+\n+class WSGIFileWrapperTests(TestCase):\n+    \"\"\"\n+    The wsgi.file_wrapper works for the builtin server.\n+\n+    Tests for #9659: wsgi.file_wrapper in the builtin server.\n+    We need to mock a couple of handlers and keep track of what\n+    gets called when using a couple kinds of WSGI apps.\n+    \"\"\"\n+\n+    def test_file_wrapper_uses_sendfile(self):\n+        env = {'SERVER_PROTOCOL': 'HTTP/1.0'}\n+        handler = FileWrapperHandler(None, BytesIO(), BytesIO(), env)\n+        handler.run(wsgi_app_file_wrapper)\n+        self.assertTrue(handler._used_sendfile)\n+        self.assertEqual(handler.stdout.getvalue(), b'')\n+        self.assertEqual(handler.stderr.getvalue(), b'')\n+\n+    def test_file_wrapper_no_sendfile(self):\n+        env = {'SERVER_PROTOCOL': 'HTTP/1.0'}\n+        handler = FileWrapperHandler(None, BytesIO(), BytesIO(), env)\n+        handler.run(wsgi_app)\n+        self.assertFalse(handler._used_sendfile)\n+        self.assertEqual(handler.stdout.getvalue().splitlines()[-1], b'Hello World!')\n+        self.assertEqual(handler.stderr.getvalue(), b'')\n+\n+    @override_settings(ROOT_URLCONF='builtin_server.urls')\n+    def test_file_response_closing(self):\n+        \"\"\"\n+        View returning a FileResponse properly closes the file and http\n+        response when file_wrapper is used.\n+        \"\"\"\n+        env = RequestFactory().get('/fileresponse/').environ\n+        handler = FileWrapperHandler(None, BytesIO(), BytesIO(), env)\n+        handler.run(get_internal_wsgi_application())\n+        # Sendfile is used only when file_wrapper has been used.\n+        self.assertTrue(handler._used_sendfile)\n+        # Fetch the original response object.\n+        self.assertIn('response', FILE_RESPONSE_HOLDER)\n+        response = FILE_RESPONSE_HOLDER['response']\n+        # The response and file buffers are closed.\n+        self.assertIs(response.closed, True)\n+        buf1, buf2 = FILE_RESPONSE_HOLDER['buffers']\n+        self.assertIs(buf1.closed, True)\n+        self.assertIs(buf2.closed, True)\n+        FILE_RESPONSE_HOLDER.clear()\n+\n+    @override_settings(ROOT_URLCONF='builtin_server.urls')\n+    def test_file_response_call_request_finished(self):\n+        env = RequestFactory().get('/fileresponse/').environ\n+        handler = FileWrapperHandler(None, BytesIO(), BytesIO(), env)\n+        with mock.MagicMock() as signal_handler:\n+            request_finished.connect(signal_handler)\n+            handler.run(get_internal_wsgi_application())\n+            self.assertEqual(signal_handler.call_count, 1)\n+\n+\n+class WriteChunkCounterHandler(ServerHandler):\n+    \"\"\"\n+    Server handler that counts the number of chunks written after headers were\n+    sent. Used to make sure large response body chunking works properly.\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.request_handler = DummyHandler()\n+        self.headers_written = False\n+        self.write_chunk_counter = 0\n+\n+    def send_headers(self):\n+        super().send_headers()\n+        self.headers_written = True\n+\n+    def _write(self, data):\n+        if self.headers_written:\n+            self.write_chunk_counter += 1\n+        self.stdout.write(data)\n+\n+\n+def send_big_data_app(environ, start_response):\n+    start_response('200 OK', [('Content-Type', 'text/plain')])\n+    # Return a blob of data that is 1.5 times the maximum chunk size.\n+    return [b'x' * (MAX_SOCKET_CHUNK_SIZE + MAX_SOCKET_CHUNK_SIZE // 2)]\n+\n+\n+class ServerHandlerChunksProperly(TestCase):\n+    \"\"\"\n+    The ServerHandler chunks data properly.\n+\n+    Tests for #18972: The logic that performs the math to break data into\n+    32MB (MAX_SOCKET_CHUNK_SIZE) chunks was flawed, BUT it didn't actually\n+    cause any problems.\n+    \"\"\"\n+\n+    def test_chunked_data(self):\n+        env = {'SERVER_PROTOCOL': 'HTTP/1.0'}\n+        handler = WriteChunkCounterHandler(None, BytesIO(), BytesIO(), env)\n+        handler.run(send_big_data_app)\n+        self.assertEqual(handler.write_chunk_counter, 2)\n+\n+\n+class RunserverCommandTests(SimpleTestCase):\n+    @override_settings(\n+        STATICFILES_DIRS='foo',\n+        INSTALLED_APPS=[\n+            'django.contrib.auth',\n+            'django.contrib.contenttypes',\n+            'django.contrib.staticfiles',\n+        ],\n+    )\n+    @mock.patch('django.core.servers.basehttp.run')\n+    def test_skip_checks_option(self, mocked_run):\n+        \"\"\"\n+        The runserver command should not perform system checks with\n+        --skip-checks.\n+        \"\"\"\n+        call_command('runserver', '--skip-checks')\n+        mocked_run.assert_called_once()\n"], "arch": "x86_64", "base_commit": "bef6f7584280f1cc80e5e2d80b7ad073a93d26ec", "test_directives": ["builtin_server.test_runserver_command"], "coverage_files": ["django/core/management/commands/runserver.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.8", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/core/management/commands/runserver\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 builtin_server.test_runserver_command", "req_install_commands": ["conda create -n testbed python=3.8 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}