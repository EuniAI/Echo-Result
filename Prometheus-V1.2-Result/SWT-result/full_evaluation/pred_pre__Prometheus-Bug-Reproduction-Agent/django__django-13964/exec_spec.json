{"instance_id": "django__django-13964", "repo": "django/django", "version": "4.0", "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4", "patch_list": ["diff --git a/tests/model_fields/test_foreignkey_regress.py b/tests/model_fields/test_foreignkey_regress.py\nnew file mode 100644\nindex 0000000000..212d146893\n--- /dev/null\n+++ b/tests/model_fields/test_foreignkey_regress.py\n@@ -0,0 +1,159 @@\n+from decimal import Decimal\n+\n+from django.apps import apps\n+from django.core import checks\n+from django.core.exceptions import FieldError\n+from django.db import models, transaction\n+from django.test import TestCase, skipIfDBFeature\n+from django.test.utils import isolate_apps\n+\n+from .models import Bar, FkToChar, Foo, PrimaryKeyCharModel\n+\n+\n+class ForeignKeyTests(TestCase):\n+\n+    def test_callable_default(self):\n+        \"\"\"A lazy callable may be used for ForeignKey.default.\"\"\"\n+        a = Foo.objects.create(id=1, a='abc', d=Decimal('12.34'))\n+        b = Bar.objects.create(b='bcd')\n+        self.assertEqual(b.a, a)\n+\n+    @skipIfDBFeature('interprets_empty_strings_as_nulls')\n+    def test_empty_string_fk(self):\n+        \"\"\"\n+        Empty strings foreign key values don't get converted to None (#19299).\n+        \"\"\"\n+        char_model_empty = PrimaryKeyCharModel.objects.create(string='')\n+        fk_model_empty = FkToChar.objects.create(out=char_model_empty)\n+        fk_model_empty = FkToChar.objects.select_related('out').get(id=fk_model_empty.pk)\n+        self.assertEqual(fk_model_empty.out, char_model_empty)\n+\n+    def test_fk_to_char_pk_late_assignment(self):\n+        with transaction.atomic():\n+            order = FkToChar()\n+            product = PrimaryKeyCharModel()\n+            order.out = product\n+            product.string = 'foo'\n+            product.save()\n+            order.save()\n+            self.assertTrue(FkToChar.objects.filter(out=product).exists())\n+\n+    @isolate_apps('model_fields')\n+    def test_warning_when_unique_true_on_fk(self):\n+        class Foo(models.Model):\n+            pass\n+\n+        class FKUniqueTrue(models.Model):\n+            fk_field = models.ForeignKey(Foo, models.CASCADE, unique=True)\n+\n+        model = FKUniqueTrue()\n+        expected_warnings = [\n+            checks.Warning(\n+                'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',\n+                hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',\n+                obj=FKUniqueTrue.fk_field.field,\n+                id='fields.W342',\n+            )\n+        ]\n+        warnings = model.check()\n+        self.assertEqual(warnings, expected_warnings)\n+\n+    def test_related_name_converted_to_text(self):\n+        rel_name = Bar._meta.get_field('a').remote_field.related_name\n+        self.assertIsInstance(rel_name, str)\n+\n+    def test_abstract_model_pending_operations(self):\n+        \"\"\"\n+        Foreign key fields declared on abstract models should not add lazy\n+        relations to resolve relationship declared as string (#24215).\n+        \"\"\"\n+        pending_ops_before = list(apps._pending_operations.items())\n+\n+        class AbstractForeignKeyModel(models.Model):\n+            fk = models.ForeignKey('missing.FK', models.CASCADE)\n+\n+            class Meta:\n+                abstract = True\n+\n+        self.assertIs(AbstractForeignKeyModel._meta.apps, apps)\n+        self.assertEqual(\n+            pending_ops_before,\n+            list(apps._pending_operations.items()),\n+            'Pending lookup added for a foreign key on an abstract model'\n+        )\n+\n+    @isolate_apps('model_fields', 'model_fields.tests')\n+    def test_abstract_model_app_relative_foreign_key(self):\n+        class AbstractReferent(models.Model):\n+            reference = models.ForeignKey('Referred', on_delete=models.CASCADE)\n+\n+            class Meta:\n+                app_label = 'model_fields'\n+                abstract = True\n+\n+        def assert_app_model_resolved(label):\n+            class Referred(models.Model):\n+                class Meta:\n+                    app_label = label\n+\n+            class ConcreteReferent(AbstractReferent):\n+                class Meta:\n+                    app_label = label\n+\n+            self.assertEqual(ConcreteReferent._meta.get_field('reference').related_model, Referred)\n+\n+        assert_app_model_resolved('model_fields')\n+        assert_app_model_resolved('tests')\n+\n+    @isolate_apps('model_fields')\n+    def test_to_python(self):\n+        class Foo(models.Model):\n+            pass\n+\n+        class Bar(models.Model):\n+            fk = models.ForeignKey(Foo, models.CASCADE)\n+\n+        self.assertEqual(Bar._meta.get_field('fk').to_python('1'), 1)\n+\n+    @isolate_apps('model_fields')\n+    def test_fk_to_fk_get_col_output_field(self):\n+        class Foo(models.Model):\n+            pass\n+\n+        class Bar(models.Model):\n+            foo = models.ForeignKey(Foo, models.CASCADE, primary_key=True)\n+\n+        class Baz(models.Model):\n+            bar = models.ForeignKey(Bar, models.CASCADE, primary_key=True)\n+\n+        col = Baz._meta.get_field('bar').get_col('alias')\n+        self.assertIs(col.output_field, Foo._meta.pk)\n+\n+    @isolate_apps('model_fields')\n+    def test_recursive_fks_get_col(self):\n+        class Foo(models.Model):\n+            bar = models.ForeignKey('Bar', models.CASCADE, primary_key=True)\n+\n+        class Bar(models.Model):\n+            foo = models.ForeignKey(Foo, models.CASCADE, primary_key=True)\n+\n+        with self.assertRaisesMessage(ValueError, 'Cannot resolve output_field'):\n+            Foo._meta.get_field('bar').get_col('alias')\n+\n+    @isolate_apps('model_fields')\n+    def test_non_local_to_field(self):\n+        class Parent(models.Model):\n+            key = models.IntegerField(unique=True)\n+\n+        class Child(Parent):\n+            pass\n+\n+        class Related(models.Model):\n+            child = models.ForeignKey(Child, on_delete=models.CASCADE, to_field='key')\n+\n+        msg = (\n+            \"'model_fields.Related.child' refers to field 'key' which is not \"\n+            \"local to model 'model_fields.Child'.\"\n+        )\n+        with self.assertRaisesMessage(FieldError, msg):\n+            Related._meta.get_field('child').related_fields\n"], "arch": "x86_64", "base_commit": "f39634ff229887bf7790c069d0c411b38494ca38", "test_directives": ["model_fields.test_foreignkey_regress"], "coverage_files": ["django/db/models/base.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.8", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/models/base\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 model_fields.test_foreignkey_regress", "req_install_commands": ["conda create -n testbed python=3.8 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}