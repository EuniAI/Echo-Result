{"instance_id": "django__django-16454", "repo": "django/django", "version": "5.0", "environment_setup_commit": "4a72da71001f154ea60906a2f74898d32b7322a7", "patch_list": ["diff --git a/tests/admin_scripts/test_management_parser.py b/tests/admin_scripts/test_management_parser.py\nnew file mode 100644\nindex 0000000000..b03d0f4b67\n--- /dev/null\n+++ b/tests/admin_scripts/test_management_parser.py\n@@ -0,0 +1,203 @@\n+import os\n+import re\n+import shutil\n+import subprocess\n+import sys\n+import tempfile\n+\n+from django import conf\n+from django.conf import settings\n+from django.test import SimpleTestCase\n+\n+\n+class AdminScriptTestCase(SimpleTestCase):\n+    def setUp(self):\n+        tmpdir = tempfile.TemporaryDirectory()\n+        self.addCleanup(tmpdir.cleanup)\n+        # os.path.realpath() is required for temporary directories on macOS,\n+        # where `/var` is a symlink to `/private/var`.\n+        self.test_dir = os.path.realpath(os.path.join(tmpdir.name, \"test_project\"))\n+        os.mkdir(self.test_dir)\n+\n+    def write_settings(self, filename, apps=None, is_dir=False, sdict=None, extra=None):\n+        if is_dir:\n+            settings_dir = os.path.join(self.test_dir, filename)\n+            os.mkdir(settings_dir)\n+            settings_file_path = os.path.join(settings_dir, \"__init__.py\")\n+        else:\n+            settings_file_path = os.path.join(self.test_dir, filename)\n+\n+        with open(settings_file_path, \"w\") as settings_file:\n+            settings_file.write(\n+                \"# Settings file automatically generated by admin_scripts test case\\n\"\n+            )\n+            if extra:\n+                settings_file.write(\"%s\\n\" % extra)\n+            exports = [\n+                \"DATABASES\",\n+                \"DEFAULT_AUTO_FIELD\",\n+                \"ROOT_URLCONF\",\n+                \"SECRET_KEY\",\n+                \"USE_TZ\",\n+            ]\n+            for s in exports:\n+                if hasattr(settings, s):\n+                    o = getattr(settings, s)\n+                    if not isinstance(o, (dict, tuple, list)):\n+                        o = \"'%s'\" % o\n+                    settings_file.write(\"%s = %s\\n\" % (s, o))\n+\n+            if apps is None:\n+                apps = [\n+                    \"django.contrib.auth\",\n+                    \"django.contrib.contenttypes\",\n+                    \"admin_scripts\",\n+                ]\n+\n+            settings_file.write(\"INSTALLED_APPS = %s\\n\" % apps)\n+\n+            if sdict:\n+                for k, v in sdict.items():\n+                    settings_file.write(\"%s = %s\\n\" % (k, v))\n+\n+    def _ext_backend_paths(self):\n+        \"\"\"\n+        Returns the paths for any external backend packages.\n+        \"\"\"\n+        paths = []\n+        for backend in settings.DATABASES.values():\n+            package = backend[\"ENGINE\"].split(\".\")[0]\n+            if package != \"django\":\n+                backend_pkg = __import__(package)\n+                backend_dir = os.path.dirname(backend_pkg.__file__)\n+                paths.append(os.path.dirname(backend_dir))\n+        return paths\n+\n+    def run_test(self, args, settings_file=None, apps=None, umask=-1):\n+        base_dir = os.path.dirname(self.test_dir)\n+        # The base dir for Django's tests is one level up.\n+        tests_dir = os.path.dirname(os.path.dirname(__file__))\n+        # The base dir for Django is one level above the test dir. We don't use\n+        # `import django` to figure that out, so we don't pick up a Django\n+        # from site-packages or similar.\n+        django_dir = os.path.dirname(tests_dir)\n+        ext_backend_base_dirs = self._ext_backend_paths()\n+\n+        # Define a temporary environment for the subprocess\n+        test_environ = os.environ.copy()\n+\n+        # Set the test environment\n+        if settings_file:\n+            test_environ[\"DJANGO_SETTINGS_MODULE\"] = settings_file\n+        elif \"DJANGO_SETTINGS_MODULE\" in test_environ:\n+            del test_environ[\"DJANGO_SETTINGS_MODULE\"]\n+        python_path = [base_dir, django_dir, tests_dir]\n+        python_path.extend(ext_backend_base_dirs)\n+        test_environ[\"PYTHONPATH\"] = os.pathsep.join(python_path)\n+        test_environ[\"PYTHONWARNINGS\"] = \"\"\n+\n+        p = subprocess.run(\n+            [sys.executable, *args],\n+            capture_output=True,\n+            cwd=self.test_dir,\n+            env=test_environ,\n+            text=True,\n+            umask=umask,\n+        )\n+        return p.stdout, p.stderr\n+\n+    def run_manage(self, args, settings_file=None, manage_py=None):\n+        template_manage_py = (\n+            os.path.join(os.path.dirname(__file__), manage_py)\n+            if manage_py\n+            else os.path.join(\n+                os.path.dirname(conf.__file__), \"project_template\", \"manage.py-tpl\"\n+            )\n+        )\n+        test_manage_py = os.path.join(self.test_dir, \"manage.py\")\n+        shutil.copyfile(template_manage_py, test_manage_py)\n+\n+        with open(test_manage_py) as fp:\n+            manage_py_contents = fp.read()\n+        manage_py_contents = manage_py_contents.replace(\n+            \"{{ project_name }}\", \"test_project\"\n+        )\n+        with open(test_manage_py, \"w\") as fp:\n+            fp.write(manage_py_contents)\n+\n+        return self.run_test([\"./manage.py\", *args], settings_file)\n+\n+    def assertNoOutput(self, stream):\n+        \"Utility assertion: assert that the given stream is empty\"\n+        self.assertEqual(\n+            len(stream), 0, \"Stream should be empty: actually contains '%s'\" % stream\n+        )\n+\n+    def assertOutput(self, stream, msg, regex=False):\n+        \"Utility assertion: assert that the given message exists in the output\"\n+        if regex:\n+            self.assertIsNotNone(\n+                re.search(msg, stream),\n+                \"'%s' does not match actual output text '%s'\" % (msg, stream),\n+            )\n+        else:\n+            self.assertIn(\n+                msg,\n+                stream,\n+                \"'%s' does not match actual output text '%s'\" % (msg, stream),\n+            )\n+\n+\n+class ManagementParserSubparserTests(AdminScriptTestCase):\n+    def test_subparser_required_argument_error(self):\n+        \"\"\"\n+        A missing required argument on a subparser should produce a\n+        user-friendly error message, not a traceback.\n+        \"\"\"\n+        # Create an app with a management command.\n+        app_dir = os.path.join(self.test_dir, \"test_app\")\n+        os.mkdir(app_dir)\n+        with open(os.path.join(app_dir, \"__init__.py\"), \"w\"):\n+            pass\n+        commands_dir = os.path.join(app_dir, \"management\", \"commands\")\n+        os.makedirs(commands_dir)\n+        with open(os.path.join(commands_dir, \"__init__.py\"), \"w\"):\n+            pass\n+        command_py = os.path.join(commands_dir, \"cheeses.py\")\n+        with open(command_py, \"w\") as f:\n+            f.write(\n+                \"from django.core.management.base import BaseCommand\\n\"\n+                \"class Command(BaseCommand):\\n\"\n+                \"    def add_arguments(self, parser):\\n\"\n+                \"        subparsers = parser.add_subparsers(required=True)\\n\"\n+                '        create = subparsers.add_parser(\"create\")\\n'\n+                '        create.add_argument(\"name\")\\n'\n+                \"    def handle(self, *args, **options):\\n\"\n+                \"        pass\\n\"\n+            )\n+\n+        # The manage.py script created by run_manage() uses\n+        # \"test_project.settings\" as the settings module, so a project\n+        # package is required.\n+        project_dir = os.path.join(self.test_dir, \"test_project\")\n+        os.mkdir(project_dir)\n+        with open(os.path.join(project_dir, \"__init__.py\"), \"w\"):\n+            pass\n+\n+        self.write_settings(\n+            os.path.join(\"test_project\", \"settings.py\"),\n+            apps=[\n+                \"django.contrib.auth\",\n+                \"django.contrib.contenttypes\",\n+                \"test_app\",\n+            ],\n+        )\n+\n+        out, err = self.run_manage([\"cheeses\", \"create\"])\n+        self.assertNoOutput(out)\n+        # This assertion checks for the correct, user-friendly error message\n+        # that argparse should produce. It will FAIL now because the bug\n+        # causes a CommandError traceback instead.\n+        self.assertOutput(\n+            err, \"manage.py cheeses create: error: the following arguments are required: name\"\n+        )\n"], "arch": "x86_64", "base_commit": "1250483ebf73f7a82ff820b94092c63ce4238264", "test_directives": ["admin_scripts.test_management_parser"], "coverage_files": ["django/core/management/base.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.11", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/core/management/base\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 admin_scripts.test_management_parser", "req_install_commands": ["conda create -n testbed python=3.11 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\naiosmtpd\nasgiref >= 3.7.0\nargon2-cffi >= 19.2.0\nbcrypt\nblack\ndocutils\ngeoip2; python_version < '3.12'\njinja2 >= 2.11.0\nnumpy; python_version < '3.12'\nPillow >= 6.2.1; sys.platform != 'win32' or python_version < '3.12'\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.4.0\nselenium >= 4.8.0\nsqlparse >= 0.3.1\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}