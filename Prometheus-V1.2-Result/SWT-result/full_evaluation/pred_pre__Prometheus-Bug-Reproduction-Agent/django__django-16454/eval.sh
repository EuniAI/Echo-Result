#!/bin/bash
set -uxo pipefail
source /opt/miniconda3/bin/activate
conda activate testbed
cd /testbed
git diff HEAD 1250483ebf73f7a82ff820b94092c63ce4238264 >> /root/pre_state.patch
git config --global --add safe.directory /testbed
cd /testbed
git status
git show
git diff 1250483ebf73f7a82ff820b94092c63ce4238264
source /opt/miniconda3/bin/activate
conda activate testbed
python -m pip install -e .
git apply -v - <<'EOF_114329324912'
diff --git a/tests/admin_scripts/test_management_parser.py b/tests/admin_scripts/test_management_parser.py
new file mode 100644
index 0000000000..b03d0f4b67
--- /dev/null
+++ b/tests/admin_scripts/test_management_parser.py
@@ -0,0 +1,203 @@
+import os
+import re
+import shutil
+import subprocess
+import sys
+import tempfile
+
+from django import conf
+from django.conf import settings
+from django.test import SimpleTestCase
+
+
+class AdminScriptTestCase(SimpleTestCase):
+    def setUp(self):
+        tmpdir = tempfile.TemporaryDirectory()
+        self.addCleanup(tmpdir.cleanup)
+        # os.path.realpath() is required for temporary directories on macOS,
+        # where `/var` is a symlink to `/private/var`.
+        self.test_dir = os.path.realpath(os.path.join(tmpdir.name, "test_project"))
+        os.mkdir(self.test_dir)
+
+    def write_settings(self, filename, apps=None, is_dir=False, sdict=None, extra=None):
+        if is_dir:
+            settings_dir = os.path.join(self.test_dir, filename)
+            os.mkdir(settings_dir)
+            settings_file_path = os.path.join(settings_dir, "__init__.py")
+        else:
+            settings_file_path = os.path.join(self.test_dir, filename)
+
+        with open(settings_file_path, "w") as settings_file:
+            settings_file.write(
+                "# Settings file automatically generated by admin_scripts test case\n"
+            )
+            if extra:
+                settings_file.write("%s\n" % extra)
+            exports = [
+                "DATABASES",
+                "DEFAULT_AUTO_FIELD",
+                "ROOT_URLCONF",
+                "SECRET_KEY",
+                "USE_TZ",
+            ]
+            for s in exports:
+                if hasattr(settings, s):
+                    o = getattr(settings, s)
+                    if not isinstance(o, (dict, tuple, list)):
+                        o = "'%s'" % o
+                    settings_file.write("%s = %s\n" % (s, o))
+
+            if apps is None:
+                apps = [
+                    "django.contrib.auth",
+                    "django.contrib.contenttypes",
+                    "admin_scripts",
+                ]
+
+            settings_file.write("INSTALLED_APPS = %s\n" % apps)
+
+            if sdict:
+                for k, v in sdict.items():
+                    settings_file.write("%s = %s\n" % (k, v))
+
+    def _ext_backend_paths(self):
+        """
+        Returns the paths for any external backend packages.
+        """
+        paths = []
+        for backend in settings.DATABASES.values():
+            package = backend["ENGINE"].split(".")[0]
+            if package != "django":
+                backend_pkg = __import__(package)
+                backend_dir = os.path.dirname(backend_pkg.__file__)
+                paths.append(os.path.dirname(backend_dir))
+        return paths
+
+    def run_test(self, args, settings_file=None, apps=None, umask=-1):
+        base_dir = os.path.dirname(self.test_dir)
+        # The base dir for Django's tests is one level up.
+        tests_dir = os.path.dirname(os.path.dirname(__file__))
+        # The base dir for Django is one level above the test dir. We don't use
+        # `import django` to figure that out, so we don't pick up a Django
+        # from site-packages or similar.
+        django_dir = os.path.dirname(tests_dir)
+        ext_backend_base_dirs = self._ext_backend_paths()
+
+        # Define a temporary environment for the subprocess
+        test_environ = os.environ.copy()
+
+        # Set the test environment
+        if settings_file:
+            test_environ["DJANGO_SETTINGS_MODULE"] = settings_file
+        elif "DJANGO_SETTINGS_MODULE" in test_environ:
+            del test_environ["DJANGO_SETTINGS_MODULE"]
+        python_path = [base_dir, django_dir, tests_dir]
+        python_path.extend(ext_backend_base_dirs)
+        test_environ["PYTHONPATH"] = os.pathsep.join(python_path)
+        test_environ["PYTHONWARNINGS"] = ""
+
+        p = subprocess.run(
+            [sys.executable, *args],
+            capture_output=True,
+            cwd=self.test_dir,
+            env=test_environ,
+            text=True,
+            umask=umask,
+        )
+        return p.stdout, p.stderr
+
+    def run_manage(self, args, settings_file=None, manage_py=None):
+        template_manage_py = (
+            os.path.join(os.path.dirname(__file__), manage_py)
+            if manage_py
+            else os.path.join(
+                os.path.dirname(conf.__file__), "project_template", "manage.py-tpl"
+            )
+        )
+        test_manage_py = os.path.join(self.test_dir, "manage.py")
+        shutil.copyfile(template_manage_py, test_manage_py)
+
+        with open(test_manage_py) as fp:
+            manage_py_contents = fp.read()
+        manage_py_contents = manage_py_contents.replace(
+            "{{ project_name }}", "test_project"
+        )
+        with open(test_manage_py, "w") as fp:
+            fp.write(manage_py_contents)
+
+        return self.run_test(["./manage.py", *args], settings_file)
+
+    def assertNoOutput(self, stream):
+        "Utility assertion: assert that the given stream is empty"
+        self.assertEqual(
+            len(stream), 0, "Stream should be empty: actually contains '%s'" % stream
+        )
+
+    def assertOutput(self, stream, msg, regex=False):
+        "Utility assertion: assert that the given message exists in the output"
+        if regex:
+            self.assertIsNotNone(
+                re.search(msg, stream),
+                "'%s' does not match actual output text '%s'" % (msg, stream),
+            )
+        else:
+            self.assertIn(
+                msg,
+                stream,
+                "'%s' does not match actual output text '%s'" % (msg, stream),
+            )
+
+
+class ManagementParserSubparserTests(AdminScriptTestCase):
+    def test_subparser_required_argument_error(self):
+        """
+        A missing required argument on a subparser should produce a
+        user-friendly error message, not a traceback.
+        """
+        # Create an app with a management command.
+        app_dir = os.path.join(self.test_dir, "test_app")
+        os.mkdir(app_dir)
+        with open(os.path.join(app_dir, "__init__.py"), "w"):
+            pass
+        commands_dir = os.path.join(app_dir, "management", "commands")
+        os.makedirs(commands_dir)
+        with open(os.path.join(commands_dir, "__init__.py"), "w"):
+            pass
+        command_py = os.path.join(commands_dir, "cheeses.py")
+        with open(command_py, "w") as f:
+            f.write(
+                "from django.core.management.base import BaseCommand\n"
+                "class Command(BaseCommand):\n"
+                "    def add_arguments(self, parser):\n"
+                "        subparsers = parser.add_subparsers(required=True)\n"
+                '        create = subparsers.add_parser("create")\n'
+                '        create.add_argument("name")\n'
+                "    def handle(self, *args, **options):\n"
+                "        pass\n"
+            )
+
+        # The manage.py script created by run_manage() uses
+        # "test_project.settings" as the settings module, so a project
+        # package is required.
+        project_dir = os.path.join(self.test_dir, "test_project")
+        os.mkdir(project_dir)
+        with open(os.path.join(project_dir, "__init__.py"), "w"):
+            pass
+
+        self.write_settings(
+            os.path.join("test_project", "settings.py"),
+            apps=[
+                "django.contrib.auth",
+                "django.contrib.contenttypes",
+                "test_app",
+            ],
+        )
+
+        out, err = self.run_manage(["cheeses", "create"])
+        self.assertNoOutput(out)
+        # This assertion checks for the correct, user-friendly error message
+        # that argparse should produce. It will FAIL now because the bug
+        # causes a CommandError traceback instead.
+        self.assertOutput(
+            err, "manage.py cheeses create: error: the following arguments are required: name"
+        )

EOF_114329324912
python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/core/management/base\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 admin_scripts.test_management_parser
cat coverage.cover
git checkout 1250483ebf73f7a82ff820b94092c63ce4238264
git apply /root/pre_state.patch
