diff --git a/tests/migrations/test_writer_bug.py b/tests/migrations/test_writer_bug.py
new file mode 100644
index 0000000000..c36591fe1f
--- /dev/null
+++ b/tests/migrations/test_writer_bug.py
@@ -0,0 +1,256 @@
+import datetime
+import decimal
+import enum
+import functools
+import math
+import os
+import pathlib
+import re
+import sys
+import uuid
+from unittest import mock
+
+import custom_migration_operations.more_operations
+import custom_migration_operations.operations
+
+from django import get_version
+from django.conf import SettingsReference, settings
+from django.core.validators import EmailValidator, RegexValidator
+from django.db import migrations, models
+from django.db.migrations.serializer import BaseSerializer
+from django.db.migrations.writer import MigrationWriter, OperationWriter
+from django.test import SimpleTestCase
+from django.utils.deconstruct import deconstructible
+from django.utils.functional import SimpleLazyObject
+from django.utils.timezone import get_default_timezone, get_fixed_timezone, utc
+from django.utils.translation import gettext_lazy as _
+
+from .models import FoodManager, FoodQuerySet
+
+
+class DeconstructibleInstances:
+    def deconstruct(self):
+        return ('DeconstructibleInstances', [], {})
+
+
+class Money(decimal.Decimal):
+    def deconstruct(self):
+        return (
+            '%s.%s' % (self.__class__.__module__, self.__class__.__name__),
+            [str(self)],
+            {}
+        )
+
+
+class TestModel1:
+    def upload_to(self):
+        return '/somewhere/dynamic/'
+    thing = models.FileField(upload_to=upload_to)
+
+
+class TextEnum(enum.Enum):
+    A = 'a-value'
+    B = 'value-b'
+
+
+class TextTranslatedEnum(enum.Enum):
+    A = _('a-value')
+    B = _('value-b')
+
+
+class BinaryEnum(enum.Enum):
+    A = b'a-value'
+    B = b'value-b'
+
+
+class IntEnum(enum.IntEnum):
+    A = 1
+    B = 2
+
+
+# Helper classes for the regression test.
+class NameErrorMixin:
+    pass
+
+
+class NameErrorField(models.TextField):
+    pass
+
+
+class OperationWriterTests(SimpleTestCase):
+
+    def test_empty_signature(self):
+        operation = custom_migration_operations.operations.TestOperation()
+        buff, imports = OperationWriter(operation, indentation=0).serialize()
+        self.assertEqual(imports, {'import custom_migration_operations.operations'})
+        self.assertEqual(
+            buff,
+            'custom_migration_operations.operations.TestOperation(\n'
+            '),'
+        )
+
+    def test_args_signature(self):
+        operation = custom_migration_operations.operations.ArgsOperation(1, 2)
+        buff, imports = OperationWriter(operation, indentation=0).serialize()
+        self.assertEqual(imports, {'import custom_migration_operations.operations'})
+        self.assertEqual(
+            buff,
+            'custom_migration_operations.operations.ArgsOperation(\n'
+            '    arg1=1,\n'
+            '    arg2=2,\n'
+            '),'
+        )
+
+    def test_kwargs_signature(self):
+        operation = custom_migration_operations.operations.KwargsOperation(kwarg1=1)
+        buff, imports = OperationWriter(operation, indentation=0).serialize()
+        self.assertEqual(imports, {'import custom_migration_operations.operations'})
+        self.assertEqual(
+            buff,
+            'custom_migration_operations.operations.KwargsOperation(\n'
+            '    kwarg1=1,\n'
+            '),'
+        )
+
+    def test_args_kwargs_signature(self):
+        operation = custom_migration_operations.operations.ArgsKwargsOperation(1, 2, kwarg2=4)
+        buff, imports = OperationWriter(operation, indentation=0).serialize()
+        self.assertEqual(imports, {'import custom_migration_operations.operations'})
+        self.assertEqual(
+            buff,
+            'custom_migration_operations.operations.ArgsKwargsOperation(\n'
+            '    arg1=1,\n'
+            '    arg2=2,\n'
+            '    kwarg2=4,\n'
+            '),'
+        )
+
+    def test_nested_args_signature(self):
+        operation = custom_migration_operations.operations.ArgsOperation(
+            custom_migration_operations.operations.ArgsOperation(1, 2),
+            custom_migration_operations.operations.KwargsOperation(kwarg1=3, kwarg2=4)
+        )
+        buff, imports = OperationWriter(operation, indentation=0).serialize()
+        self.assertEqual(imports, {'import custom_migration_operations.operations'})
+        self.assertEqual(
+            buff,
+            'custom_migration_operations.operations.ArgsOperation(\n'
+            '    arg1=custom_migration_operations.operations.ArgsOperation(\n'
+            '        arg1=1,\n'
+            '        arg2=2,\n'
+            '    ),\n'
+            '    arg2=custom_migration_operations.operations.KwargsOperation(\n'
+            '        kwarg1=3,\n'
+            '        kwarg2=4,\n'
+            '    ),\n'
+            '),'
+        )
+
+    def test_multiline_args_signature(self):
+        operation = custom_migration_operations.operations.ArgsOperation("test\n    arg1", "test\narg2")
+        buff, imports = OperationWriter(operation, indentation=0).serialize()
+        self.assertEqual(imports, {'import custom_migration_operations.operations'})
+        self.assertEqual(
+            buff,
+            "custom_migration_operations.operations.ArgsOperation(\n"
+            "    arg1='test\\n    arg1',\n"
+            "    arg2='test\\narg2',\n"
+            "),"
+        )
+
+    def test_expand_args_signature(self):
+        operation = custom_migration_operations.operations.ExpandArgsOperation([1, 2])
+        buff, imports = OperationWriter(operation, indentation=0).serialize()
+        self.assertEqual(imports, {'import custom_migration_operations.operations'})
+        self.assertEqual(
+            buff,
+            'custom_migration_operations.operations.ExpandArgsOperation(\n'
+            '    arg=[\n'
+            '        1,\n'
+            '        2,\n'
+            '    ],\n'
+            '),'
+        )
+
+    def test_nested_operation_expand_args_signature(self):
+        operation = custom_migration_operations.operations.ExpandArgsOperation(
+            arg=[
+                custom_migration_operations.operations.KwargsOperation(
+                    kwarg1=1,
+                    kwarg2=2,
+                ),
+            ]
+        )
+        buff, imports = OperationWriter(operation, indentation=0).serialize()
+        self.assertEqual(imports, {'import custom_migration_operations.operations'})
+        self.assertEqual(
+            buff,
+            'custom_migration_operations.operations.ExpandArgsOperation(\n'
+            '    arg=[\n'
+            '        custom_migration_operations.operations.KwargsOperation(\n'
+            '            kwarg1=1,\n'
+            '            kwarg2=2,\n'
+            '        ),\n'
+            '    ],\n'
+            '),'
+        )
+
+
+class WriterTests(SimpleTestCase):
+    """
+    Tests the migration writer (makes migration files from Migration instances)
+    """
+    class NestedEnum(enum.IntEnum):
+        A = 1
+        B = 2
+
+    class NestedChoices(models.TextChoices):
+        X = 'X', 'X value'
+        Y = 'Y', 'Y value'
+
+    def safe_exec(self, string, value=None):
+        d = {}
+        try:
+            exec(string, globals(), d)
+        except Exception as e:
+            if value:
+                self.fail("Could not exec %r (from value %r): %s" % (string.strip(), value, e))
+            else:
+                self.fail("Could not exec %r: %s" % (string.strip(), e))
+        return d
+
+    def serialize_round_trip(self, value):
+        string, imports = MigrationWriter.serialize(value)
+        return self.safe_exec("%s\ntest_value_result = %s" % ("\n".join(imports), string), value)['test_value_result']
+
+    def assertSerializedEqual(self, value):
+        self.assertEqual(self.serialize_round_trip(value), value)
+
+    def assertSerializedResultEqual(self, value, target):
+        self.assertEqual(MigrationWriter.serialize(value), target)
+
+    def assertSerializedFieldEqual(self, value):
+        new_value = self.serialize_round_trip(value)
+        self.assertEqual(value.__class__, new_value.__class__)
+        self.assertEqual(value.max_length, new_value.max_length)
+        self.assertEqual(value.null, new_value.null)
+        self.assertEqual(value.unique, new_value.unique)
+
+    def test_model_import_for_bases(self):
+        """
+        `from django.db import models` should be added when `models.Model` is
+        present in the `bases` of a `CreateModel` operation.
+        """
+        migration = type('Migration', (migrations.Migration,), {
+            'operations': [
+                migrations.CreateModel(
+                    'MyModel',
+                    fields=[('name', NameErrorField(primary_key=True, serialize=False))],
+                    bases=(NameErrorMixin, models.Model),
+                ),
+            ],
+            'dependencies': [],
+        })
+        writer = MigrationWriter(migration)
+        output = writer.as_string()
+        self.assertIn('from django.db import models', output)
