{"instance_id": "django__django-14053", "repo": "django/django", "version": "4.0", "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4", "patch_list": ["diff --git a/tests/staticfiles_tests/test_hashed_storage.py b/tests/staticfiles_tests/test_hashed_storage.py\nnew file mode 100644\nindex 0000000000..2d14acda9d\n--- /dev/null\n+++ b/tests/staticfiles_tests/test_hashed_storage.py\n@@ -0,0 +1,541 @@\n+import os\n+import shutil\n+import sys\n+import tempfile\n+import unittest\n+from io import StringIO\n+from pathlib import Path\n+from unittest import mock\n+\n+from django.conf import settings\n+from django.contrib.staticfiles import finders, storage\n+from django.contrib.staticfiles.management.commands.collectstatic import (\n+    Command as CollectstaticCommand,\n+)\n+from django.core.management import call_command\n+from django.test import override_settings\n+\n+from .cases import CollectionTestCase\n+from .settings import TEST_ROOT\n+\n+\n+def hashed_file_path(test, path):\n+    fullpath = test.render_template(test.static_template_snippet(path))\n+    return fullpath.replace(settings.STATIC_URL, '')\n+\n+\n+class TestHashedFiles:\n+    hashed_file_path = hashed_file_path\n+\n+    def setUp(self):\n+        self._max_post_process_passes = storage.staticfiles_storage.max_post_process_passes\n+        super().setUp()\n+\n+    def tearDown(self):\n+        # Clear hashed files to avoid side effects among tests.\n+        storage.staticfiles_storage.hashed_files.clear()\n+        storage.staticfiles_storage.max_post_process_passes = self._max_post_process_passes\n+\n+    def assertPostCondition(self):\n+        \"\"\"\n+        Assert post conditions for a test are met. Must be manually called at\n+        the end of each test.\n+        \"\"\"\n+        pass\n+\n+    def test_template_tag_return(self):\n+        self.assertStaticRaises(ValueError, \"does/not/exist.png\", \"/static/does/not/exist.png\")\n+        self.assertStaticRenders(\"test/file.txt\", \"/static/test/file.dad0999e4f8f.txt\")\n+        self.assertStaticRenders(\"test/file.txt\", \"/static/test/file.dad0999e4f8f.txt\", asvar=True)\n+        self.assertStaticRenders(\"cached/styles.css\", \"/static/cached/styles.5e0040571e1a.css\")\n+        self.assertStaticRenders(\"path/\", \"/static/path/\")\n+        self.assertStaticRenders(\"path/?query\", \"/static/path/?query\")\n+        self.assertPostCondition()\n+\n+    def test_template_tag_simple_content(self):\n+        relpath = self.hashed_file_path(\"cached/styles.css\")\n+        self.assertEqual(relpath, \"cached/styles.5e0040571e1a.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            content = relfile.read()\n+            self.assertNotIn(b\"cached/other.css\", content)\n+            self.assertIn(b\"other.d41d8cd98f00.css\", content)\n+        self.assertPostCondition()\n+\n+    def test_path_ignored_completely(self):\n+        relpath = self.hashed_file_path(\"cached/css/ignored.css\")\n+        self.assertEqual(relpath, \"cached/css/ignored.554da52152af.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            content = relfile.read()\n+            self.assertIn(b'#foobar', content)\n+            self.assertIn(b'http:foobar', content)\n+            self.assertIn(b'https:foobar', content)\n+            self.assertIn(b'data:foobar', content)\n+            self.assertIn(b'chrome:foobar', content)\n+            self.assertIn(b'//foobar', content)\n+        self.assertPostCondition()\n+\n+    def test_path_with_querystring(self):\n+        relpath = self.hashed_file_path(\"cached/styles.css?spam=eggs\")\n+        self.assertEqual(relpath, \"cached/styles.5e0040571e1a.css?spam=eggs\")\n+        with storage.staticfiles_storage.open(\"cached/styles.5e0040571e1a.css\") as relfile:\n+            content = relfile.read()\n+            self.assertNotIn(b\"cached/other.css\", content)\n+            self.assertIn(b\"other.d41d8cd98f00.css\", content)\n+        self.assertPostCondition()\n+\n+    def test_path_with_fragment(self):\n+        relpath = self.hashed_file_path(\"cached/styles.css#eggs\")\n+        self.assertEqual(relpath, \"cached/styles.5e0040571e1a.css#eggs\")\n+        with storage.staticfiles_storage.open(\"cached/styles.5e0040571e1a.css\") as relfile:\n+            content = relfile.read()\n+            self.assertNotIn(b\"cached/other.css\", content)\n+            self.assertIn(b\"other.d41d8cd98f00.css\", content)\n+        self.assertPostCondition()\n+\n+    def test_path_with_querystring_and_fragment(self):\n+        relpath = self.hashed_file_path(\"cached/css/fragments.css\")\n+        self.assertEqual(relpath, \"cached/css/fragments.a60c0e74834f.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            content = relfile.read()\n+            self.assertIn(b'fonts/font.b9b105392eb8.eot?#iefix', content)\n+            self.assertIn(b'fonts/font.b8d603e42714.svg#webfontIyfZbseF', content)\n+            self.assertIn(b'fonts/font.b8d603e42714.svg#path/to/../../fonts/font.svg', content)\n+            self.assertIn(b'data:font/woff;charset=utf-8;base64,d09GRgABAAAAADJoAA0AAAAAR2QAAQAAAAAAAAAAAAA', content)\n+            self.assertIn(b'#default#VML', content)\n+        self.assertPostCondition()\n+\n+    def test_template_tag_absolute(self):\n+        relpath = self.hashed_file_path(\"cached/absolute.css\")\n+        self.assertEqual(relpath, \"cached/absolute.eb04def9f9a4.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            content = relfile.read()\n+            self.assertNotIn(b\"/static/cached/styles.css\", content)\n+            self.assertIn(b\"/static/cached/styles.5e0040571e1a.css\", content)\n+            self.assertNotIn(b\"/static/styles_root.css\", content)\n+            self.assertIn(b\"/static/styles_root.401f2509a628.css\", content)\n+            self.assertIn(b'/static/cached/img/relative.acae32e4532b.png', content)\n+        self.assertPostCondition()\n+\n+    def test_template_tag_absolute_root(self):\n+        \"\"\"\n+        Like test_template_tag_absolute, but for a file in STATIC_ROOT (#26249).\n+        \"\"\"\n+        relpath = self.hashed_file_path(\"absolute_root.css\")\n+        self.assertEqual(relpath, \"absolute_root.f821df1b64f7.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            content = relfile.read()\n+            self.assertNotIn(b\"/static/styles_root.css\", content)\n+            self.assertIn(b\"/static/styles_root.401f2509a628.css\", content)\n+        self.assertPostCondition()\n+\n+    def test_template_tag_relative(self):\n+        relpath = self.hashed_file_path(\"cached/relative.css\")\n+        self.assertEqual(relpath, \"cached/relative.c3e9e1ea6f2e.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            content = relfile.read()\n+            self.assertNotIn(b\"../cached/styles.css\", content)\n+            self.assertNotIn(b'@import \"styles.css\"', content)\n+            self.assertNotIn(b'url(img/relative.png)', content)\n+            self.assertIn(b'url(\"img/relative.acae32e4532b.png\")', content)\n+            self.assertIn(b\"../cached/styles.5e0040571e1a.css\", content)\n+        self.assertPostCondition()\n+\n+    def test_import_replacement(self):\n+        \"See #18050\"\n+        relpath = self.hashed_file_path(\"cached/import.css\")\n+        self.assertEqual(relpath, \"cached/import.f53576679e5a.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            self.assertIn(b'import url(\"styles.5e0040571e1a.css\")', relfile.read())\n+        self.assertPostCondition()\n+\n+    def test_template_tag_deep_relative(self):\n+        relpath = self.hashed_file_path(\"cached/css/window.css\")\n+        self.assertEqual(relpath, \"cached/css/window.5d5c10836967.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            content = relfile.read()\n+            self.assertNotIn(b'url(img/window.png)', content)\n+            self.assertIn(b'url(\"img/window.acae32e4532b.png\")', content)\n+        self.assertPostCondition()\n+\n+    def test_template_tag_url(self):\n+        relpath = self.hashed_file_path(\"cached/url.css\")\n+        self.assertEqual(relpath, \"cached/url.902310b73412.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            self.assertIn(b\"https://\", relfile.read())\n+        self.assertPostCondition()\n+\n+    @override_settings(\n+        STATICFILES_DIRS=[os.path.join(TEST_ROOT, 'project', 'loop')],\n+        STATICFILES_FINDERS=['django.contrib.staticfiles.finders.FileSystemFinder'],\n+    )\n+    def test_import_loop(self):\n+        finders.get_finder.cache_clear()\n+        err = StringIO()\n+        with self.assertRaisesMessage(RuntimeError, 'Max post-process passes exceeded'):\n+            call_command('collectstatic', interactive=False, verbosity=0, stderr=err)\n+        self.assertEqual(\"Post-processing 'All' failed!\\n\\n\", err.getvalue())\n+        self.assertPostCondition()\n+\n+    def test_post_processing(self):\n+        \"\"\"\n+        post_processing behaves correctly.\n+\n+        Files that are alterable should always be post-processed; files that\n+        aren't should be skipped.\n+\n+        collectstatic has already been called once in setUp() for this testcase,\n+        therefore we check by verifying behavior on a second run.\n+        \"\"\"\n+        collectstatic_args = {\n+            'interactive': False,\n+            'verbosity': 0,\n+            'link': False,\n+            'clear': False,\n+            'dry_run': False,\n+            'post_process': True,\n+            'use_default_ignore_patterns': True,\n+            'ignore_patterns': ['*.ignoreme'],\n+        }\n+\n+        collectstatic_cmd = CollectstaticCommand()\n+        collectstatic_cmd.set_options(**collectstatic_args)\n+        stats = collectstatic_cmd.collect()\n+        self.assertIn(os.path.join('cached', 'css', 'window.css'), stats['post_processed'])\n+        self.assertIn(os.path.join('cached', 'css', 'img', 'window.png'), stats['unmodified'])\n+        self.assertIn(os.path.join('test', 'nonascii.css'), stats['post_processed'])\n+        self.assertPostCondition()\n+\n+    def test_css_import_case_insensitive(self):\n+        relpath = self.hashed_file_path(\"cached/styles_insensitive.css\")\n+        self.assertEqual(relpath, \"cached/styles_insensitive.3fa427592a53.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            content = relfile.read()\n+            self.assertNotIn(b\"cached/other.css\", content)\n+            self.assertIn(b\"other.d41d8cd98f00.css\", content)\n+        self.assertPostCondition()\n+\n+    @override_settings(\n+        STATICFILES_DIRS=[os.path.join(TEST_ROOT, 'project', 'faulty')],\n+        STATICFILES_FINDERS=['django.contrib.staticfiles.finders.FileSystemFinder'],\n+    )\n+    def test_post_processing_failure(self):\n+        \"\"\"\n+        post_processing indicates the origin of the error when it fails.\n+        \"\"\"\n+        finders.get_finder.cache_clear()\n+        err = StringIO()\n+        with self.assertRaises(Exception):\n+            call_command('collectstatic', interactive=False, verbosity=0, stderr=err)\n+        self.assertEqual(\"Post-processing 'faulty.css' failed!\\n\\n\", err.getvalue())\n+        self.assertPostCondition()\n+\n+\n+@override_settings(STATICFILES_STORAGE='staticfiles_tests.storage.ExtraPatternsStorage')\n+class TestExtraPatternsStorage(CollectionTestCase):\n+\n+    def setUp(self):\n+        storage.staticfiles_storage.hashed_files.clear()  # avoid cache interference\n+        super().setUp()\n+\n+    def cached_file_path(self, path):\n+        fullpath = self.render_template(self.static_template_snippet(path))\n+        return fullpath.replace(settings.STATIC_URL, '')\n+\n+    def test_multi_extension_patterns(self):\n+        \"\"\"\n+        With storage classes having several file extension patterns, only the\n+        files matching a specific file pattern should be affected by the\n+        substitution (#19670).\n+        \"\"\"\n+        # CSS files shouldn't be touched by JS patterns.\n+        relpath = self.cached_file_path(\"cached/import.css\")\n+        self.assertEqual(relpath, \"cached/import.f53576679e5a.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            self.assertIn(b'import url(\"styles.5e0040571e1a.css\")', relfile.read())\n+\n+        # Confirm JS patterns have been applied to JS files.\n+        relpath = self.cached_file_path(\"cached/test.js\")\n+        self.assertEqual(relpath, \"cached/test.388d7a790d46.js\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            self.assertIn(b'JS_URL(\"import.f53576679e5a.css\")', relfile.read())\n+\n+\n+@override_settings(\n+    STATICFILES_STORAGE='django.contrib.staticfiles.storage.ManifestStaticFilesStorage',\n+)\n+class TestCollectionManifestStorage(TestHashedFiles, CollectionTestCase):\n+    \"\"\"\n+    Tests for the Cache busting storage\n+    \"\"\"\n+    def setUp(self):\n+        super().setUp()\n+\n+        temp_dir = tempfile.mkdtemp()\n+        os.makedirs(os.path.join(temp_dir, 'test'))\n+        self._clear_filename = os.path.join(temp_dir, 'test', 'cleared.txt')\n+        with open(self._clear_filename, 'w') as f:\n+            f.write('to be deleted in one test')\n+\n+        self.patched_settings = self.settings(\n+            STATICFILES_DIRS=settings.STATICFILES_DIRS + [temp_dir],\n+        )\n+        self.patched_settings.enable()\n+        self.addCleanup(shutil.rmtree, temp_dir)\n+        self._manifest_strict = storage.staticfiles_storage.manifest_strict\n+\n+    def tearDown(self):\n+        self.patched_settings.disable()\n+\n+        if os.path.exists(self._clear_filename):\n+            os.unlink(self._clear_filename)\n+\n+        storage.staticfiles_storage.manifest_strict = self._manifest_strict\n+        super().tearDown()\n+\n+    def assertPostCondition(self):\n+        hashed_files = storage.staticfiles_storage.hashed_files\n+        # The in-memory version of the manifest matches the one on disk\n+        # since a properly created manifest should cover all filenames.\n+        if hashed_files:\n+            manifest = storage.staticfiles_storage.load_manifest()\n+            self.assertEqual(hashed_files, manifest)\n+\n+    def test_manifest_exists(self):\n+        filename = storage.staticfiles_storage.manifest_name\n+        path = storage.staticfiles_storage.path(filename)\n+        self.assertTrue(os.path.exists(path))\n+\n+    def test_manifest_does_not_exist(self):\n+        storage.staticfiles_storage.manifest_name = 'does.not.exist.json'\n+        self.assertIsNone(storage.staticfiles_storage.read_manifest())\n+\n+    def test_manifest_does_not_ignore_permission_error(self):\n+        with mock.patch('builtins.open', side_effect=PermissionError):\n+            with self.assertRaises(PermissionError):\n+                storage.staticfiles_storage.read_manifest()\n+\n+    def test_loaded_cache(self):\n+        self.assertNotEqual(storage.staticfiles_storage.hashed_files, {})\n+        manifest_content = storage.staticfiles_storage.read_manifest()\n+        self.assertIn(\n+            '\"version\": \"%s\"' % storage.staticfiles_storage.manifest_version,\n+            manifest_content\n+        )\n+\n+    def test_parse_cache(self):\n+        hashed_files = storage.staticfiles_storage.hashed_files\n+        manifest = storage.staticfiles_storage.load_manifest()\n+        self.assertEqual(hashed_files, manifest)\n+\n+    def test_clear_empties_manifest(self):\n+        cleared_file_name = storage.staticfiles_storage.clean_name(os.path.join('test', 'cleared.txt'))\n+        # collect the additional file\n+        self.run_collectstatic()\n+\n+        hashed_files = storage.staticfiles_storage.hashed_files\n+        self.assertIn(cleared_file_name, hashed_files)\n+\n+        manifest_content = storage.staticfiles_storage.load_manifest()\n+        self.assertIn(cleared_file_name, manifest_content)\n+\n+        original_path = storage.staticfiles_storage.path(cleared_file_name)\n+        self.assertTrue(os.path.exists(original_path))\n+\n+        # delete the original file form the app, collect with clear\n+        os.unlink(self._clear_filename)\n+        self.run_collectstatic(clear=True)\n+\n+        self.assertFileNotFound(original_path)\n+\n+        hashed_files = storage.staticfiles_storage.hashed_files\n+        self.assertNotIn(cleared_file_name, hashed_files)\n+\n+        manifest_content = storage.staticfiles_storage.load_manifest()\n+        self.assertNotIn(cleared_file_name, manifest_content)\n+\n+    def test_missing_entry(self):\n+        missing_file_name = 'cached/missing.css'\n+        configured_storage = storage.staticfiles_storage\n+        self.assertNotIn(missing_file_name, configured_storage.hashed_files)\n+\n+        # File name not found in manifest\n+        with self.assertRaisesMessage(ValueError, \"Missing staticfiles manifest entry for '%s'\" % missing_file_name):\n+            self.hashed_file_path(missing_file_name)\n+\n+        configured_storage.manifest_strict = False\n+        # File doesn't exist on disk\n+        err_msg = \"The file '%s' could not be found with %r.\" % (missing_file_name, configured_storage._wrapped)\n+        with self.assertRaisesMessage(ValueError, err_msg):\n+            self.hashed_file_path(missing_file_name)\n+\n+        content = StringIO()\n+        content.write('Found')\n+        configured_storage.save(missing_file_name, content)\n+        # File exists on disk\n+        self.hashed_file_path(missing_file_name)\n+\n+    def test_intermediate_files(self):\n+        cached_files = os.listdir(os.path.join(settings.STATIC_ROOT, 'cached'))\n+        # Intermediate files shouldn't be created for reference.\n+        self.assertEqual(\n+            len([\n+                cached_file\n+                for cached_file in cached_files\n+                if cached_file.startswith('relative.')\n+            ]),\n+            2,\n+        )\n+\n+    def test_post_process_yields_each_file_only_once(self):\n+        \"\"\"\n+        HashedFilesMixin.post_process() should not yield the same file multiple\n+        times.\n+        \"\"\"\n+        # The base setup runs collectstatic once, but to get the stats back\n+        # from the command, we run it again.\n+        collectstatic_cmd = CollectstaticCommand()\n+        # The options are based on the existing test_post_processing test.\n+        collectstatic_cmd.set_options(\n+            interactive=False,\n+            verbosity=0,\n+            link=False,\n+            clear=False,\n+            dry_run=False,\n+            post_process=True,\n+            use_default_ignore_patterns=True,\n+            ignore_patterns=['*.ignoreme'],\n+        )\n+        stats = collectstatic_cmd.collect()\n+        post_processed_files = stats['post_processed']\n+        self.assertEqual(\n+            len(post_processed_files),\n+            len(set(post_processed_files)),\n+            \"post_process() yielded some files more than once.\"\n+        )\n+\n+\n+@override_settings(STATICFILES_STORAGE='staticfiles_tests.storage.NoneHashStorage')\n+class TestCollectionNoneHashStorage(CollectionTestCase):\n+    hashed_file_path = hashed_file_path\n+\n+    def test_hashed_name(self):\n+        relpath = self.hashed_file_path('cached/styles.css')\n+        self.assertEqual(relpath, 'cached/styles.css')\n+\n+\n+@override_settings(STATICFILES_STORAGE='staticfiles_tests.storage.SimpleStorage')\n+class TestCollectionSimpleStorage(CollectionTestCase):\n+    hashed_file_path = hashed_file_path\n+\n+    def setUp(self):\n+        storage.staticfiles_storage.hashed_files.clear()  # avoid cache interference\n+        super().setUp()\n+\n+    def test_template_tag_return(self):\n+        self.assertStaticRaises(ValueError, \"does/not/exist.png\", \"/static/does/not/exist.png\")\n+        self.assertStaticRenders(\"test/file.txt\", \"/static/test/file.deploy12345.txt\")\n+        self.assertStaticRenders(\"cached/styles.css\", \"/static/cached/styles.deploy12345.css\")\n+        self.assertStaticRenders(\"path/\", \"/static/path/\")\n+        self.assertStaticRenders(\"path/?query\", \"/static/path/?query\")\n+\n+    def test_template_tag_simple_content(self):\n+        relpath = self.hashed_file_path(\"cached/styles.css\")\n+        self.assertEqual(relpath, \"cached/styles.deploy12345.css\")\n+        with storage.staticfiles_storage.open(relpath) as relfile:\n+            content = relfile.read()\n+            self.assertNotIn(b\"cached/other.css\", content)\n+            self.assertIn(b\"other.deploy12345.css\", content)\n+\n+\n+class CustomStaticFilesStorage(storage.StaticFilesStorage):\n+    \"\"\"\n+    Used in TestStaticFilePermissions\n+    \"\"\"\n+    def __init__(self, *args, **kwargs):\n+        kwargs['file_permissions_mode'] = 0o640\n+        kwargs['directory_permissions_mode'] = 0o740\n+        super().__init__(*args, **kwargs)\n+\n+\n+@unittest.skipIf(sys.platform == 'win32', \"Windows only partially supports chmod.\")\n+class TestStaticFilePermissions(CollectionTestCase):\n+\n+    command_params = {\n+        'interactive': False,\n+        'verbosity': 0,\n+        'ignore_patterns': ['*.ignoreme'],\n+    }\n+\n+    def setUp(self):\n+        self.umask = 0o027\n+        self.old_umask = os.umask(self.umask)\n+        super().setUp()\n+\n+    def tearDown(self):\n+        os.umask(self.old_umask)\n+        super().tearDown()\n+\n+    # Don't run collectstatic command in this test class.\n+    def run_collectstatic(self, **kwargs):\n+        pass\n+\n+    @override_settings(\n+        FILE_UPLOAD_PERMISSIONS=0o655,\n+        FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o765,\n+    )\n+    def test_collect_static_files_permissions(self):\n+        call_command('collectstatic', **self.command_params)\n+        static_root = Path(settings.STATIC_ROOT)\n+        test_file = static_root / 'test.txt'\n+        file_mode = test_file.stat().st_mode & 0o777\n+        self.assertEqual(file_mode, 0o655)\n+        tests = [\n+            static_root / 'subdir',\n+            static_root / 'nested',\n+            static_root / 'nested' / 'css',\n+        ]\n+        for directory in tests:\n+            with self.subTest(directory=directory):\n+                dir_mode = directory.stat().st_mode & 0o777\n+                self.assertEqual(dir_mode, 0o765)\n+\n+    @override_settings(\n+        FILE_UPLOAD_PERMISSIONS=None,\n+        FILE_UPLOAD_DIRECTORY_PERMISSIONS=None,\n+    )\n+    def test_collect_static_files_default_permissions(self):\n+        call_command('collectstatic', **self.command_params)\n+        static_root = Path(settings.STATIC_ROOT)\n+        test_file = static_root / 'test.txt'\n+        file_mode = test_file.stat().st_mode & 0o777\n+        self.assertEqual(file_mode, 0o666 & ~self.umask)\n+        tests = [\n+            static_root / 'subdir',\n+            static_root / 'nested',\n+            static_root / 'nested' / 'css',\n+        ]\n+        for directory in tests:\n+            with self.subTest(directory=directory):\n+                dir_mode = directory.stat().st_mode & 0o777\n+                self.assertEqual(dir_mode, 0o777 & ~self.umask)\n+\n+    @override_settings(\n+        FILE_UPLOAD_PERMISSIONS=0o655,\n+        FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o765,\n+        STATICFILES_STORAGE='staticfiles_tests.test_hashed_storage.CustomStaticFilesStorage',\n+    )\n+    def test_collect_static_files_subclass_of_static_storage(self):\n+        call_command('collectstatic', **self.command_params)\n+        static_root = Path(settings.STATIC_ROOT)\n+        test_file = static_root / 'test.txt'\n+        file_mode = test_file.stat().st_mode & 0o777\n+        self.assertEqual(file_mode, 0o640)\n+        tests = [\n+            static_root / 'subdir',\n+            static_root / 'nested',\n+            static_root / 'nested' / 'css',\n+        ]\n+        for directory in tests:\n+            with self.subTest(directory=directory):\n+                dir_mode = directory.stat().st_mode & 0o777\n+                self.assertEqual(dir_mode, 0o740)\n"], "arch": "x86_64", "base_commit": "179ee13eb37348cd87169a198aec18fedccc8668", "test_directives": ["staticfiles_tests.test_hashed_storage"], "coverage_files": ["django/contrib/staticfiles/storage.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.8", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/contrib/staticfiles/storage\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 staticfiles_tests.test_hashed_storage", "req_install_commands": ["conda create -n testbed python=3.8 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}