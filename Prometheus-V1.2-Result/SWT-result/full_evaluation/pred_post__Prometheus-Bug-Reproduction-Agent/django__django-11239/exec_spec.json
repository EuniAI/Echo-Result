{"instance_id": "django__django-11239", "repo": "django/django", "version": "3.0", "environment_setup_commit": "419a78300f7cd27611196e1e464d50fd0385ff27", "patch_list": ["diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -17,6 +17,10 @@ def runshell_db(cls, conn_params):\n         dbname = conn_params.get('database', '')\n         user = conn_params.get('user', '')\n         passwd = conn_params.get('password', '')\n+        sslmode = conn_params.get('sslmode', '')\n+        sslrootcert = conn_params.get('sslrootcert', '')\n+        sslcert = conn_params.get('sslcert', '')\n+        sslkey = conn_params.get('sslkey', '')\n \n         if user:\n             args += ['-U', user]\n@@ -30,6 +34,14 @@ def runshell_db(cls, conn_params):\n         subprocess_env = os.environ.copy()\n         if passwd:\n             subprocess_env['PGPASSWORD'] = str(passwd)\n+        if sslmode:\n+            subprocess_env['PGSSLMODE'] = str(sslmode)\n+        if sslrootcert:\n+            subprocess_env['PGSSLROOTCERT'] = str(sslrootcert)\n+        if sslcert:\n+            subprocess_env['PGSSLCERT'] = str(sslcert)\n+        if sslkey:\n+            subprocess_env['PGSSLKEY'] = str(sslkey)\n         try:\n             # Allow SIGINT to pass to psql to abort queries.\n             signal.signal(signal.SIGINT, signal.SIG_IGN)\n", "diff --git a/tests/backends/postgresql/test_client.py b/tests/backends/postgresql/test_client.py\nnew file mode 100644\nindex 0000000000..2fb2566c6f\n--- /dev/null\n+++ b/tests/backends/postgresql/test_client.py\n@@ -0,0 +1,127 @@\n+import os\n+import signal\n+import subprocess\n+from unittest import mock\n+\n+from django.db.backends.postgresql.client import DatabaseClient\n+from django.test import SimpleTestCase\n+\n+\n+class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n+\n+    def _run_it(self, dbinfo):\n+        \"\"\"\n+        That function invokes the runshell command, while mocking\n+        subprocess.run(). It returns a 2-tuple with:\n+        - The command line list\n+        - The the value of the PGPASSWORD environment variable, or None.\n+        \"\"\"\n+        def _mock_subprocess_run(*args, env=os.environ, **kwargs):\n+            self.subprocess_args = list(*args)\n+            self.pgpassword = env.get('PGPASSWORD')\n+            return subprocess.CompletedProcess(self.subprocess_args, 0)\n+        with mock.patch('subprocess.run', new=_mock_subprocess_run):\n+            DatabaseClient.runshell_db(dbinfo)\n+        return self.subprocess_args, self.pgpassword\n+\n+    def test_basic(self):\n+        self.assertEqual(\n+            self._run_it({\n+                'database': 'dbname',\n+                'user': 'someuser',\n+                'password': 'somepassword',\n+                'host': 'somehost',\n+                'port': '444',\n+            }), (\n+                ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],\n+                'somepassword',\n+            )\n+        )\n+\n+    def test_nopass(self):\n+        self.assertEqual(\n+            self._run_it({\n+                'database': 'dbname',\n+                'user': 'someuser',\n+                'host': 'somehost',\n+                'port': '444',\n+            }), (\n+                ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],\n+                None,\n+            )\n+        )\n+\n+    def test_column(self):\n+        self.assertEqual(\n+            self._run_it({\n+                'database': 'dbname',\n+                'user': 'some:user',\n+                'password': 'some:password',\n+                'host': '::1',\n+                'port': '444',\n+            }), (\n+                ['psql', '-U', 'some:user', '-h', '::1', '-p', '444', 'dbname'],\n+                'some:password',\n+            )\n+        )\n+\n+    def test_accent(self):\n+        username = 'r\u00f4le'\n+        password = 's\u00e9same'\n+        self.assertEqual(\n+            self._run_it({\n+                'database': 'dbname',\n+                'user': username,\n+                'password': password,\n+                'host': 'somehost',\n+                'port': '444',\n+            }), (\n+                ['psql', '-U', username, '-h', 'somehost', '-p', '444', 'dbname'],\n+                password,\n+            )\n+        )\n+\n+    def test_sigint_handler(self):\n+        \"\"\"SIGINT is ignored in Python and passed to psql to abort quries.\"\"\"\n+        def _mock_subprocess_run(*args, **kwargs):\n+            handler = signal.getsignal(signal.SIGINT)\n+            self.assertEqual(handler, signal.SIG_IGN)\n+\n+        sigint_handler = signal.getsignal(signal.SIGINT)\n+        # The default handler isn't SIG_IGN.\n+        self.assertNotEqual(sigint_handler, signal.SIG_IGN)\n+        with mock.patch('subprocess.run', new=_mock_subprocess_run):\n+            DatabaseClient.runshell_db({})\n+        # dbshell restores the original handler.\n+        self.assertEqual(sigint_handler, signal.getsignal(signal.SIGINT))\n+\n+    def test_ssl_client_certificate_options(self):\n+        \"\"\"\n+        Client certificate SSL options are passed to psql as environment\n+        variables.\n+        \"\"\"\n+        dbinfo = {\n+            'database': 'dbname',\n+            'user': 'someuser',\n+            'host': 'somehost',\n+            'port': '444',\n+            'password': '',\n+            'options': {\n+                'sslmode': 'verify-ca',\n+                'sslrootcert': 'ca.crt',\n+                'sslcert': 'client.crt',\n+                'sslkey': 'client.key',\n+            },\n+        }\n+        run_env = None\n+\n+        def _mock_subprocess_run(*args, env=os.environ, **kwargs):\n+            nonlocal run_env\n+            run_env = env\n+            return subprocess.CompletedProcess(list(*args), 0)\n+\n+        with mock.patch('subprocess.run', new=_mock_subprocess_run):\n+            DatabaseClient.runshell_db(dbinfo)\n+\n+        self.assertEqual(run_env.get('PGSSLCERT'), 'client.crt')\n+        self.assertEqual(run_env.get('PGSSLKEY'), 'client.key')\n"], "arch": "x86_64", "base_commit": "d87bd29c4f8dfcdf3f4a4eb8340e6770a2416fe3", "test_directives": ["backends.postgresql.test_client"], "coverage_files": ["django/db/backends/postgresql/client.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/backends/postgresql/client\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 backends.postgresql.test_client", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref ~= 3.2\nargon2-cffi >= 16.1.0\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow != 5.4.0\npylibmc; sys.platform != 'win32'\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}