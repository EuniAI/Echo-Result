{"instance_id": "sphinx-doc__sphinx-9258", "repo": "sphinx-doc/sphinx", "version": "4.1", "environment_setup_commit": "9a2c3c4a1559e37e95fdee88c128bb116642c897", "patch_list": ["diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -304,7 +304,7 @@ def make_xref(self, rolename: str, domain: str, target: str,\n     def make_xrefs(self, rolename: str, domain: str, target: str,\n                    innernode: Type[TextlikeNode] = nodes.emphasis,\n                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:\n-        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+|\\.\\.\\.)'\n+        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+|\\s*\\|\\s*|\\.\\.\\.)'\n         delims_re = re.compile(delims)\n         sub_targets = re.split(delims, target)\n \n", "diff --git a/tests/test_domain_py_pep_604.py b/tests/test_domain_py_pep_604.py\nnew file mode 100644\nindex 000000000..fb0c5dfe2\n--- /dev/null\n+++ b/tests/test_domain_py_pep_604.py\n@@ -0,0 +1,504 @@\n+import re\n+import sys\n+from unittest.mock import Mock\n+\n+import pytest\n+from docutils import nodes\n+\n+from sphinx import addnodes\n+from sphinx.addnodes import (desc, desc_addname, desc_annotation, desc_content, desc_name,\n+                             desc_optional, desc_parameter, desc_parameterlist, desc_returns,\n+                             desc_sig_name, desc_sig_operator, desc_sig_punctuation,\n+                             desc_signature, pending_xref)\n+from sphinx.domains import IndexEntry\n+from sphinx.domains.python import (PythonDomain, PythonModuleIndex, _parse_annotation,\n+                                   _pseudo_parse_arglist, py_sig_re)\n+from sphinx.testing import restructuredtext\n+from sphinx.testing.util import assert_node\n+\n+\n+def parse(sig):\n+    m = py_sig_re.match(sig)\n+    if m is None:\n+        raise ValueError\n+    name_prefix, name, arglist, retann = m.groups()\n+    signode = addnodes.desc_signature(sig, '')\n+    _pseudo_parse_arglist(signode, arglist)\n+    return signode.astext()\n+\n+\n+def test_function_signatures():\n+    rv = parse('func(a=1) -> int object')\n+    assert rv == '(a=1)'\n+\n+    rv = parse('func(a=1, [b=None])')\n+    assert rv == '(a=1, [b=None])'\n+\n+    rv = parse('func(a=1[, b=None])')\n+    assert rv == '(a=1, [b=None])'\n+\n+    rv = parse(\"compile(source : string, filename, symbol='file')\")\n+    assert rv == \"(source : string, filename, symbol='file')\"\n+\n+    rv = parse('func(a=[], [b=None])')\n+    assert rv == '(a=[], [b=None])'\n+\n+    rv = parse('func(a=[][, b=None])')\n+    assert rv == '(a=[], [b=None])'\n+\n+\n+@pytest.mark.sphinx('dummy', testroot='domain-py')\n+def test_domain_py_xrefs(app, status, warning):\n+    \"\"\"Domain objects have correct prefixes when looking up xrefs\"\"\"\n+    app.builder.build_all()\n+\n+    def assert_refnode(node, module_name, class_name, target, reftype=None,\n+                       domain='py'):\n+        attributes = {\n+            'refdomain': domain,\n+            'reftarget': target,\n+        }\n+        if reftype is not None:\n+            attributes['reftype'] = reftype\n+        if module_name is not False:\n+            attributes['py:module'] = module_name\n+        if class_name is not False:\n+            attributes['py:class'] = class_name\n+        assert_node(node, **attributes)\n+\n+    doctree = app.env.get_doctree('roles')\n+    refnodes = list(doctree.traverse(pending_xref))\n+    assert_refnode(refnodes[0], None, None, 'TopLevel', 'class')\n+    assert_refnode(refnodes[1], None, None, 'top_level', 'meth')\n+    assert_refnode(refnodes[2], None, 'NestedParentA', 'child_1', 'meth')\n+    assert_refnode(refnodes[3], None, 'NestedParentA', 'NestedChildA.subchild_2', 'meth')\n+    assert_refnode(refnodes[4], None, 'NestedParentA', 'child_2', 'meth')\n+    assert_refnode(refnodes[5], False, 'NestedParentA', 'any_child', domain='')\n+    assert_refnode(refnodes[6], None, 'NestedParentA', 'NestedChildA', 'class')\n+    assert_refnode(refnodes[7], None, 'NestedParentA.NestedChildA', 'subchild_2', 'meth')\n+    assert_refnode(refnodes[8], None, 'NestedParentA.NestedChildA',\n+                   'NestedParentA.child_1', 'meth')\n+    assert_refnode(refnodes[9], None, 'NestedParentA', 'NestedChildA.subchild_1', 'meth')\n+    assert_refnode(refnodes[10], None, 'NestedParentB', 'child_1', 'meth')\n+    assert_refnode(refnodes[11], None, 'NestedParentB', 'NestedParentB', 'class')\n+    assert_refnode(refnodes[12], None, None, 'NestedParentA.NestedChildA', 'class')\n+    assert len(refnodes) == 13\n+\n+    doctree = app.env.get_doctree('module')\n+    refnodes = list(doctree.traverse(pending_xref))\n+    assert_refnode(refnodes[0], 'module_a.submodule', None,\n+                   'ModTopLevel', 'class')\n+    assert_refnode(refnodes[1], 'module_a.submodule', 'ModTopLevel',\n+                   'mod_child_1', 'meth')\n+    assert_refnode(refnodes[2], 'module_a.submodule', 'ModTopLevel',\n+                   'ModTopLevel.mod_child_1', 'meth')\n+    assert_refnode(refnodes[3], 'module_a.submodule', 'ModTopLevel',\n+                   'mod_child_2', 'meth')\n+    assert_refnode(refnodes[4], 'module_a.submodule', 'ModTopLevel',\n+                   'module_a.submodule.ModTopLevel.mod_child_1', 'meth')\n+    assert_refnode(refnodes[5], 'module_a.submodule', 'ModTopLevel',\n+                   'prop', 'attr')\n+    assert_refnode(refnodes[6], 'module_a.submodule', 'ModTopLevel',\n+                   'prop', 'meth')\n+    assert_refnode(refnodes[7], 'module_b.submodule', None,\n+                   'ModTopLevel', 'class')\n+    assert_refnode(refnodes[8], 'module_b.submodule', 'ModTopLevel',\n+                   'ModNoModule', 'class')\n+    assert_refnode(refnodes[9], False, False, 'int', 'class')\n+    assert_refnode(refnodes[10], False, False, 'tuple', 'class')\n+    assert_refnode(refnodes[11], False, False, 'str', 'class')\n+    assert_refnode(refnodes[12], False, False, 'float', 'class')\n+    assert_refnode(refnodes[13], False, False, 'list', 'class')\n+    assert_refnode(refnodes[14], False, False, 'ModTopLevel', 'class')\n+    assert_refnode(refnodes[15], False, False, 'index', 'doc', domain='std')\n+    assert len(refnodes) == 16\n+\n+    doctree = app.env.get_doctree('module_option')\n+    refnodes = list(doctree.traverse(pending_xref))\n+    print(refnodes)\n+    print(refnodes[0])\n+    print(refnodes[1])\n+    assert_refnode(refnodes[0], 'test.extra', 'B', 'foo', 'meth')\n+    assert_refnode(refnodes[1], 'test.extra', 'B', 'foo', 'meth')\n+    assert len(refnodes) == 2\n+\n+\n+@pytest.mark.sphinx('html', testroot='domain-py')\n+def test_domain_py_xrefs_abbreviations(app, status, warning):\n+    app.builder.build_all()\n+\n+    content = (app.outdir / 'abbr.html').read_text()\n+    assert re.search(r'normal: <a .* href=\"module.html#module_a.submodule.ModTopLevel.'\n+                     r'mod_child_1\" .*><.*>module_a.submodule.ModTopLevel.mod_child_1\\(\\)'\n+                     r'<.*></a>',\n+                     content)\n+    assert re.search(r'relative: <a .* href=\"module.html#module_a.submodule.ModTopLevel.'\n+                     r'mod_child_1\" .*><.*>ModTopLevel.mod_child_1\\(\\)<.*></a>',\n+                     content)\n+    assert re.search(r'short name: <a .* href=\"module.html#module_a.submodule.ModTopLevel.'\n+                     r'mod_child_1\" .*><.*>mod_child_1\\(\\)<.*></a>',\n+                     content)\n+    assert re.search(r'relative \\+ short name: <a .* href=\"module.html#module_a.submodule.'\n+                     r'ModTopLevel.mod_child_1\" .*><.*>mod_child_1\\(\\)<.*></a>',\n+                     content)\n+    assert re.search(r'short name \\+ relative: <a .* href=\"module.html#module_a.submodule.'\n+                     r'ModTopLevel.mod_child_1\" .*><.*>mod_child_1\\(\\)<.*></a>',\n+                     content)\n+\n+\n+@pytest.mark.sphinx('dummy', testroot='domain-py')\n+def test_domain_py_objects(app, status, warning):\n+    app.builder.build_all()\n+\n+    modules = app.env.domains['py'].data['modules']\n+    objects = app.env.domains['py'].data['objects']\n+\n+    assert 'module_a.submodule' in modules\n+    assert 'module_a.submodule' in objects\n+    assert 'module_b.submodule' in modules\n+    assert 'module_b.submodule' in objects\n+\n+    assert objects['module_a.submodule.ModTopLevel'][2] == 'class'\n+    assert objects['module_a.submodule.ModTopLevel.mod_child_1'][2] == 'method'\n+    assert objects['module_a.submodule.ModTopLevel.mod_child_2'][2] == 'method'\n+    assert 'ModTopLevel.ModNoModule' not in objects\n+    assert objects['ModNoModule'][2] == 'class'\n+    assert objects['module_b.submodule.ModTopLevel'][2] == 'class'\n+\n+    assert objects['TopLevel'][2] == 'class'\n+    assert objects['top_level'][2] == 'method'\n+    assert objects['NestedParentA'][2] == 'class'\n+    assert objects['NestedParentA.child_1'][2] == 'method'\n+    assert objects['NestedParentA.any_child'][2] == 'method'\n+    assert objects['NestedParentA.NestedChildA'][2] == 'class'\n+    assert objects['NestedParentA.NestedChildA.subchild_1'][2] == 'method'\n+    assert objects['NestedParentA.NestedChildA.subchild_2'][2] == 'method'\n+    assert objects['NestedParentA.child_2'][2] == 'method'\n+    assert objects['NestedParentB'][2] == 'class'\n+    assert objects['NestedParentB.child_1'][2] == 'method'\n+\n+\n+@pytest.mark.sphinx('html', testroot='domain-py')\n+def test_resolve_xref_for_properties(app, status, warning):\n+    app.builder.build_all()\n+\n+    content = (app.outdir / 'module.html').read_text()\n+    assert ('Link to <a class=\"reference internal\" href=\"#module_a.submodule.ModTopLevel.prop\"'\n+            ' title=\"module_a.submodule.ModTopLevel.prop\">'\n+            '<code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">'\n+            'prop</span> <span class=\"pre\">attribute</span></code></a>' in content)\n+    assert ('Link to <a class=\"reference internal\" href=\"#module_a.submodule.ModTopLevel.prop\"'\n+            ' title=\"module_a.submodule.ModTopLevel.prop\">'\n+            '<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">'\n+            'prop</span> <span class=\"pre\">method</span></code></a>' in content)\n+    assert ('Link to <a class=\"reference internal\" href=\"#module_a.submodule.ModTopLevel.prop\"'\n+            ' title=\"module_a.submodule.ModTopLevel.prop\">'\n+            '<code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">'\n+            'prop</span> <span class=\"pre\">attribute</span></code></a>' in content)\n+\n+\n+@pytest.mark.sphinx('dummy', testroot='domain-py')\n+def test_domain_py_find_obj(app, status, warning):\n+\n+    def find_obj(modname, prefix, obj_name, obj_type, searchmode=0):\n+        return app.env.domains['py'].find_obj(\n+            app.env, modname, prefix, obj_name, obj_type, searchmode)\n+\n+    app.builder.build_all()\n+\n+    assert (find_obj(None, None, 'NONEXISTANT', 'class') == [])\n+    assert (find_obj(None, None, 'NestedParentA', 'class') ==\n+            [('NestedParentA', ('roles', 'NestedParentA', 'class', False))])\n+    assert (find_obj(None, None, 'NestedParentA.NestedChildA', 'class') ==\n+            [('NestedParentA.NestedChildA',\n+              ('roles', 'NestedParentA.NestedChildA', 'class', False))])\n+    assert (find_obj(None, 'NestedParentA', 'NestedChildA', 'class') ==\n+            [('NestedParentA.NestedChildA',\n+              ('roles', 'NestedParentA.NestedChildA', 'class', False))])\n+    assert (find_obj(None, None, 'NestedParentA.NestedChildA.subchild_1', 'meth') ==\n+            [('NestedParentA.NestedChildA.subchild_1',\n+              ('roles', 'NestedParentA.NestedChildA.subchild_1', 'method', False))])\n+    assert (find_obj(None, 'NestedParentA', 'NestedChildA.subchild_1', 'meth') ==\n+            [('NestedParentA.NestedChildA.subchild_1',\n+              ('roles', 'NestedParentA.NestedChildA.subchild_1', 'method', False))])\n+    assert (find_obj(None, 'NestedParentA.NestedChildA', 'subchild_1', 'meth') ==\n+            [('NestedParentA.NestedChildA.subchild_1',\n+              ('roles', 'NestedParentA.NestedChildA.subchild_1', 'method', False))])\n+\n+\n+@pytest.mark.sphinx('html', testroot='domain-py', freshenv=True)\n+def test_domain_py_canonical(app, status, warning):\n+    app.builder.build_all()\n+\n+    content = (app.outdir / 'canonical.html').read_text()\n+    assert ('<a class=\"reference internal\" href=\"#canonical.Foo\" title=\"canonical.Foo\">'\n+            '<code class=\"xref py py-class docutils literal notranslate\">'\n+            '<span class=\"pre\">Foo</span></code></a>' in content)\n+    assert warning.getvalue() == ''\n+\n+\n+def test_get_full_qualified_name():\n+    env = Mock(domaindata={})\n+    domain = PythonDomain(env)\n+\n+    # non-python references\n+    node = nodes.reference()\n+    assert domain.get_full_qualified_name(node) is None\n+\n+    # simple reference\n+    node = nodes.reference(reftarget='func')\n+    assert domain.get_full_qualified_name(node) == 'func'\n+\n+    # with py:module context\n+    kwargs = {'py:module': 'module1'}\n+    node = nodes.reference(reftarget='func', **kwargs)\n+    assert domain.get_full_qualified_name(node) == 'module1.func'\n+\n+    # with py:class context\n+    kwargs = {'py:class': 'Class'}\n+    node = nodes.reference(reftarget='func', **kwargs)\n+    assert domain.get_full_qualified_name(node) == 'Class.func'\n+\n+    # with both py:module and py:class context\n+    kwargs = {'py:module': 'module1', 'py:class': 'Class'}\n+    node = nodes.reference(reftarget='func', **kwargs)\n+    assert domain.get_full_qualified_name(node) == 'module1.Class.func'\n+\n+\n+def test_parse_annotation(app):\n+    doctree = _parse_annotation(\"int\", app.env)\n+    assert_node(doctree, ([pending_xref, \"int\"],))\n+    assert_node(doctree[0], pending_xref, refdomain=\"py\", reftype=\"class\", reftarget=\"int\")\n+\n+    doctree = _parse_annotation(\"List[int]\", app.env)\n+    assert_node(doctree, ([pending_xref, \"List\"],\n+                          [desc_sig_punctuation, \"[\"],\n+                          [pending_xref, \"int\"],\n+                          [desc_sig_punctuation, \"]\"]))\n+\n+    doctree = _parse_annotation(\"Tuple[int, int]\", app.env)\n+    assert_node(doctree, ([pending_xref, \"Tuple\"],\n+                          [desc_sig_punctuation, \"[\"],\n+                          [pending_xref, \"int\"],\n+                          [desc_sig_punctuation, \", \"],\n+                          [pending_xref, \"int\"],\n+                          [desc_sig_punctuation, \"]\"]))\n+\n+    doctree = _parse_annotation(\"Tuple[()]\", app.env)\n+    assert_node(doctree, ([pending_xref, \"Tuple\"],\n+                          [desc_sig_punctuation, \"[\"],\n+                          [desc_sig_punctuation, \"(\"],\n+                          [desc_sig_punctuation, \")\"],\n+                          [desc_sig_punctuation, \"]\"]))\n+\n+    doctree = _parse_annotation(\"Tuple[int, ...]\", app.env)\n+    assert_node(doctree, ([pending_xref, \"Tuple\"],\n+                          [desc_sig_punctuation, \"[\"],\n+                          [pending_xref, \"int\"],\n+                          [desc_sig_punctuation, \", \"],\n+                          [desc_sig_punctuation, \"...\"],\n+                          [desc_sig_punctuation, \"]\"]))\n+\n+    doctree = _parse_annotation(\"Callable[[int, int], int]\", app.env)\n+    assert_node(doctree, ([pending_xref, \"Callable\"],\n+                          [desc_sig_punctuation, \"[\"],\n+                          [desc_sig_punctuation, \"[\"],\n+                          [pending_xref, \"int\"],\n+                          [desc_sig_punctuation, \", \"],\n+                          [pending_xref, \"int\"],\n+                          [desc_sig_punctuation, \"]\"],\n+                          [desc_sig_punctuation, \", \"],\n+                          [pending_xref, \"int\"],\n+                          [desc_sig_punctuation, \"]\"]))\n+\n+    doctree = _parse_annotation(\"List[None]\", app.env)\n+    assert_node(doctree, ([pending_xref, \"List\"],\n+                          [desc_sig_punctuation, \"[\"],\n+                          [pending_xref, \"None\"],\n+                          [desc_sig_punctuation, \"]\"]))\n+\n+    # None type makes an object-reference (not a class reference)\n+    doctree = _parse_annotation(\"None\", app.env)\n+    assert_node(doctree, ([pending_xref, \"None\"],))\n+    assert_node(doctree[0], pending_xref, refdomain=\"py\", reftype=\"obj\", reftarget=\"None\")\n+\n+\n+def test_pyfunction_signature(app):\n+    text = \".. py:function:: hello(name: str) -> str\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [desc, ([desc_signature, ([desc_name, \"hello\"],\n+                                                    desc_parameterlist,\n+                                                    [desc_returns, pending_xref, \"str\"])],\n+                                  desc_content)]))\n+    assert_node(doctree[1], addnodes.desc, desctype=\"function\",\n+                domain=\"py\", objtype=\"function\", noindex=False)\n+    assert_node(doctree[1][0][1],\n+                [desc_parameterlist, desc_parameter, ([desc_sig_name, \"name\"],\n+                                                      [desc_sig_punctuation, \":\"],\n+                                                      \" \",\n+                                                      [nodes.inline, pending_xref, \"str\"])])\n+\n+\n+def test_pyfunction_signature_full(app):\n+    text = (\".. py:function:: hello(a: str, b = 1, *args: str, \"\n+            \"c: bool = True, d: tuple = (1, 2), **kwargs: str) -> str\")\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [desc, ([desc_signature, ([desc_name, \"hello\"],\n+                                                    desc_parameterlist,\n+                                                    [desc_returns, pending_xref, \"str\"])],\n+                                  desc_content)]))\n+    assert_node(doctree[1], addnodes.desc, desctype=\"function\",\n+                domain=\"py\", objtype=\"function\", noindex=False)\n+    assert_node(doctree[1][0][1],\n+                [desc_parameterlist, ([desc_parameter, ([desc_sig_name, \"a\"],\n+                                                        [desc_sig_punctuation, \":\"],\n+                                                        \" \",\n+                                                        [desc_sig_name, pending_xref, \"str\"])],\n+                                      [desc_parameter, ([desc_sig_name, \"b\"],\n+                                                        [desc_sig_operator, \"=\"],\n+                                                        [nodes.inline, \"1\"])],\n+                                      [desc_parameter, ([desc_sig_operator, \"*\"],\n+                                                        [desc_sig_name, \"args\"],\n+                                                        [desc_sig_punctuation, \":\"],\n+                                                        \" \",\n+                                                        [desc_sig_name, pending_xref, \"str\"])],\n+                                      [desc_parameter, ([desc_sig_name, \"c\"],\n+                                                        [desc_sig_punctuation, \":\"],\n+                                                        \" \",\n+                                                        [desc_sig_name, pending_xref, \"bool\"],\n+                                                        \" \",\n+                                                        [desc_sig_operator, \"=\"],\n+                                                        \" \",\n+                                                        [nodes.inline, \"True\"])],\n+                                      [desc_parameter, ([desc_sig_name, \"d\"],\n+                                                        [desc_sig_punctuation, \":\"],\n+                                                        \" \",\n+                                                        [desc_sig_name, pending_xref, \"tuple\"],\n+                                                        \" \",\n+                                                        [desc_sig_operator, \"=\"],\n+                                                        \" \",\n+                                                        [nodes.inline, \"(1, 2)\"])],\n+                                      [desc_parameter, ([desc_sig_operator, \"**\"],\n+                                                        [desc_sig_name, \"kwargs\"],\n+                                                        [desc_sig_punctuation, \":\"],\n+                                                        \" \",\n+                                                        [desc_sig_name, pending_xref, \"str\"])])])\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 8), reason='python 3.8+ is required.')\n+def test_pyfunction_signature_full_py38(app):\n+    # case: separator at head\n+    text = \".. py:function:: hello(*, a)\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree[1][0][1],\n+                [desc_parameterlist, ([desc_parameter, nodes.inline, \"*\"],\n+                                      [desc_parameter, desc_sig_name, \"a\"])])\n+\n+    # case: separator in the middle\n+    text = \".. py:function:: hello(a, /, b, *, c)\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree[1][0][1],\n+                [desc_parameterlist, ([desc_parameter, desc_sig_name, \"a\"],\n+                                      [desc_parameter, desc_sig_operator, \"/\"],\n+                                      [desc_parameter, desc_sig_name, \"b\"],\n+                                      [desc_parameter, desc_sig_operator, \"*\"],\n+                                      [desc_parameter, desc_sig_name, \"c\"])])\n+\n+    # case: separator in the middle (2)\n+    text = \".. py:function:: hello(a, /, *, b)\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree[1][0][1],\n+                [desc_parameterlist, ([desc_parameter, desc_sig_name, \"a\"],\n+                                      [desc_parameter, desc_sig_operator, \"/\"],\n+                                      [desc_parameter, desc_sig_operator, \"*\"],\n+                                      [desc_parameter, desc_sig_name, \"b\"])])\n+\n+    # case: separator at tail\n+    text = \".. py:function:: hello(a, /)\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree[1][0][1],\n+                [desc_parameterlist, ([desc_parameter, desc_sig_name, \"a\"],\n+                                      [desc_parameter, desc_sig_operator, \"/\"])])\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 8), reason='python 3.8+ is required.')\n+def test_pyfunction_with_number_literals(app):\n+    text = \".. py:function:: hello(age=0x10, height=1_6_0)\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree[1][0][1],\n+                [desc_parameterlist, ([desc_parameter, ([desc_sig_name, \"age\"],\n+                                                        [desc_sig_operator, \"=\"],\n+                                                        [nodes.inline, \"0x10\"])],\n+                                      [desc_parameter, ([desc_sig_name, \"height\"],\n+                                                        [desc_sig_operator, \"=\"],\n+                                                        [nodes.inline, \"1_6_0\"])])])\n+\n+\n+def test_pyfunction_with_union_type_operator(app):\n+    text = \".. py:function:: hello(age: int | None)\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree[1][0][1],\n+                [desc_parameterlist, ([desc_parameter, ([desc_sig_name, \"age\"],\n+                                                        [desc_sig_punctuation, \":\"],\n+                                                        \" \",\n+                                                        [desc_sig_name, ([pending_xref, \"int\"],\n+                                                                         \" \",\n+                                                                         [desc_sig_punctuation, \"|\"],\n+                                                                         \" \",\n+                                                                         [pending_xref, \"None\"])])])])\n+\n+\n+def test_pyfield_with_union_type_operator(app):\n+    text = (\".. py:function:: foo(text)\\n\"\n+            \"\\n\"\n+            \"   :type text: bytes | str\\n\")\n+    doctree = restructuredtext.parse(app, text)\n+    field = doctree[1][1][0][0]\n+    assert_node(field[1],\n+                [nodes.paragraph, ([pending_xref, \"bytes\"],\n+                                    \" \",\n+                                    [addnodes.desc_sig_punctuation, \"|\"],\n+                                    \" \",\n+                                    [pending_xref, \"str\"])])\n+\n+\n+def test_optional_pyfunction_signature(app):\n+    text = \".. py:function:: compile(source [, filename [, symbol]]) -> ast object\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [desc, ([desc_signature, ([desc_name, \"compile\"],\n+                                                    desc_parameterlist,\n+                                                    [desc_returns, pending_xref, \"ast object\"])],\n+                                  desc_content)]))\n+    assert_node(doctree[1], addnodes.desc, desctype=\"function\",\n+                domain=\"py\", objtype=\"function\", noindex=False)\n+    assert_node(doctree[1][0][1],\n+                ([desc_parameter, \"source\"],\n+                 [desc_optional, ([desc_parameter, \"filename\"],\n+                                  [desc_optional, desc_parameter, \"symbol\"])]))\n+\n+\n+def test_pyexception_signature(app):\n+    text = \".. py:exception:: exceptions.IOError\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [desc, ([desc_signature, ([desc_annotation, \"exception \"],\n+                                                    [desc_addname, \"exceptions.\"],\n+                                                    [desc_name, \"IOError\"])],\n+                                  desc_content)]))\n+    assert_node(doctree[1], desc, desctype=\"exception\",\n+                domain=\"py\", objtype=\"exception\", noindex=False)\n+\n+\n+def test_exceptions_module_is_ignored(app):\n+    text = (\".. py:exception:: IOError\\n\"\n+            \"   :module: exceptions\\n\")\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [desc, ([desc_signature, ([desc_annotation, \"exception \"],\n+                                                    [desc_name, \"IOError\"])],\n+                                  desc_content)]))\n+    assert_node(doctree[1], desc, desctype=\"exception\",\n+                domain=\"py\", objtype=\"exception\", noindex=False)\n"], "arch": "x86_64", "base_commit": "06107f838c28ab6ca6bfc2cc208e15997fcb2146", "test_directives": ["tests/test_domain_py_pep_604.py"], "coverage_files": ["sphinx/domains/python.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.9", "pip_packages": ["tox==4.16.0", "tox-current-env==0.0.11"], "install": "python -m pip install -e .[test]", "pre_install": ["sed -i 's/pytest/pytest -rA/' tox.ini", "sed -i 's/Jinja2>=2.3/Jinja2<3.0/' setup.py", "sed -i 's/sphinxcontrib-applehelp/sphinxcontrib-applehelp<=1.0.7/' setup.py", "sed -i 's/sphinxcontrib-devhelp/sphinxcontrib-devhelp<=1.0.5/' setup.py", "sed -i 's/sphinxcontrib-qthelp/sphinxcontrib-qthelp<=1.0.6/' setup.py", "sed -i 's/alabaster>=0.7,<0.8/alabaster>=0.7,<0.7.12/' setup.py", "sed -i \"s/'packaging',/'packaging', 'markupsafe<=2.0.1',/\" setup.py", "grep -q 'sphinxcontrib-htmlhelp>=2.0.0' setup.py && sed -i 's/sphinxcontrib-htmlhelp>=2.0.0/sphinxcontrib-htmlhelp>=2.0.0,<=2.0.4/' setup.py || sed -i 's/sphinxcontrib-htmlhelp/sphinxcontrib-htmlhelp<=2.0.4/' setup.py", "grep -q 'sphinxcontrib-serializinghtml>=1.1.5' setup.py && sed -i 's/sphinxcontrib-serializinghtml>=1.1.5/sphinxcontrib-serializinghtml>=1.1.5,<=1.1.9/' setup.py || sed -i 's/sphinxcontrib-serializinghtml/sphinxcontrib-serializinghtml<=1.1.9/' setup.py"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(sphinx/domains/python\\.py)' -m tox -epy39 -v -- tests/test_domain_py_pep_604.py", "req_install_commands": ["conda create -n testbed python=3.9  -y"]}