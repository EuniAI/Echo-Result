{"instance_id": "django__django-15503", "repo": "django/django", "version": "4.1", "environment_setup_commit": "647480166bfe7532e8c471fef0146e3a17e6c0c9", "patch_list": ["diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -172,6 +172,10 @@ def as_sql(self, compiler, connection):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n+    def compile_json_path_final_key(self, key_transform):\n+        # Compile the final key without interpreting ints as array elements.\n+        return \".%s\" % json.dumps(key_transform)\n+\n     def as_sql(self, compiler, connection, template=None):\n         # Process JSON path from the left-hand side.\n         if isinstance(self.lhs, KeyTransform):\n@@ -193,13 +197,10 @@ def as_sql(self, compiler, connection, template=None):\n                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n             else:\n                 rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n+            *rhs_key_transforms, final_key = rhs_key_transforms\n+            rhs_json_path = compile_json_path(rhs_key_transforms, include_root=False)\n+            rhs_json_path += self.compile_json_path_final_key(final_key)\n+            rhs_params.append(lhs_json_path + rhs_json_path)\n         # Add condition for each key.\n         if self.logical_operator:\n             sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n@@ -253,6 +254,11 @@ class HasAnyKeys(HasKeys):\n     logical_operator = \" OR \"\n \n \n+class HasKeyOrArrayIndex(HasKey):\n+    def compile_json_path_final_key(self, key_transform):\n+        return compile_json_path([key_transform], include_root=False)\n+\n+\n class CaseInsensitiveMixin:\n     \"\"\"\n     Mixin to allow case-insensitive comparison of JSON values on MySQL.\n@@ -387,7 +393,7 @@ def __init__(self, key_transform, *args, **kwargs):\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n-        sql, params = HasKey(\n+        sql, params = HasKeyOrArrayIndex(\n             self.lhs.lhs,\n             self.lhs.key_name,\n         ).as_oracle(compiler, connection)\n@@ -401,7 +407,7 @@ def as_sqlite(self, compiler, connection):\n         template = \"JSON_TYPE(%s, %%s) IS NULL\"\n         if not self.rhs:\n             template = \"JSON_TYPE(%s, %%s) IS NOT NULL\"\n-        return HasKey(self.lhs.lhs, self.lhs.key_name).as_sql(\n+        return HasKeyOrArrayIndex(self.lhs.lhs, self.lhs.key_name).as_sql(\n             compiler,\n             connection,\n             template=template,\n@@ -466,7 +472,7 @@ def as_oracle(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n         if rhs_params == [\"null\"]:\n             # Field has key and it's NULL.\n-            has_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)\n+            has_key_expr = HasKeyOrArrayIndex(self.lhs.lhs, self.lhs.key_name)\n             has_key_sql, has_key_params = has_key_expr.as_oracle(compiler, connection)\n             is_null_expr = self.lhs.get_lookup(\"isnull\")(self.lhs, True)\n             is_null_sql, is_null_params = is_null_expr.as_sql(compiler, connection)\n", "diff --git a/tests/model_fields/test_jsonfield_repro.py b/tests/model_fields/test_jsonfield_repro.py\nnew file mode 100644\nindex 0000000000..c99d1a0894\n--- /dev/null\n+++ b/tests/model_fields/test_jsonfield_repro.py\n@@ -0,0 +1,589 @@\n+import operator\n+import uuid\n+from unittest import mock\n+\n+from django import forms\n+from django.core import serializers\n+from django.core.exceptions import ValidationError\n+from django.core.serializers.json import DjangoJSONEncoder\n+from django.db import (\n+    DataError,\n+    IntegrityError,\n+    NotSupportedError,\n+    OperationalError,\n+    connection,\n+    models,\n+)\n+from django.db.models import (\n+    Count,\n+    ExpressionWrapper,\n+    F,\n+    IntegerField,\n+    OuterRef,\n+    Q,\n+    Subquery,\n+    Transform,\n+    Value,\n+)\n+from django.db.models.expressions import RawSQL\n+from django.db.models.fields.json import (\n+    KeyTextTransform,\n+    KeyTransform,\n+    KeyTransformFactory,\n+    KeyTransformTextLookupMixin,\n+)\n+from django.db.models.functions import Cast\n+from django.test import SimpleTestCase, TestCase, skipIfDBFeature, skipUnlessDBFeature\n+from django.test.utils import CaptureQueriesContext\n+\n+from .models import CustomJSONDecoder, JSONModel, NullableJSONModel, RelatedJSONModel\n+\n+\n+@skipUnlessDBFeature(\"supports_json_field\")\n+class JSONFieldTests(TestCase):\n+    def test_invalid_value(self):\n+        msg = \"is not JSON serializable\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            NullableJSONModel.objects.create(\n+                value={\n+                    \"uuid\": uuid.UUID(\"d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475\"),\n+                }\n+            )\n+\n+    def test_custom_encoder_decoder(self):\n+        value = {\"uuid\": uuid.UUID(\"{d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475}\")}\n+        obj = NullableJSONModel(value_custom=value)\n+        obj.clean_fields()\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.value_custom, value)\n+\n+    def test_db_check_constraints(self):\n+        value = \"{@!invalid json value 123 $!@#\"\n+        with mock.patch.object(DjangoJSONEncoder, \"encode\", return_value=value):\n+            with self.assertRaises((IntegrityError, DataError, OperationalError)):\n+                NullableJSONModel.objects.create(value_custom=value)\n+\n+\n+class TestMethods(SimpleTestCase):\n+    def test_deconstruct(self):\n+        field = models.JSONField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.JSONField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_deconstruct_custom_encoder_decoder(self):\n+        field = models.JSONField(encoder=DjangoJSONEncoder, decoder=CustomJSONDecoder)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(kwargs[\"encoder\"], DjangoJSONEncoder)\n+        self.assertEqual(kwargs[\"decoder\"], CustomJSONDecoder)\n+\n+    def test_get_transforms(self):\n+        @models.JSONField.register_lookup\n+        class MyTransform(Transform):\n+            lookup_name = \"my_transform\"\n+\n+        field = models.JSONField()\n+        transform = field.get_transform(\"my_transform\")\n+        self.assertIs(transform, MyTransform)\n+        models.JSONField._unregister_lookup(MyTransform)\n+        models.JSONField._clear_cached_lookups()\n+        transform = field.get_transform(\"my_transform\")\n+        self.assertIsInstance(transform, KeyTransformFactory)\n+\n+    def test_key_transform_text_lookup_mixin_non_key_transform(self):\n+        transform = Transform(\"test\")\n+        msg = (\n+            \"Transform should be an instance of KeyTransform in order to use \"\n+            \"this lookup.\"\n+        )\n+        with self.assertRaisesMessage(TypeError, msg):\n+            KeyTransformTextLookupMixin(transform)\n+\n+\n+class TestValidation(SimpleTestCase):\n+    def test_invalid_encoder(self):\n+        msg = \"The encoder parameter must be a callable object.\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            models.JSONField(encoder=DjangoJSONEncoder())\n+\n+    def test_invalid_decoder(self):\n+        msg = \"The decoder parameter must be a callable object.\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            models.JSONField(decoder=CustomJSONDecoder())\n+\n+    def test_validation_error(self):\n+        field = models.JSONField()\n+        msg = \"Value must be valid JSON.\"\n+        value = uuid.UUID(\"{d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475}\")\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            field.clean({\"uuid\": value}, None)\n+\n+    def test_custom_encoder(self):\n+        field = models.JSONField(encoder=DjangoJSONEncoder)\n+        value = uuid.UUID(\"{d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475}\")\n+        field.clean({\"uuid\": value}, None)\n+\n+\n+class TestFormField(SimpleTestCase):\n+    def test_formfield(self):\n+        model_field = models.JSONField()\n+        form_field = model_field.formfield()\n+        self.assertIsInstance(form_field, forms.JSONField)\n+\n+    def test_formfield_custom_encoder_decoder(self):\n+        model_field = models.JSONField(\n+            encoder=DjangoJSONEncoder, decoder=CustomJSONDecoder\n+        )\n+        form_field = model_field.formfield()\n+        self.assertIs(form_field.encoder, DjangoJSONEncoder)\n+        self.assertIs(form_field.decoder, CustomJSONDecoder)\n+\n+\n+class TestSerialization(SimpleTestCase):\n+    test_data = (\n+        '[{\"fields\": {\"value\": %s}, \"model\": \"model_fields.jsonmodel\", \"pk\": null}]'\n+    )\n+    test_values = (\n+        # (Python value, serialized value),\n+        ({\"a\": \"b\", \"c\": None}, '''{\"a\": \"b\", \"c\": null}'''),\n+        (\"abc\", '\"abc\"'),\n+        ('''{\"a\": \"a\"}''', '\"{\\\"a\\\": \\\"a\\\"}\"'),\n+    )\n+\n+    def test_dumping(self):\n+        for value, serialized in self.test_values:\n+            with self.subTest(value=value):\n+                instance = JSONModel(value=value)\n+                data = serializers.serialize(\"json\", [instance])\n+                self.assertJSONEqual(data, self.test_data % serialized)\n+\n+    def test_loading(self):\n+        for value, serialized in self.test_values:\n+            with self.subTest(value=value):\n+                instance = list(\n+                    serializers.deserialize(\"json\", self.test_data % serialized)\n+                )[0].object\n+                self.assertEqual(instance.value, value)\n+\n+    def test_xml_serialization(self):\n+        test_xml_data = (\n+            '''<django-objects version=\"1.0\">'''\n+            '''<object model=\"model_fields.nullablejsonmodel\">'''\n+            '''<field name=\"value\" type=\"JSONField\">%s'''\n+            '''</field></object></django-objects>'''\n+        )\n+        for value, serialized in self.test_values:\n+            with self.subTest(value=value):\n+                instance = NullableJSONModel(value=value)\n+                data = serializers.serialize(\"xml\", [instance], fields=[\"value\"])\n+                self.assertXMLEqual(data, test_xml_data % serialized)\n+                new_instance = list(serializers.deserialize(\"xml\", data))[0].object\n+                self.assertEqual(new_instance.value, instance.value)\n+\n+\n+@skipUnlessDBFeature(\"supports_json_field\")\n+class TestSaveLoad(TestCase):\n+    def test_null(self):\n+        obj = NullableJSONModel(value=None)\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    @skipUnlessDBFeature(\"supports_primitives_in_json_field\")\n+    def test_json_null_different_from_sql_null(self):\n+        json_null = NullableJSONModel.objects.create(value=Value(\"null\"))\n+        json_null.refresh_from_db()\n+        sql_null = NullableJSONModel.objects.create(value=None)\n+        sql_null.refresh_from_db()\n+        # '''null''' is not equal to NULL in the database.\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value=Value(\"null\")),\n+            [json_null],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value=None),\n+            [json_null],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True),\n+            [sql_null],\n+        )\n+        # '''null''' is equal to NULL in Python (None).\n+        self.assertEqual(json_null.value, sql_null.value)\n+\n+    @skipUnlessDBFeature(\"supports_primitives_in_json_field\")\n+    def test_primitives(self):\n+        values = [\n+            True,\n+            1,\n+            1.45,\n+            \"String\",\n+            \"\",\n+        ]\n+        for value in values:\n+            with self.subTest(value=value):\n+                obj = JSONModel(value=value)\n+                obj.save()\n+                obj.refresh_from_db()\n+                self.assertEqual(obj.value, value)\n+\n+    def test_dict(self):\n+        values = [\n+            {},\n+            {\"name\": \"John\", \"age\": 20, \"height\": 180.3},\n+            {\"a\": True, \"b\": {\"b1\": False, \"b2\": None}},\n+        ]\n+        for value in values:\n+            with self.subTest(value=value):\n+                obj = JSONModel.objects.create(value=value)\n+                obj.refresh_from_db()\n+                self.assertEqual(obj.value, value)\n+\n+    def test_list(self):\n+        values = [\n+            [],\n+            [\"John\", 20, 180.3],\n+            [True, [False, None]],\n+        ]\n+        for value in values:\n+            with self.subTest(value=value):\n+                obj = JSONModel.objects.create(value=value)\n+                obj.refresh_from_db()\n+                self.assertEqual(obj.value, value)\n+\n+    def test_realistic_object(self):\n+        value = {\n+            \"name\": \"John\",\n+            \"age\": 20,\n+            \"pets\": [\n+                {\"name\": \"Kit\", \"type\": \"cat\", \"age\": 2},\n+                {\"name\": \"Max\", \"type\": \"dog\", \"age\": 1},\n+            ],\n+            \"courses\": [\n+                [\"A1\", \"A2\", \"A3\"],\n+                [\"B1\", \"B2\"],\n+                [\"C1\"],\n+            ],\n+        }\n+        obj = JSONModel.objects.create(value=value)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.value, value)\n+\n+\n+@skipUnlessDBFeature(\"supports_json_field\")\n+class TestQuerying(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.primitives = [True, False, \"yes\", 7, 9.6]\n+        values = [\n+            None,\n+            [],\n+            {},\n+            {\"a\": \"b\", \"c\": 14},\n+            {\n+                \"a\": \"b\",\n+                \"c\": 14,\n+                \"d\": [\"e\", {\"f\": \"g\"}],\n+                \"h\": True,\n+                \"i\": False,\n+                \"j\": None,\n+                \"k\": {\"l\": \"m\"},\n+                \"n\": [None, True, False],\n+                \"o\": '\"quoted\"',\n+                \"p\": 4.2,\n+                \"r\": {\"s\": True, \"t\": False},\n+            },\n+            [1, [2]],\n+            {\"k\": True, \"l\": False, \"foo\": \"bax\"},\n+            {\n+                \"foo\": \"bar\",\n+                \"baz\": {\"a\": \"b\", \"c\": \"d\"},\n+                \"bar\": [\"foo\", \"bar\"],\n+                \"bax\": {\"foo\": \"bar\"},\n+            },\n+        ]\n+        cls.objs = [NullableJSONModel.objects.create(value=value) for value in values]\n+        if connection.features.supports_primitives_in_json_field:\n+            cls.objs.extend(\n+                [\n+                    NullableJSONModel.objects.create(value=value)\n+                    for value in cls.primitives\n+                ]\n+            )\n+        cls.raw_sql = \"%s::jsonb\" if connection.vendor == \"postgresql\" else \"%s\"\n+\n+    def test_exact(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__exact={}),\n+            [self.objs[2]],\n+        )\n+\n+    def test_exact_complex(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__exact={\"a\": \"b\", \"c\": 14}),\n+            [self.objs[3]],\n+        )\n+\n+    def test_icontains(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__icontains=\"BaX\"),\n+            self.objs[6:8],\n+        )\n+\n+    def test_isnull(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True),\n+            [self.objs[0]],\n+        )\n+\n+    def test_ordering_by_transform(self):\n+        mariadb = connection.vendor == \"mysql\" and connection.mysql_is_mariadb\n+        values = [\n+            {\"ord\": 93, \"name\": \"bar\"},\n+            {\"ord\": 22.1, \"name\": \"foo\"},\n+            {\"ord\": -1, \"name\": \"baz\"},\n+            {\"ord\": 21.931902, \"name\": \"spam\"},\n+            {\"ord\": -100291029, \"name\": \"eggs\"},\n+        ]\n+        for field_name in [\"value\", \"value_custom\"]:\n+            with self.subTest(field=field_name):\n+                objs = [\n+                    NullableJSONModel.objects.create(**{field_name: value})\n+                    for value in values\n+                ]\n+                query = NullableJSONModel.objects.filter(\n+                    **{\"%s__name__isnull\" % field_name: False},\n+                ).order_by(\"%s__ord\" % field_name)\n+                expected = [objs[4], objs[2], objs[3], objs[1], objs[0]]\n+                if mariadb or connection.vendor == \"oracle\":\n+                    # MariaDB and Oracle return JSON values as strings.\n+                    expected = [objs[2], objs[4], objs[3], objs[1], objs[0]]\n+                self.assertSequenceEqual(query, expected)\n+\n+    def test_ordering_grouping_by_key_transform(self):\n+        base_qs = NullableJSONModel.objects.filter(value__d__0__isnull=False)\n+        for qs in (\n+            base_qs.order_by(\"value__d__0\"),\n+            base_qs.annotate(\n+                key=KeyTransform(\"0\", KeyTransform(\"d\", \"value\"))\n+            ).order_by(\"key\"),\n+        ):\n+            self.assertSequenceEqual(qs, [self.objs[4]])\n+        qs = NullableJSONModel.objects.filter(value__isnull=False)\n+        self.assertQuerysetEqual(\n+            qs.filter(value__isnull=False)\n+            .annotate(\n+                key=KeyTextTransform(\n+                    \"f\", KeyTransform(\"1\", KeyTransform(\"d\", \"value\"))\n+                ),\n+            )\n+            .values(\"key\")\n+            .annotate(count=Count(\"key\"))\n+            .order_by(\"count\"),\n+            [(None, 0), (\"g\", 1)],\n+            operator.itemgetter(\"key\", \"count\"),\n+        )\n+\n+    def test_ordering_grouping_by_count(self):\n+        qs = (\n+            NullableJSONModel.objects.filter(\n+                value__isnull=False,\n+            )\n+            .values(\"value__d__0\")\n+            .annotate(count=Count(\"value__d__0\"))\n+            .order_by(\"count\")\n+        )\n+        self.assertQuerysetEqual(qs, [0, 1], operator.itemgetter(\"count\"))\n+\n+    def test_order_grouping_custom_decoder(self):\n+        NullableJSONModel.objects.create(value_custom={\"a\": \"b\"})\n+        qs = NullableJSONModel.objects.filter(value_custom__isnull=False)\n+        self.assertSequenceEqual(\n+            qs.values(\n+                \"value_custom__a\",\n+            )\n+            .annotate(\n+                count=Count(\"id\"),\n+            )\n+            .order_by(\"value_custom__a\"),\n+            [{\"value_custom__a\": \"b\", \"count\": 1}],\n+        )\n+\n+    def test_key_transform_raw_expression(self):\n+        expr = RawSQL(self.raw_sql, ['''{\"x\": \"bar\"}'''])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__foo=KeyTransform(\"x\", expr)),\n+            [self.objs[7]],\n+        )\n+\n+    def test_nested_key_transform_raw_expression(self):\n+        expr = RawSQL(self.raw_sql, ['''{\"x\": {\"y\": \"bar\"}}'''])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(\n+                value__foo=KeyTransform(\"y\", KeyTransform(\"x\", expr))\n+            ),\n+            [self.objs[7]],\n+        )\n+\n+    def test_key_transform_expression(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__0__isnull=False)\n+            .annotate(\n+                key=KeyTransform(\"d\", \"value\"),\n+                chain=KeyTransform(\"0\", \"key\"),\n+                expr=KeyTransform(\"0\", Cast(\"key\", models.JSONField())),\n+            )\n+            .filter(chain=F(\"expr\")),\n+            [self.objs[4]],\n+        )\n+\n+    def test_key_transform_annotation_expression(self):\n+        obj = NullableJSONModel.objects.create(value={\"d\": [\"e\", \"e\"]})\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__0__isnull=False)\n+            .annotate(\n+                key=F(\"value__d\"),\n+                chain=F(\"key__0\"),\n+                expr=Cast(\"key\", models.JSONField()),\n+            )\n+            .filter(chain=F(\"expr__1\")),\n+            [obj],\n+        )\n+\n+    def test_nested_key_transform_expression(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__0__isnull=False)\n+            .annotate(\n+                key=KeyTransform(\"d\", \"value\"),\n+                chain=KeyTransform(\"f\", KeyTransform(\"1\", \"key\")),\n+                expr=KeyTransform(\n+                    \"f\", KeyTransform(\"1\", Cast(\"key\", models.JSONField()))\n+                ),\n+            )\n+            .filter(chain=F(\"expr\")),\n+            [self.objs[4]],\n+        )\n+\n+    def test_nested_key_transform_annotation_expression(self):\n+        obj = NullableJSONModel.objects.create(\n+            value={\"d\": [\"e\", {\"f\": \"g\"}, {\"f\": \"g\"}]},\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__0__isnull=False)\n+            .annotate(\n+                key=F(\"value__d\"),\n+                chain=F(\"key__1__f\"),\n+                expr=Cast(\"key\", models.JSONField()),\n+            )\n+            .filter(chain=F(\"expr__2__f\")),\n+            [obj],\n+        )\n+\n+    def test_nested_key_transform_on_subquery(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__0__isnull=False)\n+            .annotate(\n+                subquery_value=Subquery(\n+                    NullableJSONModel.objects.filter(pk=OuterRef(\"pk\")).values(\"value\")\n+                ),\n+                key=KeyTransform(\"d\", \"subquery_value\"),\n+                chain=KeyTransform(\"f\", KeyTransform(\"1\", \"key\")),\n+            )\n+            .filter(chain=\"g\"),\n+            [self.objs[4]],\n+        )\n+\n+    def test_expression_wrapper_key_transform(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.annotate(\n+                wrapped=ExpressionWrapper(\n+                    Value({\"wrapper\": \"content\"}), output_field=models.JSONField()\n+                ),\n+            )\n+            .filter(wrapped__wrapper=\"content\")\n+            .order_by(\"pk\"),\n+            self.objs,\n+        )\n+\n+    def test_has_key(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n+            [self.objs[3], self.objs[4]],\n+        )\n+\n+    def test_has_key_deep(self):\n+        tests = [\n+            (Q(value__baz__has_key=\"a\"), self.objs[7]),\n+            (\n+                Q(value__has_key=KeyTransform(\"a\", KeyTransform(\"baz\", \"value\"))),\n+                self.objs[7],\n+            ),\n+            (Q(value__has_key=F(\"value__baz__a\")), self.objs[7]),\n+            (\n+                Q(value__has_key=KeyTransform(\"c\", KeyTransform(\"baz\", \"value\"))),\n+                self.objs[7],\n+            ),\n+            (Q(value__has_key=F(\"value__baz__c\")), self.objs[7]),\n+            (Q(value__d__1__has_key=\"f\"), self.objs[4]),\n+            (\n+                Q(\n+                    value__has_key=KeyTransform(\n+                        \"f\", KeyTransform(\"1\", KeyTransform(\"d\", \"value\"))\n+                    )\n+                ),\n+                self.objs[4],\n+            ),\n+            (Q(value__has_key=F(\"value__d__1__f\")), self.objs[4]),\n+        ]\n+        for condition, expected in tests:\n+            with self.subTest(condition=condition):\n+                self.assertSequenceEqual(\n+                    NullableJSONModel.objects.filter(condition),\n+                    [expected],\n+                )\n+\n+    def test_has_key_list(self):\n+        obj = NullableJSONModel.objects.create(value=[{\"a\": 1}, {\"b\": \"x\"}])\n+        tests = [\n+            Q(value__1__has_key=\"b\"),\n+            Q(value__has_key=KeyTransform(\"b\", KeyTransform(1, \"value\"))),\n+            Q(value__has_key=KeyTransform(\"b\", KeyTransform(\"1\", \"value\"))),\n+            Q(value__has_key=F(\"value__1__b\")),\n+        ]\n+        for condition in tests:\n+            with self.subTest(condition=condition):\n+                self.assertSequenceEqual(\n+                    NullableJSONModel.objects.filter(condition),\n+                    [obj],\n+                )\n+\n+    def test_has_key_numeric_lookup(self):\n+        \"\"\"\n+        Test has_key, has_keys, and has_any_keys lookups with numeric keys.\n+        \"\"\"\n+        obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\"})\n+        queries = [\n+            Q(value__has_key=\"1111\"),\n+            Q(value__has_keys=[\"1111\"]),\n+            Q(value__has_any_keys=[\"1111\", \"2222\"]),\n+        ]\n+        for query in queries:\n+            with self.subTest(query=query):\n+                self.assertSequenceEqual(\n+                    NullableJSONModel.objects.filter(query),\n+                    [obj],\n+                )\n+\n+    def test_has_keys(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_keys=[\"a\", \"c\", \"h\"]),\n+            [self.objs[4]],\n+        )\n+\n+    def test_has_any_keys(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_any_keys=[\"c\", \"l\"]),\n+            [self.objs[3], self.objs[4], self.objs[6]],\n+        )\n"], "arch": "x86_64", "base_commit": "859a87d873ce7152af73ab851653b4e1c3ffea4c", "test_directives": ["model_fields.test_jsonfield_repro"], "coverage_files": ["django/db/models/fields/json.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.9", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/models/fields/json\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 model_fields.test_jsonfield_repro", "req_install_commands": ["conda create -n testbed python=3.9 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\naiosmtpd\nasgiref >= 3.4.1\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\nblack\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}