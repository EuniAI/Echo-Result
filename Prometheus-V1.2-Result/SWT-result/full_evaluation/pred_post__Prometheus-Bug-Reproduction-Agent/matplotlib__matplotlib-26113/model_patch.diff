diff --git a/lib/matplotlib/tests/test_hexbin.py b/lib/matplotlib/tests/test_hexbin.py
new file mode 100644
index 0000000000..18e5f2b780
--- /dev/null
+++ b/lib/matplotlib/tests/test_hexbin.py
@@ -0,0 +1,42 @@
+import numpy as np
+import matplotlib.pyplot as plt
+
+
+def test_hexbin_mincnt_with_C():
+    """
+    Test that hexbin's mincnt parameter is consistent when C is provided.
+
+    When the C parameter is provided to hexbin, the filtering of bins
+    by mincnt is inconsistent with the case where C is not provided.
+    This test checks that the number of hexagons drawn is the same
+    in both cases, as would be expected.
+    """
+    # Setup from the bug report to reproduce the issue
+    np.random.seed(42)
+    x, y = np.random.multivariate_normal(
+        [0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250
+    ).T
+    z = np.ones_like(x)
+    extent = [-3.0, 3.0, -3.0, 3.0]
+    gridsize = (7, 7)
+
+    fig, ax = plt.subplots()
+
+    # Case 1: No C argument, mincnt=1. This is the correct behavior.
+    coll_no_C = ax.hexbin(x, y, mincnt=1, extent=extent, gridsize=gridsize)
+    ax.clear()
+
+    # Case 2: C argument supplied, mincnt=1. This is the buggy behavior.
+    coll_with_C = ax.hexbin(
+        x,
+        y,
+        C=z,
+        reduce_C_function=np.sum,
+        mincnt=1,
+        extent=extent,
+        gridsize=gridsize,
+    )
+
+    # The number of hexagons drawn should be the same in both cases.
+    # This fails because with C, mincnt is treated as a strict inequality.
+    assert len(coll_no_C.get_array()) == len(coll_with_C.get_array())
