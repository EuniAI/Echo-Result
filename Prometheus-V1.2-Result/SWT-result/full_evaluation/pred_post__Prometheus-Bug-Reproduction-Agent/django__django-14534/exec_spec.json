{"instance_id": "django__django-14534", "repo": "django/django", "version": "4.0", "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4", "patch_list": ["diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -277,7 +277,7 @@ def template_name(self):\n \n     @property\n     def id_for_label(self):\n-        return 'id_%s_%s' % (self.data['name'], self.data['index'])\n+        return self.data['attrs'].get('id')\n \n     @property\n     def choice_label(self):\n", "diff --git a/tests/forms_tests/widget_tests/test_bound_widget_id_for_label.py b/tests/forms_tests/widget_tests/test_bound_widget_id_for_label.py\nnew file mode 100644\nindex 0000000000..40c3f57943\n--- /dev/null\n+++ b/tests/forms_tests/widget_tests/test_bound_widget_id_for_label.py\n@@ -0,0 +1,229 @@\n+import datetime\n+\n+from django import forms\n+from django.forms import CheckboxSelectMultiple\n+from django.test import override_settings\n+\n+from .base import WidgetTest\n+\n+\n+class CheckboxSelectMultipleTest(WidgetTest):\n+    widget = CheckboxSelectMultiple\n+\n+    def test_render_value(self):\n+        self.check_html(self.widget(choices=self.beatles), 'beatles', ['J'], html=(\n+            \"\"\"<ul>\n+            <li><label><input checked type=\"checkbox\" name=\"beatles\" value=\"J\"> John</label></li>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"P\"> Paul</label></li>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"G\"> George</label></li>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"R\"> Ringo</label></li>\n+            </ul>\"\"\"\n+        ))\n+\n+    def test_render_value_multiple(self):\n+        self.check_html(self.widget(choices=self.beatles), 'beatles', ['J', 'P'], html=(\n+            \"\"\"<ul>\n+            <li><label><input checked type=\"checkbox\" name=\"beatles\" value=\"J\"> John</label></li>\n+            <li><label><input checked type=\"checkbox\" name=\"beatles\" value=\"P\"> Paul</label></li>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"G\"> George</label></li>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"R\"> Ringo</label></li>\n+            </ul>\"\"\"\n+        ))\n+\n+    def test_render_none(self):\n+        \"\"\"\n+        If the value is None, none of the options are selected, even if the\n+        choices have an empty option.\n+        \"\"\"\n+        self.check_html(self.widget(choices=(('', 'Unknown'),) + self.beatles), 'beatles', None, html=(\n+            \"\"\"<ul>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"\"> Unknown</label></li>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"J\"> John</label></li>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"P\"> Paul</label></li>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"G\"> George</label></li>\n+            <li><label><input type=\"checkbox\" name=\"beatles\" value=\"R\"> Ringo</label></li>\n+            </ul>\"\"\"\n+        ))\n+\n+    def test_nested_choices(self):\n+        nested_choices = (\n+            ('unknown', 'Unknown'),\n+            ('Audio', (('vinyl', 'Vinyl'), ('cd', 'CD'))),\n+            ('Video', (('vhs', 'VHS'), ('dvd', 'DVD'))),\n+        )\n+        html = \"\"\"\n+        <ul id=\"media\">\n+        <li>\n+        <label for=\"media_0\"><input id=\"media_0\" name=\"nestchoice\" type=\"checkbox\" value=\"unknown\"> Unknown</label>\n+        </li>\n+        <li>Audio<ul id=\"media_1\">\n+        <li>\n+        <label for=\"media_1_0\">\n+        <input checked id=\"media_1_0\" name=\"nestchoice\" type=\"checkbox\" value=\"vinyl\"> Vinyl\n+        </label>\n+        </li>\n+        <li>\n+        <label for=\"media_1_1\"><input id=\"media_1_1\" name=\"nestchoice\" type=\"checkbox\" value=\"cd\"> CD</label>\n+        </li>\n+        </ul></li>\n+        <li>Video<ul id=\"media_2\">\n+        <li>\n+        <label for=\"media_2_0\"><input id=\"media_2_0\" name=\"nestchoice\" type=\"checkbox\" value=\"vhs\"> VHS</label>\n+        </li>\n+        <li>\n+        <label for=\"media_2_1\">\n+        <input checked id=\"media_2_1\" name=\"nestchoice\" type=\"checkbox\" value=\"dvd\"> DVD\n+        </label>\n+        </li>\n+        </ul></li>\n+        </ul>\n+        \"\"\"\n+        self.check_html(\n+            self.widget(choices=nested_choices), 'nestchoice', ('vinyl', 'dvd'),\n+            attrs={'id': 'media'}, html=html,\n+        )\n+\n+    def test_nested_choices_without_id(self):\n+        nested_choices = (\n+            ('unknown', 'Unknown'),\n+            ('Audio', (('vinyl', 'Vinyl'), ('cd', 'CD'))),\n+            ('Video', (('vhs', 'VHS'), ('dvd', 'DVD'))),\n+        )\n+        html = \"\"\"\n+        <ul>\n+        <li>\n+        <label><input name=\"nestchoice\" type=\"checkbox\" value=\"unknown\"> Unknown</label>\n+        </li>\n+        <li>Audio<ul>\n+        <li>\n+        <label>\n+        <input checked name=\"nestchoice\" type=\"checkbox\" value=\"vinyl\"> Vinyl\n+        </label>\n+        </li>\n+        <li>\n+        <label><input name=\"nestchoice\" type=\"checkbox\" value=\"cd\"> CD</label>\n+        </li>\n+        </ul></li>\n+        <li>Video<ul>\n+        <li>\n+        <label><input name=\"nestchoice\" type=\"checkbox\" value=\"vhs\"> VHS</label>\n+        </li>\n+        <li>\n+        <label>\n+        <input checked name=\"nestchoice\" type=\"checkbox\" value=\"dvd\"> DVD\n+        </label>\n+        </li>\n+        </ul></li>\n+        </ul>\n+        \"\"\"\n+        self.check_html(self.widget(choices=nested_choices), 'nestchoice', ('vinyl', 'dvd'), html=html)\n+\n+    def test_separate_ids(self):\n+        \"\"\"\n+        Each input gets a separate ID.\n+        \"\"\"\n+        choices = [('a', 'A'), ('b', 'B'), ('c', 'C')]\n+        html = \"\"\"\n+        <ul id=\"abc\">\n+        <li>\n+        <label for=\"abc_0\"><input checked type=\"checkbox\" name=\"letters\" value=\"a\" id=\"abc_0\"> A</label>\n+        </li>\n+        <li><label for=\"abc_1\"><input type=\"checkbox\" name=\"letters\" value=\"b\" id=\"abc_1\"> B</label></li>\n+        <li>\n+        <label for=\"abc_2\"><input checked type=\"checkbox\" name=\"letters\" value=\"c\" id=\"abc_2\"> C</label>\n+        </li>\n+        </ul>\n+        \"\"\"\n+        self.check_html(self.widget(choices=choices), 'letters', ['a', 'c'], attrs={'id': 'abc'}, html=html)\n+\n+    def test_separate_ids_constructor(self):\n+        \"\"\"\n+        Each input gets a separate ID when the ID is passed to the constructor.\n+        \"\"\"\n+        widget = CheckboxSelectMultiple(attrs={'id': 'abc'}, choices=[('a', 'A'), ('b', 'B'), ('c', 'C')])\n+        html = \"\"\"\n+        <ul id=\"abc\">\n+        <li>\n+        <label for=\"abc_0\"><input checked type=\"checkbox\" name=\"letters\" value=\"a\" id=\"abc_0\"> A</label>\n+        </li>\n+        <li><label for=\"abc_1\"><input type=\"checkbox\" name=\"letters\" value=\"b\" id=\"abc_1\"> B</label></li>\n+        <li>\n+        <label for=\"abc_2\"><input checked type=\"checkbox\" name=\"letters\" value=\"c\" id=\"abc_2\"> C</label>\n+        </li>\n+        </ul>\n+        \"\"\"\n+        self.check_html(widget, 'letters', ['a', 'c'], html=html)\n+\n+    @override_settings(USE_L10N=True, USE_THOUSAND_SEPARATOR=True)\n+    def test_doesnt_localize_input_value(self):\n+        choices = [\n+            (1, 'One'),\n+            (1000, 'One thousand'),\n+            (1000000, 'One million'),\n+        ]\n+        html = \"\"\"\n+        <ul>\n+        <li><label><input type=\"checkbox\" name=\"numbers\" value=\"1\"> One</label></li>\n+        <li><label><input type=\"checkbox\" name=\"numbers\" value=\"1000\"> One thousand</label></li>\n+        <li><label><input type=\"checkbox\" name=\"numbers\" value=\"1000000\"> One million</label></li>\n+        </ul>\n+        \"\"\"\n+        self.check_html(self.widget(choices=choices), 'numbers', None, html=html)\n+\n+        choices = [\n+            (datetime.time(0, 0), 'midnight'),\n+            (datetime.time(12, 0), 'noon'),\n+        ]\n+        html = \"\"\"\n+        <ul>\n+        <li><label><input type=\"checkbox\" name=\"times\" value=\"00:00:00\"> midnight</label></li>\n+        <li><label><input type=\"checkbox\" name=\"times\" value=\"12:00:00\"> noon</label></li>\n+        </ul>\n+        \"\"\"\n+        self.check_html(self.widget(choices=choices), 'times', None, html=html)\n+\n+    def test_use_required_attribute(self):\n+        widget = self.widget(choices=self.beatles)\n+        # Always False because browser validation would require all checkboxes\n+        # to be checked instead of at least one.\n+        self.assertIs(widget.use_required_attribute(None), False)\n+        self.assertIs(widget.use_required_attribute([]), False)\n+        self.assertIs(widget.use_required_attribute(['J', 'P']), False)\n+\n+    def test_value_omitted_from_data(self):\n+        widget = self.widget(choices=self.beatles)\n+        self.assertIs(widget.value_omitted_from_data({}, {}, 'field'), False)\n+        self.assertIs(widget.value_omitted_from_data({'field': 'value'}, {}, 'field'), False)\n+\n+    def test_label(self):\n+        \"\"\"\n+        CheckboxSelectMultiple doesn't contain 'for=\"field_0\"' in the <label>\n+        because clicking that would toggle the first checkbox.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            f = forms.MultipleChoiceField(widget=CheckboxSelectMultiple)\n+\n+        bound_field = TestForm()['f']\n+        self.assertEqual(bound_field.field.widget.id_for_label('id'), '')\n+        self.assertEqual(bound_field.label_tag(), '<label>F:</label>')\n+\n+    def test_bound_widget_id_for_label(self):\n+        \"\"\"\n+        BoundWidget.id_for_label() should use the widget's attrs['id']\n+        that is passed from BoundField.subwidgets().\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            field = forms.MultipleChoiceField(\n+                choices=(('a', 'A'), ('b', 'B')),\n+                widget=CheckboxSelectMultiple,\n+            )\n+        form = TestForm(auto_id='test_%s')\n+        bound_field = form['field']\n+        # The 'for' attribute of the label should be based on auto_id.\n+        # The bug is that BoundWidget.id_for_label() generates its own ID\n+        # ('id_field_0') instead of using the one passed to the widget\n+        # ('test_field_0').\n+        self.assertInHTML(\n+            '<label for=\"test_field_0\">',\n+            str(list(bound_field)[0])\n+        )\n"], "arch": "x86_64", "base_commit": "910ecd1b8df7678f45c3d507dde6bcb1faafa243", "test_directives": ["forms_tests.widget_tests.test_bound_widget_id_for_label"], "coverage_files": ["django/forms/boundfield.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.8", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/forms/boundfield\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 forms_tests.widget_tests.test_bound_widget_id_for_label", "req_install_commands": ["conda create -n testbed python=3.8 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}