{"instance_id": "django__django-11490", "repo": "django/django", "version": "3.0", "environment_setup_commit": "419a78300f7cd27611196e1e464d50fd0385ff27", "patch_list": ["diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -426,6 +426,7 @@ def get_combinator_sql(self, combinator, all):\n                 # must have the same columns list. Set the selects defined on\n                 # the query on all combined queries, if not already set.\n                 if not compiler.query.values_select and self.query.values_select:\n+                    compiler.query = compiler.query.clone()\n                     compiler.query.set_values((\n                         *self.query.extra_select,\n                         *self.query.values_select,\n", "diff --git a/tests/queries/test_queryset_set_operations.py b/tests/queries/test_queryset_set_operations.py\nnew file mode 100644\nindex 0000000000..90ffb3cb96\n--- /dev/null\n+++ b/tests/queries/test_queryset_set_operations.py\n@@ -0,0 +1,241 @@\n+import pytest\n+from django.db.models import Exists, F, IntegerField, OuterRef, Value\n+from django.db.utils import DatabaseError, NotSupportedError\n+from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n+\n+from .models import Number, ReservedName\n+\n+\n+@skipUnlessDBFeature('supports_select_union')\n+class QuerySetSetOperationTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        Number.objects.bulk_create(Number(num=i) for i in range(10))\n+\n+    def number_transform(self, value):\n+        return value.num\n+\n+    def assertNumbersEqual(self, queryset, expected_numbers, ordered=True):\n+        self.assertQuerysetEqual(queryset, expected_numbers, self.number_transform, ordered)\n+\n+    def test_simple_union(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=8)\n+        qs3 = Number.objects.filter(num=5)\n+        self.assertNumbersEqual(qs1.union(qs2, qs3), [0, 1, 5, 8, 9], ordered=False)\n+\n+    @skipUnlessDBFeature('supports_select_intersection')\n+    def test_simple_intersection(self):\n+        qs1 = Number.objects.filter(num__lte=5)\n+        qs2 = Number.objects.filter(num__gte=5)\n+        qs3 = Number.objects.filter(num__gte=4, num__lte=6)\n+        self.assertNumbersEqual(qs1.intersection(qs2, qs3), [5], ordered=False)\n+\n+    @skipUnlessDBFeature('supports_select_intersection')\n+    def test_intersection_with_values(self):\n+        ReservedName.objects.create(name='a', order=2)\n+        qs1 = ReservedName.objects.all()\n+        reserved_name = qs1.intersection(qs1).values('name', 'order', 'id').get()\n+        self.assertEqual(reserved_name['name'], 'a')\n+        self.assertEqual(reserved_name['order'], 2)\n+        reserved_name = qs1.intersection(qs1).values_list('name', 'order', 'id').get()\n+        self.assertEqual(reserved_name[:2], ('a', 2))\n+\n+    @skipUnlessDBFeature('supports_select_difference')\n+    def test_simple_difference(self):\n+        qs1 = Number.objects.filter(num__lte=5)\n+        qs2 = Number.objects.filter(num__lte=4)\n+        self.assertNumbersEqual(qs1.difference(qs2), [5], ordered=False)\n+\n+    def test_union_distinct(self):\n+        qs1 = Number.objects.all()\n+        qs2 = Number.objects.all()\n+        self.assertEqual(len(list(qs1.union(qs2, all=True))), 20)\n+        self.assertEqual(len(list(qs1.union(qs2))), 10)\n+\n+    @skipUnlessDBFeature('supports_select_intersection')\n+    def test_intersection_with_empty_qs(self):\n+        qs1 = Number.objects.all()\n+        qs2 = Number.objects.none()\n+        qs3 = Number.objects.filter(pk__in=[])\n+        self.assertEqual(len(qs1.intersection(qs2)), 0)\n+        self.assertEqual(len(qs1.intersection(qs3)), 0)\n+        self.assertEqual(len(qs2.intersection(qs1)), 0)\n+        self.assertEqual(len(qs3.intersection(qs1)), 0)\n+        self.assertEqual(len(qs2.intersection(qs2)), 0)\n+        self.assertEqual(len(qs3.intersection(qs3)), 0)\n+\n+    @skipUnlessDBFeature('supports_select_difference')\n+    def test_difference_with_empty_qs(self):\n+        qs1 = Number.objects.all()\n+        qs2 = Number.objects.none()\n+        qs3 = Number.objects.filter(pk__in=[])\n+        self.assertEqual(len(qs1.difference(qs2)), 10)\n+        self.assertEqual(len(qs1.difference(qs3)), 10)\n+        self.assertEqual(len(qs2.difference(qs1)), 0)\n+        self.assertEqual(len(qs3.difference(qs1)), 0)\n+        self.assertEqual(len(qs2.difference(qs2)), 0)\n+        self.assertEqual(len(qs3.difference(qs3)), 0)\n+\n+    @skipUnlessDBFeature('supports_select_difference')\n+    def test_difference_with_values(self):\n+        ReservedName.objects.create(name='a', order=2)\n+        qs1 = ReservedName.objects.all()\n+        qs2 = ReservedName.objects.none()\n+        reserved_name = qs1.difference(qs2).values('name', 'order', 'id').get()\n+        self.assertEqual(reserved_name['name'], 'a')\n+        self.assertEqual(reserved_name['order'], 2)\n+        reserved_name = qs1.difference(qs2).values_list('name', 'order', 'id').get()\n+        self.assertEqual(reserved_name[:2], ('a', 2))\n+\n+    def test_union_with_empty_qs(self):\n+        qs1 = Number.objects.all()\n+        qs2 = Number.objects.none()\n+        qs3 = Number.objects.filter(pk__in=[])\n+        self.assertEqual(len(qs1.union(qs2)), 10)\n+        self.assertEqual(len(qs2.union(qs1)), 10)\n+        self.assertEqual(len(qs1.union(qs3)), 10)\n+        self.assertEqual(len(qs3.union(qs1)), 10)\n+        self.assertEqual(len(qs2.union(qs1, qs1, qs1)), 10)\n+        self.assertEqual(len(qs2.union(qs1, qs1, all=True)), 20)\n+        self.assertEqual(len(qs2.union(qs2)), 0)\n+        self.assertEqual(len(qs3.union(qs3)), 0)\n+\n+    def test_limits(self):\n+        qs1 = Number.objects.all()\n+        qs2 = Number.objects.all()\n+        self.assertEqual(len(list(qs1.union(qs2)[:2])), 2)\n+\n+    def test_ordering(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=2, num__lte=3)\n+        self.assertNumbersEqual(qs1.union(qs2).order_by('-num'), [3, 2, 1, 0])\n+\n+    def test_ordering_by_f_expression(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=2, num__lte=3)\n+        self.assertNumbersEqual(qs1.union(qs2).order_by(F('num').desc()), [3, 2, 1, 0])\n+\n+    def test_union_with_values(self):\n+        ReservedName.objects.create(name='a', order=2)\n+        qs1 = ReservedName.objects.all()\n+        reserved_name = qs1.union(qs1).values('name', 'order', 'id').get()\n+        self.assertEqual(reserved_name['name'], 'a')\n+        self.assertEqual(reserved_name['order'], 2)\n+        reserved_name = qs1.union(qs1).values_list('name', 'order', 'id').get()\n+        self.assertEqual(reserved_name[:2], ('a', 2))\n+\n+    def test_composed_queryset_values_columns_change(self):\n+        \"\"\"\n+        A composed queryset can change its output columns when values() or\n+        values_list() is called multiple times.\n+        \"\"\"\n+        ReservedName.objects.create(name='a', order=2)\n+        qs = ReservedName.objects.all()\n+        composed_qs = qs.union(qs)\n+        # Prime the compiler with a different set of columns.\n+        composed_qs.values_list('name', 'order').get()\n+        # This second call should use a different column list ('order').\n+        self.assertEqual(composed_qs.values_list('order').get(), (2,))\n+\n+    def test_union_with_two_annotated_values_list(self):\n+        qs1 = Number.objects.filter(num=1).annotate(\n+            count=Value(0, IntegerField()),\n+        ).values_list('num', 'count')\n+        qs2 = Number.objects.filter(num=2).values('pk').annotate(\n+            count=F('num'),\n+        ).annotate(\n+            num=Value(1, IntegerField()),\n+        ).values_list('num', 'count')\n+        self.assertCountEqual(qs1.union(qs2), [(1, 0), (2, 1)])\n+\n+    def test_union_with_extra_and_values_list(self):\n+        qs1 = Number.objects.filter(num=1).extra(\n+            select={'count': 0},\n+        ).values_list('num', 'count')\n+        qs2 = Number.objects.filter(num=2).extra(select={'count': 1})\n+        self.assertCountEqual(qs1.union(qs2), [(1, 0), (2, 1)])\n+\n+    def test_union_with_values_list_on_annotated_and_unannotated(self):\n+        ReservedName.objects.create(name='rn1', order=1)\n+        qs1 = Number.objects.annotate(\n+            has_reserved_name=Exists(ReservedName.objects.filter(order=OuterRef('num')))\n+        ).filter(has_reserved_name=True)\n+        qs2 = Number.objects.filter(num=9)\n+        self.assertCountEqual(qs1.union(qs2).values_list('num', flat=True), [1, 9])\n+\n+    def test_count_union(self):\n+        qs1 = Number.objects.filter(num__lte=1).values('num')\n+        qs2 = Number.objects.filter(num__gte=2, num__lte=3).values('num')\n+        self.assertEqual(qs1.union(qs2).count(), 4)\n+\n+    def test_count_union_empty_result(self):\n+        qs = Number.objects.filter(pk__in=[])\n+        self.assertEqual(qs.union(qs).count(), 0)\n+\n+    @skipUnlessDBFeature('supports_select_difference')\n+    def test_count_difference(self):\n+        qs1 = Number.objects.filter(num__lt=10)\n+        qs2 = Number.objects.filter(num__lt=9)\n+        self.assertEqual(qs1.difference(qs2).count(), 1)\n+\n+    @skipUnlessDBFeature('supports_select_intersection')\n+    def test_count_intersection(self):\n+        qs1 = Number.objects.filter(num__gte=5)\n+        qs2 = Number.objects.filter(num__lte=5)\n+        self.assertEqual(qs1.intersection(qs2).count(), 1)\n+\n+    @skipUnlessDBFeature('supports_slicing_ordering_in_compound')\n+    def test_ordering_subqueries(self):\n+        qs1 = Number.objects.order_by('num')[:2]\n+        qs2 = Number.objects.order_by('-num')[:2]\n+        self.assertNumbersEqual(qs1.union(qs2).order_by('-num')[:4], [9, 8, 1, 0])\n+\n+    @skipIfDBFeature('supports_slicing_ordering_in_compound')\n+    def test_unsupported_ordering_slicing_raises_db_error(self):\n+        qs1 = Number.objects.all()\n+        qs2 = Number.objects.all()\n+        msg = 'LIMIT/OFFSET not allowed in subqueries of compound statements'\n+        with self.assertRaisesMessage(DatabaseError, msg):\n+            list(qs1.union(qs2[:10]))\n+        msg = 'ORDER BY not allowed in subqueries of compound statements'\n+        with self.assertRaisesMessage(DatabaseError, msg):\n+            list(qs1.order_by('id').union(qs2))\n+\n+    @skipIfDBFeature('supports_select_intersection')\n+    def test_unsupported_intersection_raises_db_error(self):\n+        qs1 = Number.objects.all()\n+        qs2 = Number.objects.all()\n+        msg = 'intersection is not supported on this database backend'\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            list(qs1.intersection(qs2))\n+\n+    def test_combining_multiple_models(self):\n+        ReservedName.objects.create(name='99 little bugs', order=99)\n+        qs1 = Number.objects.filter(num=1).values_list('num', flat=True)\n+        qs2 = ReservedName.objects.values_list('order')\n+        self.assertEqual(list(qs1.union(qs2).order_by('num')), [1, 99])\n+\n+    def test_order_raises_on_non_selected_column(self):\n+        qs1 = Number.objects.filter().annotate(\n+            annotation=Value(1, IntegerField()),\n+        ).values('annotation', num2=F('num'))\n+        qs2 = Number.objects.filter().values('id', 'num')\n+        # Should not raise\n+        list(qs1.union(qs2).order_by('annotation'))\n+        list(qs1.union(qs2).order_by('num2'))\n+        msg = 'ORDER BY term does not match any column in the result set'\n+        # 'id' is not part of the select\n+        with self.assertRaisesMessage(DatabaseError, msg):\n+            list(qs1.union(qs2).order_by('id'))\n+        # 'num' got realiased to num2\n+        with self.assertRaisesMessage(DatabaseError, msg):\n+            list(qs1.union(qs2).order_by('num'))\n+        # switched order, now 'exists' again:\n+        list(qs2.union(qs1).order_by('num'))\n+\n+    @skipUnlessDBFeature('supports_select_difference', 'supports_select_intersection')\n+    def test_qs_with_subcompound_qs(self):\n+        qs1 = Number.objects.all()\n+        qs2 = Number.objects.intersection(Number.objects.filter(num__gt=1))\n+        self.assertEqual(qs1.difference(qs2).count(), 2)\n"], "arch": "x86_64", "base_commit": "a7038adbd02c916315b16939b835f021c2ee8880", "test_directives": ["queries.test_queryset_set_operations"], "coverage_files": ["django/db/models/sql/compiler.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/models/sql/compiler\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 queries.test_queryset_set_operations", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref ~= 3.2\nargon2-cffi >= 16.1.0\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow != 5.4.0\npylibmc; sys.platform != 'win32'\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}