{"instance_id": "django__django-12754", "repo": "django/django", "version": "3.2", "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d", "patch_list": ["diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -563,6 +563,16 @@ def generate_created_models(self):\n                 if isinstance(base, str) and \".\" in base:\n                     base_app_label, base_name = base.split(\".\", 1)\n                     dependencies.append((base_app_label, base_name, None, True))\n+                    # Depend on the removal of base fields if the new model has\n+                    # a field with the same name.\n+                    old_base_model_state = self.from_state.models.get((base_app_label, base_name))\n+                    new_base_model_state = self.to_state.models.get((base_app_label, base_name))\n+                    if old_base_model_state and new_base_model_state:\n+                        removed_base_fields = set(old_base_model_state.fields).difference(\n+                            new_base_model_state.fields,\n+                        ).intersection(model_state.fields)\n+                        for removed_base_field in removed_base_fields:\n+                            dependencies.append((base_app_label, base_name, removed_base_field, False))\n             # Depend on the other end of the primary key if it's a relation\n             if primary_key_rel:\n                 dependencies.append((\n", "diff --git a/tests/migrations/test_autodetector_bug.py b/tests/migrations/test_autodetector_bug.py\nnew file mode 100644\nindex 0000000000..4498079d26\n--- /dev/null\n+++ b/tests/migrations/test_autodetector_bug.py\n@@ -0,0 +1,2490 @@\n+import functools\n+import re\n+from unittest import mock\n+\n+from django.apps import apps\n+from django.conf import settings\n+from django.contrib.auth.models import AbstractBaseUser\n+from django.core.validators import RegexValidator, validate_slug\n+from django.db import connection, models\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.graph import MigrationGraph\n+from django.db.migrations.loader import MigrationLoader\n+from django.db.migrations.questioner import MigrationQuestioner\n+from django.db.migrations.state import ModelState, ProjectState\n+from django.test import TestCase, override_settings\n+from django.test.utils import isolate_lru_cache\n+\n+from .models import FoodManager, FoodQuerySet\n+\n+\n+class DeconstructibleObject:\n+    \"\"\"\n+    A custom deconstructible object.\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs):\n+        self.args = args\n+        self.kwargs = kwargs\n+\n+    def deconstruct(self):\n+        return (\n+            self.__module__ + '.' + self.__class__.__name__,\n+            self.args,\n+            self.kwargs\n+        )\n+\n+\n+class AutodetectorTests(TestCase):\n+    \"\"\"\n+    Tests the migration autodetector.\n+    \"\"\"\n+\n+    author_empty = ModelState(\"testapp\", \"Author\", [(\"id\", models.AutoField(primary_key=True))])\n+    author_name = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200)),\n+    ])\n+    author_name_null = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, null=True)),\n+    ])\n+    author_name_longer = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=400)),\n+    ])\n+    author_name_renamed = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"names\", models.CharField(max_length=200)),\n+    ])\n+    author_name_default = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default='Ada Lovelace')),\n+    ])\n+    author_name_check_constraint = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200)),\n+    ],\n+        {'constraints': [models.CheckConstraint(check=models.Q(name__contains='Bob'), name='name_contains_bob')]},\n+    )\n+    author_dates_of_birth_auto_now = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"date_of_birth\", models.DateField(auto_now=True)),\n+        (\"date_time_of_birth\", models.DateTimeField(auto_now=True)),\n+        (\"time_of_birth\", models.TimeField(auto_now=True)),\n+    ])\n+    author_dates_of_birth_auto_now_add = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"date_of_birth\", models.DateField(auto_now_add=True)),\n+        (\"date_time_of_birth\", models.DateTimeField(auto_now_add=True)),\n+        (\"time_of_birth\", models.TimeField(auto_now_add=True)),\n+    ])\n+    author_name_deconstructible_1 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=DeconstructibleObject())),\n+    ])\n+    author_name_deconstructible_2 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=DeconstructibleObject())),\n+    ])\n+    author_name_deconstructible_3 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=models.IntegerField())),\n+    ])\n+    author_name_deconstructible_4 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=models.IntegerField())),\n+    ])\n+    author_name_deconstructible_list_1 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=[DeconstructibleObject(), 123])),\n+    ])\n+    author_name_deconstructible_list_2 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=[DeconstructibleObject(), 123])),\n+    ])\n+    author_name_deconstructible_list_3 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=[DeconstructibleObject(), 999])),\n+    ])\n+    author_name_deconstructible_tuple_1 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=(DeconstructibleObject(), 123))),\n+    ])\n+    author_name_deconstructible_tuple_2 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=(DeconstructibleObject(), 123))),\n+    ])\n+    author_name_deconstructible_tuple_3 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=(DeconstructibleObject(), 999))),\n+    ])\n+    author_name_deconstructible_dict_1 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default={\n+            'item': DeconstructibleObject(), 'otheritem': 123\n+        })),\n+    ])\n+    author_name_deconstructible_dict_2 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default={\n+            'item': DeconstructibleObject(), 'otheritem': 123\n+        })),\n+    ])\n+    author_name_deconstructible_dict_3 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default={\n+            'item': DeconstructibleObject(), 'otheritem': 999\n+        })),\n+    ])\n+    author_name_nested_deconstructible_1 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=DeconstructibleObject(\n+            DeconstructibleObject(1),\n+            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),\n+            a=DeconstructibleObject('A'),\n+            b=DeconstructibleObject(B=DeconstructibleObject('c')),\n+        ))),\n+    ])\n+    author_name_nested_deconstructible_2 = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=DeconstructibleObject(\n+            DeconstructibleObject(1),\n+            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),\n+            a=DeconstructibleObject('A'),\n+            b=DeconstructibleObject(B=DeconstructibleObject('c')),\n+        ))),\n+    ])\n+    author_name_nested_deconstructible_changed_arg = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=DeconstructibleObject(\n+            DeconstructibleObject(1),\n+            (DeconstructibleObject('t1'), DeconstructibleObject('t2-changed'),),\n+            a=DeconstructibleObject('A'),\n+            b=DeconstructibleObject(B=DeconstructibleObject('c')),\n+        ))),\n+    ])\n+    author_name_nested_deconstructible_extra_arg = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=DeconstructibleObject(\n+            DeconstructibleObject(1),\n+            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),\n+            None,\n+            a=DeconstructibleObject('A'),\n+            b=DeconstructibleObject(B=DeconstructibleObject('c')),\n+        ))),\n+    ])\n+    author_name_nested_deconstructible_changed_kwarg = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=DeconstructibleObject(\n+            DeconstructibleObject(1),\n+            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),\n+            a=DeconstructibleObject('A'),\n+            b=DeconstructibleObject(B=DeconstructibleObject('c-changed')),\n+        ))),\n+    ])\n+    author_name_nested_deconstructible_extra_kwarg = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200, default=DeconstructibleObject(\n+            DeconstructibleObject(1),\n+            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),\n+            a=DeconstructibleObject('A'),\n+            b=DeconstructibleObject(B=DeconstructibleObject('c')),\n+            c=None,\n+        ))),\n+    ])\n+    author_custom_pk = ModelState(\"testapp\", \"Author\", [(\"pk_field\", models.IntegerField(primary_key=True))])\n+    author_with_biography_non_blank = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField()),\n+        (\"biography\", models.TextField()),\n+    ])\n+    author_with_biography_blank = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(blank=True)),\n+        (\"biography\", models.TextField(blank=True)),\n+    ])\n+    author_with_book = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200)),\n+        (\"book\", models.ForeignKey(\"otherapp.Book\", models.CASCADE)),\n+    ])\n+    author_with_book_order_wrt = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200)),\n+        (\"book\", models.ForeignKey(\"otherapp.Book\", models.CASCADE)),\n+    ], options={\"order_with_respect_to\": \"book\"})\n+    author_renamed_with_book = ModelState(\"testapp\", \"Writer\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200)),\n+        (\"book\", models.ForeignKey(\"otherapp.Book\", models.CASCADE)),\n+    ])\n+    author_with_publisher_string = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200)),\n+        (\"publisher_name\", models.CharField(max_length=200)),\n+    ])\n+    author_with_publisher = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200)),\n+        (\"publisher\", models.ForeignKey(\"testapp.Publisher\", models.CASCADE)),\n+    ])\n+    author_with_user = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200)),\n+        (\"user\", models.ForeignKey(\"auth.User\", models.CASCADE)),\n+    ])\n+    author_with_custom_user = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=200)),\n+        (\"user\", models.ForeignKey(\"thirdapp.CustomUser\", models.CASCADE)),\n+    ])\n+    author_proxy = ModelState(\"testapp\", \"AuthorProxy\", [], {\"proxy\": True}, (\"testapp.author\",))\n+    author_proxy_options = ModelState(\"testapp\", \"AuthorProxy\", [], {\n+        \"proxy\": True,\n+        \"verbose_name\": \"Super Author\",\n+    }, (\"testapp.author\",))\n+    author_proxy_notproxy = ModelState(\"testapp\", \"AuthorProxy\", [], {}, (\"testapp.author\",))\n+    author_proxy_third = ModelState(\"thirdapp\", \"AuthorProxy\", [], {\"proxy\": True}, (\"testapp.author\",))\n+    author_proxy_third_notproxy = ModelState(\"thirdapp\", \"AuthorProxy\", [], {}, (\"testapp.author\",))\n+    author_proxy_proxy = ModelState(\"testapp\", \"AAuthorProxyProxy\", [], {\"proxy\": True}, (\"testapp.authorproxy\",))\n+    author_unmanaged = ModelState(\"testapp\", \"AuthorUnmanaged\", [], {\"managed\": False}, (\"testapp.author\",))\n+    author_unmanaged_managed = ModelState(\"testapp\", \"AuthorUnmanaged\", [], {}, (\"testapp.author\",))\n+    author_unmanaged_default_pk = ModelState(\"testapp\", \"Author\", [(\"id\", models.AutoField(primary_key=True))])\n+    author_unmanaged_custom_pk = ModelState(\"testapp\", \"Author\", [\n+        (\"pk_field\", models.IntegerField(primary_key=True)),\n+    ])\n+    author_with_m2m = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"publishers\", models.ManyToManyField(\"testapp.Publisher\")),\n+    ])\n+    author_with_m2m_blank = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"publishers\", models.ManyToManyField(\"testapp.Publisher\", blank=True)),\n+    ])\n+    author_with_m2m_through = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"publishers\", models.ManyToManyField(\"testapp.Publisher\", through=\"testapp.Contract\")),\n+    ])\n+    author_with_renamed_m2m_through = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"publishers\", models.ManyToManyField(\"testapp.Publisher\", through=\"testapp.Deal\")),\n+    ])\n+    author_with_former_m2m = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"publishers\", models.CharField(max_length=100)),\n+    ])\n+    author_with_options = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+    ], {\n+        \"permissions\": [('can_hire', 'Can hire')],\n+        \"verbose_name\": \"Authi\",\n+    })\n+    author_with_db_table_options = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+    ], {\"db_table\": \"author_one\"})\n+    author_with_new_db_table_options = ModelState(\"testapp\", \"Author\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+    ], {\"db_table\": \"author_two\"})\n+    author_renamed_with_db_table_options = ModelState(\"testapp\", \"NewAuthor\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+    ], {\"db_table\": \"author_one\"})\n+    author_renamed_with_new_db_table_options = ModelState(\"testapp\", \"NewAuthor\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+    ], {\"db_table\": \"author_three\"})\n+    contract = ModelState(\"testapp\", \"Contract\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"publisher\", models.ForeignKey(\"testapp.Publisher\", models.CASCADE)),\n+    ])\n+    contract_renamed = ModelState(\"testapp\", \"Deal\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"publisher\", models.ForeignKey(\"testapp.Publisher\", models.CASCADE)),\n+    ])\n+    publisher = ModelState(\"testapp\", \"Publisher\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"name\", models.CharField(max_length=100)),\n+    ])\n+    publisher_with_author = ModelState(\"testapp\", \"Publisher\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"name\", models.CharField(max_length=100)),\n+    ])\n+    publisher_with_aardvark_author = ModelState(\"testapp\", \"Publisher\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Aardvark\", models.CASCADE)),\n+        (\"name\", models.CharField(max_length=100)),\n+    ])\n+    publisher_with_book = ModelState(\"testapp\", \"Publisher\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"otherapp.Book\", models.CASCADE)),\n+        (\"name\", models.CharField(max_length=100)),\n+    ])\n+    other_pony = ModelState(\"otherapp\", \"Pony\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+    ])\n+    other_pony_food = ModelState(\"otherapp\", \"Pony\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+    ], managers=[\n+        ('food_qs', FoodQuerySet.as_manager()),\n+        ('food_mgr', FoodManager('a', 'b')),\n+        ('food_mgr_kwargs', FoodManager('x', 'y', 3, 4)),\n+    ])\n+    other_stable = ModelState(\"otherapp\", \"Stable\", [(\"id\", models.AutoField(primary_key=True))])\n+    third_thing = ModelState(\"thirdapp\", \"Thing\", [(\"id\", models.AutoField(primary_key=True))])\n+    book = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ])\n+    book_proxy_fk = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"thirdapp.AuthorProxy\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ])\n+    book_proxy_proxy_fk = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.AAuthorProxyProxy\", models.CASCADE)),\n+    ])\n+    book_migrations_fk = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"migrations.UnmigratedModel\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ])\n+    book_with_no_author_fk = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.IntegerField()),\n+        (\"title\", models.CharField(max_length=200)),\n+    ])\n+    book_with_no_author = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ])\n+    book_with_author_renamed = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Writer\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ])\n+    book_with_field_and_author_renamed = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"writer\", models.ForeignKey(\"testapp.Writer\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ])\n+    book_with_multiple_authors = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"authors\", models.ManyToManyField(\"testapp.Author\")),\n+        (\"title\", models.CharField(max_length=200)),\n+    ])\n+    book_with_multiple_authors_through_attribution = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"authors\", models.ManyToManyField(\"testapp.Author\", through=\"otherapp.Attribution\")),\n+        (\"title\", models.CharField(max_length=200)),\n+    ])\n+    book_indexes = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ], {\n+        \"indexes\": [models.Index(fields=[\"author\", \"title\"], name=\"book_title_author_idx\")],\n+    })\n+    book_unordered_indexes = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ], {\n+        \"indexes\": [models.Index(fields=[\"title\", \"author\"], name=\"book_author_title_idx\")],\n+    })\n+    book_foo_together = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ], {\n+        \"index_together\": {(\"author\", \"title\")},\n+        \"unique_together\": {(\"author\", \"title\")},\n+    })\n+    book_foo_together_2 = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ], {\n+        \"index_together\": {(\"title\", \"author\")},\n+        \"unique_together\": {(\"title\", \"author\")},\n+    })\n+    book_foo_together_3 = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"newfield\", models.IntegerField()),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ], {\n+        \"index_together\": {(\"title\", \"newfield\")},\n+        \"unique_together\": {(\"title\", \"newfield\")},\n+    })\n+    book_foo_together_4 = ModelState(\"otherapp\", \"Book\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"newfield2\", models.IntegerField()),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"title\", models.CharField(max_length=200)),\n+    ], {\n+        \"index_together\": {(\"title\", \"newfield2\")},\n+        \"unique_together\": {(\"title\", \"newfield2\")},\n+    })\n+    attribution = ModelState(\"otherapp\", \"Attribution\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"author\", models.ForeignKey(\"testapp.Author\", models.CASCADE)),\n+        (\"book\", models.ForeignKey(\"otherapp.Book\", models.CASCADE)),\n+    ])\n+    edition = ModelState(\"thirdapp\", \"Edition\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"book\", models.ForeignKey(\"otherapp.Book\", models.CASCADE)),\n+    ])\n+    custom_user = ModelState(\"thirdapp\", \"CustomUser\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"username\", models.CharField(max_length=255)),\n+    ], bases=(AbstractBaseUser,))\n+    custom_user_no_inherit = ModelState(\"thirdapp\", \"CustomUser\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"username\", models.CharField(max_length=255)),\n+    ])\n+    aardvark = ModelState(\"thirdapp\", \"Aardvark\", [(\"id\", models.AutoField(primary_key=True))])\n+    aardvark_testapp = ModelState(\"testapp\", \"Aardvark\", [(\"id\", models.AutoField(primary_key=True))])\n+    aardvark_based_on_author = ModelState(\"testapp\", \"Aardvark\", [], bases=(\"testapp.Author\",))\n+    aardvark_pk_fk_author = ModelState(\"testapp\", \"Aardvark\", [\n+        (\"id\", models.OneToOneField(\"testapp.Author\", models.CASCADE, primary_key=True)),\n+    ])\n+    knight = ModelState(\"eggs\", \"Knight\", [(\"id\", models.AutoField(primary_key=True))])\n+    rabbit = ModelState(\"eggs\", \"Rabbit\", [\n+        (\"id\", models.AutoField(primary_key=True)),\n+        (\"knight\", models.ForeignKey(\"eggs.Knight\", models.CASCADE)),\n+        (\"parent\", models.ForeignKey(\"eggs.Rabbit\", models.CASCADE)),\n+    ], {\n+        \"unique_together\": {(\"parent\", \"knight\")},\n+        \"indexes\": [models.Index(fields=[\"parent\", \"knight\"], name='rabbit_circular_fk_index')],\n+    })\n+\n+    def repr_changes(self, changes, include_dependencies=False):\n+        output = \"\"\n+        for app_label, migrations in sorted(changes.items()):\n+            output += \"  %s:\\n\" % app_label\n+            for migration in migrations:\n+                output += \"    %s\\n\" % migration.name\n+                for operation in migration.operations:\n+                    output += \"      %s\\n\" % operation\n+                if include_dependencies:\n+                    output += \"      Dependencies:\\n\"\n+                    if migration.dependencies:\n+                        for dep in migration.dependencies:\n+                            output += \"        %s\\n\" % (dep,)\n+                    else:\n+                        output += \"        None\\n\"\n+        return output\n+\n+    def assertNumberMigrations(self, changes, app_label, number):\n+        if len(changes.get(app_label, [])) != number:\n+            self.fail(\"Incorrect number of migrations (%s) for %s (expected %s)\\n%s\" % (\n+                len(changes.get(app_label, [])),\n+                app_label,\n+                number,\n+                self.repr_changes(changes),\n+            ))\n+\n+    def assertMigrationDependencies(self, changes, app_label, position, dependencies):\n+        if not changes.get(app_label):\n+            self.fail(\"No migrations found for %s\\n%s\" % (app_label, self.repr_changes(changes)))\n+        if len(changes[app_label]) < position + 1:\n+            self.fail(\"No migration at index %s for %s\\n%s\" % (position, app_label, self.repr_changes(changes)))\n+        migration = changes[app_label][position]\n+        if set(migration.dependencies) != set(dependencies):\n+            self.fail(\"Migration dependencies mismatch for %s.%s (expected %s):\\n%s\" % (\n+                app_label,\n+                migration.name,\n+                dependencies,\n+                self.repr_changes(changes, include_dependencies=True),\n+            ))\n+\n+    def assertOperationTypes(self, changes, app_label, position, types):\n+        if not changes.get(app_label):\n+            self.fail(\"No migrations found for %s\\n%s\" % (app_label, self.repr_changes(changes)))\n+        if len(changes[app_label]) < position + 1:\n+            self.fail(\"No migration at index %s for %s\\n%s\" % (position, app_label, self.repr_changes(changes)))\n+        migration = changes[app_label][position]\n+        real_types = [operation.__class__.__name__ for operation in migration.operations]\n+        if types != real_types:\n+            self.fail(\"Operation type mismatch for %s.%s (expected %s):\\n%s\" % (\n+                app_label,\n+                migration.name,\n+                types,\n+                self.repr_changes(changes),\n+            ))\n+\n+    def assertOperationAttributes(self, changes, app_label, position, operation_position, **attrs):\n+        if not changes.get(app_label):\n+            self.fail(\"No migrations found for %s\\n%s\" % (app_label, self.repr_changes(changes)))\n+        if len(changes[app_label]) < position + 1:\n+            self.fail(\"No migration at index %s for %s\\n%s\" % (position, app_label, self.repr_changes(changes)))\n+        migration = changes[app_label][position]\n+        if len(changes[app_label]) < position + 1:\n+            self.fail(\"No operation at index %s for %s.%s\\n%s\" % (\n+                operation_position,\n+                app_label,\n+                migration.name,\n+                self.repr_changes(changes),\n+            ))\n+        operation = migration.operations[operation_position]\n+        for attr, value in attrs.items():\n+            if getattr(operation, attr, None) != value:\n+                self.fail(\"Attribute mismatch for %s.%s op #%s, %s (expected %r, got %r):\\n%s\" % (\n+                    app_label,\n+                    migration.name,\n+                    operation_position,\n+                    attr,\n+                    value,\n+                    getattr(operation, attr, None),\n+                    self.repr_changes(changes),\n+                ))\n+\n+    def assertOperationFieldAttributes(self, changes, app_label, position, operation_position, **attrs):\n+        if not changes.get(app_label):\n+            self.fail(\"No migrations found for %s\\n%s\" % (app_label, self.repr_changes(changes)))\n+        if len(changes[app_label]) < position + 1:\n+            self.fail(\"No migration at index %s for %s\\n%s\" % (position, app_label, self.repr_changes(changes)))\n+        migration = changes[app_label][position]\n+        if len(changes[app_label]) < position + 1:\n+            self.fail(\"No operation at index %s for %s.%s\\n%s\" % (\n+                operation_position,\n+                app_label,\n+                migration.name,\n+                self.repr_changes(changes),\n+            ))\n+        operation = migration.operations[operation_position]\n+        if not hasattr(operation, 'field'):\n+            self.fail(\"No field attribute for %s.%s op #%s.\" % (\n+                app_label,\n+                migration.name,\n+                operation_position,\n+            ))\n+        field = operation.field\n+        for attr, value in attrs.items():\n+            if getattr(field, attr, None) != value:\n+                self.fail(\"Field attribute mismatch for %s.%s op #%s, field.%s (expected %r, got %r):\\n%s\" % (\n+                    app_label,\n+                    migration.name,\n+                    operation_position,\n+                    attr,\n+                    value,\n+                    getattr(field, attr, None),\n+                    self.repr_changes(changes),\n+                ))\n+\n+    def make_project_state(self, model_states):\n+        \"Shortcut to make ProjectStates from lists of predefined models\"\n+        project_state = ProjectState()\n+        for model_state in model_states:\n+            project_state.add_model(model_state.clone())\n+        return project_state\n+\n+    def get_changes(self, before_states, after_states, questioner=None):\n+        return MigrationAutodetector(\n+            self.make_project_state(before_states),\n+            self.make_project_state(after_states),\n+            questioner,\n+        )._detect_changes()\n+\n+    def test_arrange_for_graph(self):\n+        \"\"\"Tests auto-naming of migrations for graph matching.\"\"\"\n+        # Make a fake graph\n+        graph = MigrationGraph()\n+        graph.add_node((\"testapp\", \"0001_initial\"), None)\n+        graph.add_node((\"testapp\", \"0002_foobar\"), None)\n+        graph.add_node((\"otherapp\", \"0001_initial\"), None)\n+        graph.add_dependency(\"testapp.0002_foobar\", (\"testapp\", \"0002_foobar\"), (\"testapp\", \"0001_initial\"))\n+        graph.add_dependency(\"testapp.0002_foobar\", (\"testapp\", \"0002_foobar\"), (\"otherapp\", \"0001_initial\"))\n+        # Use project state to make a new migration change set\n+        before = self.make_project_state([])\n+        after = self.make_project_state([self.author_empty, self.other_pony, self.other_stable])\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+        # Run through arrange_for_graph\n+        changes = autodetector.arrange_for_graph(changes, graph)\n+        # Make sure there's a new name, deps match, etc.\n+        self.assertEqual(changes[\"testapp\"][0].name, \"0003_author\")\n+        self.assertEqual(changes[\"testapp\"][0].dependencies, [(\"testapp\", \"0002_foobar\")])\n+        self.assertEqual(changes[\"otherapp\"][0].name, \"0002_pony_stable\")\n+        self.assertEqual(changes[\"otherapp\"][0].dependencies, [(\"otherapp\", \"0001_initial\")])\n+\n+    def test_trim_apps(self):\n+        \"\"\"\n+        Trim does not remove dependencies but does remove unwanted apps.\n+        \"\"\"\n+        # Use project state to make a new migration change set\n+        before = self.make_project_state([])\n+        after = self.make_project_state([self.author_empty, self.other_pony, self.other_stable, self.third_thing])\n+        autodetector = MigrationAutodetector(before, after, MigrationQuestioner({\"ask_initial\": True}))\n+        changes = autodetector._detect_changes()\n+        # Run through arrange_for_graph\n+        graph = MigrationGraph()\n+        changes = autodetector.arrange_for_graph(changes, graph)\n+        changes[\"testapp\"][0].dependencies.append((\"otherapp\", \"0001_initial\"))\n+        changes = autodetector._trim_to_apps(changes, {\"testapp\"})\n+        # Make sure there's the right set of migrations\n+        self.assertEqual(changes[\"testapp\"][0].name, \"0001_initial\")\n+        self.assertEqual(changes[\"otherapp\"][0].name, \"0001_initial\")\n+        self.assertNotIn(\"thirdapp\", changes)\n+\n+    def test_custom_migration_name(self):\n+        \"\"\"Tests custom naming of migrations for graph matching.\"\"\"\n+        # Make a fake graph\n+        graph = MigrationGraph()\n+        graph.add_node((\"testapp\", \"0001_initial\"), None)\n+        graph.add_node((\"testapp\", \"0002_foobar\"), None)\n+        graph.add_node((\"otherapp\", \"0001_initial\"), None)\n+        graph.add_dependency(\"testapp.0002_foobar\", (\"testapp\", \"0002_foobar\"), (\"testapp\", \"0001_initial\"))\n+\n+        # Use project state to make a new migration change set\n+        before = self.make_project_state([])\n+        after = self.make_project_state([self.author_empty, self.other_pony, self.other_stable])\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes()\n+\n+        # Run through arrange_for_graph\n+        migration_name = 'custom_name'\n+        changes = autodetector.arrange_for_graph(changes, graph, migration_name)\n+\n+        # Make sure there's a new name, deps match, etc.\n+        self.assertEqual(changes[\"testapp\"][0].name, \"0003_%s\" % migration_name)\n+        self.assertEqual(changes[\"testapp\"][0].dependencies, [(\"testapp\", \"0002_foobar\")])\n+        self.assertEqual(changes[\"otherapp\"][0].name, \"0002_%s\" % migration_name)\n+        self.assertEqual(changes[\"otherapp\"][0].dependencies, [(\"otherapp\", \"0001_initial\")])\n+\n+    def test_new_model(self):\n+        \"\"\"Tests autodetection of new models.\"\"\"\n+        changes = self.get_changes([], [self.other_pony_food])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 0, name=\"Pony\")\n+        self.assertEqual([name for name, mgr in changes['otherapp'][0].operations[0].managers],\n+                         ['food_qs', 'food_mgr', 'food_mgr_kwargs'])\n+\n+    def test_old_model(self):\n+        \"\"\"Tests deletion of old models.\"\"\"\n+        changes = self.get_changes([self.author_empty], [])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"DeleteModel\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"Author\")\n+\n+    def test_add_field(self):\n+        \"\"\"Tests autodetection of new fields.\"\"\"\n+        changes = self.get_changes([self.author_empty], [self.author_name])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"name\")\n+\n+    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition',\n+                side_effect=AssertionError(\"Should not have prompted for not null addition\"))\n+    def test_add_date_fields_with_auto_now_not_asking_for_default(self, mocked_ask_method):\n+        changes = self.get_changes([self.author_empty], [self.author_dates_of_birth_auto_now])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\", \"AddField\", \"AddField\"])\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 0, auto_now=True)\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 1, auto_now=True)\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 2, auto_now=True)\n+\n+    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition',\n+                side_effect=AssertionError(\"Should not have prompted for not null addition\"))\n+    def test_add_date_fields_with_auto_now_add_not_asking_for_null_addition(self, mocked_ask_method):\n+        changes = self.get_changes([self.author_empty], [self.author_dates_of_birth_auto_now_add])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\", \"AddField\", \"AddField\"])\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 0, auto_now_add=True)\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 1, auto_now_add=True)\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 2, auto_now_add=True)\n+\n+    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_auto_now_add_addition')\n+    def test_add_date_fields_with_auto_now_add_asking_for_default(self, mocked_ask_method):\n+        changes = self.get_changes([self.author_empty], [self.author_dates_of_birth_auto_now_add])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\", \"AddField\", \"AddField\"])\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 0, auto_now_add=True)\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 1, auto_now_add=True)\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 2, auto_now_add=True)\n+        self.assertEqual(mocked_ask_method.call_count, 3)\n+\n+    def test_remove_field(self):\n+        \"\"\"Tests autodetection of removed fields.\"\"\"\n+        changes = self.get_changes([self.author_name], [self.author_empty])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"RemoveField\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"name\")\n+\n+    def test_alter_field(self):\n+        \"\"\"Tests autodetection of new fields.\"\"\"\n+        changes = self.get_changes([self.author_name], [self.author_name_longer])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterField\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"name\", preserve_default=True)\n+\n+    def test_supports_functools_partial(self):\n+        def _content_file_name(instance, filename, key, **kwargs):\n+            return '{}/{}'.format(instance, filename)\n+\n+        def content_file_name(key, **kwargs):\n+            return functools.partial(_content_file_name, key, **kwargs)\n+\n+        # An unchanged partial reference.\n+        before = [ModelState(\"testapp\", \"Author\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"file\", models.FileField(max_length=200, upload_to=content_file_name('file'))),\n+        ])]\n+        after = [ModelState(\"testapp\", \"Author\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"file\", models.FileField(max_length=200, upload_to=content_file_name('file'))),\n+        ])]\n+        changes = self.get_changes(before, after)\n+        self.assertNumberMigrations(changes, 'testapp', 0)\n+\n+        # A changed partial reference.\n+        args_changed = [ModelState(\"testapp\", \"Author\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"file\", models.FileField(max_length=200, upload_to=content_file_name('other-file'))),\n+        ])]\n+        changes = self.get_changes(before, args_changed)\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, ['AlterField'])\n+        # Can't use assertOperationFieldAttributes because we need the\n+        # deconstructed version, i.e., the exploded func/args/keywords rather\n+        # than the partial: we don't care if it's not the same instance of the\n+        # partial, only if it's the same source function, args, and keywords.\n+        value = changes['testapp'][0].operations[0].field.upload_to\n+        self.assertEqual(\n+            (_content_file_name, ('other-file',), {}),\n+            (value.func, value.args, value.keywords)\n+        )\n+\n+        kwargs_changed = [ModelState(\"testapp\", \"Author\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"file\", models.FileField(max_length=200, upload_to=content_file_name('file', spam='eggs'))),\n+        ])]\n+        changes = self.get_changes(before, kwargs_changed)\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, ['AlterField'])\n+        value = changes['testapp'][0].operations[0].field.upload_to\n+        self.assertEqual(\n+            (_content_file_name, ('file',), {'spam': 'eggs'}),\n+            (value.func, value.args, value.keywords)\n+        )\n+\n+    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration',\n+                side_effect=AssertionError(\"Should not have prompted for not null addition\"))\n+    def test_alter_field_to_not_null_with_default(self, mocked_ask_method):\n+        \"\"\"\n+        #23609 - Tests autodetection of nullable to non-nullable alterations.\n+        \"\"\"\n+        changes = self.get_changes([self.author_name_null], [self.author_name_default])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterField\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"name\", preserve_default=True)\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 0, default='Ada Lovelace')\n+\n+    @mock.patch(\n+        'django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration',\n+        return_value=models.NOT_PROVIDED,\n+    )\n+    def test_alter_field_to_not_null_without_default(self, mocked_ask_method):\n+        \"\"\"\n+        #23609 - Tests autodetection of nullable to non-nullable alterations.\n+        \"\"\"\n+        changes = self.get_changes([self.author_name_null], [self.author_name])\n+        self.assertEqual(mocked_ask_method.call_count, 1)\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterField\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"name\", preserve_default=True)\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 0, default=models.NOT_PROVIDED)\n+\n+    @mock.patch(\n+        'django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration',\n+        return_value='Some Name',\n+    )\n+    def test_alter_field_to_not_null_oneoff_default(self, mocked_ask_method):\n+        \"\"\"\n+        #23609 - Tests autodetection of nullable to non-nullable alterations.\n+        \"\"\"\n+        changes = self.get_changes([self.author_name_null], [self.author_name])\n+        self.assertEqual(mocked_ask_method.call_count, 1)\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterField\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"name\", preserve_default=False)\n+        self.assertOperationFieldAttributes(changes, \"testapp\", 0, 0, default=\"Some Name\")\n+\n+    def test_rename_field(self):\n+        \"\"\"Tests autodetection of renamed fields.\"\"\"\n+        changes = self.get_changes(\n+            [self.author_name], [self.author_name_renamed], MigrationQuestioner({\"ask_rename\": True})\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"RenameField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name=\"name\", new_name=\"names\")\n+\n+    def test_rename_field_foreign_key_to_field(self):\n+        before = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('field', models.IntegerField(unique=True)),\n+            ]),\n+            ModelState('app', 'Bar', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('foo', models.ForeignKey('app.Foo', models.CASCADE, to_field='field')),\n+            ]),\n+        ]\n+        after = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('renamed_field', models.IntegerField(unique=True)),\n+            ]),\n+            ModelState('app', 'Bar', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('foo', models.ForeignKey('app.Foo', models.CASCADE, to_field='renamed_field')),\n+            ]),\n+        ]\n+        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['RenameField'])\n+        self.assertOperationAttributes(changes, 'app', 0, 0, old_name='field', new_name='renamed_field')\n+\n+    def test_rename_foreign_object_fields(self):\n+        fields = ('first', 'second')\n+        renamed_fields = ('first_renamed', 'second_renamed')\n+        before = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('first', models.IntegerField()),\n+                ('second', models.IntegerField()),\n+            ], options={'unique_together': {fields}}),\n+            ModelState('app', 'Bar', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('first', models.IntegerField()),\n+                ('second', models.IntegerField()),\n+                ('foo', models.ForeignObject(\n+                    'app.Foo', models.CASCADE, from_fields=fields, to_fields=fields,\n+                )),\n+            ]),\n+        ]\n+        # Case 1: to_fields renames.\n+        after = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('first_renamed', models.IntegerField()),\n+                ('second_renamed', models.IntegerField()),\n+            ], options={'unique_together': {renamed_fields}}),\n+            ModelState('app', 'Bar', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('first', models.IntegerField()),\n+                ('second', models.IntegerField()),\n+                ('foo', models.ForeignObject(\n+                    'app.Foo', models.CASCADE, from_fields=fields, to_fields=renamed_fields,\n+                )),\n+            ]),\n+        ]\n+        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['RenameField', 'RenameField', 'AlterUniqueTogether'])\n+        self.assertOperationAttributes(\n+            changes, 'app', 0, 0, model_name='foo', old_name='first', new_name='first_renamed',\n+        )\n+        self.assertOperationAttributes(\n+            changes, 'app', 0, 1, model_name='foo', old_name='second', new_name='second_renamed',\n+        )\n+        # Case 2: from_fields renames.\n+        after = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('first', models.IntegerField()),\n+                ('second', models.IntegerField()),\n+            ], options={'unique_together': {fields}}),\n+            ModelState('app', 'Bar', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('first_renamed', models.IntegerField()),\n+                ('second_renamed', models.IntegerField()),\n+                ('foo', models.ForeignObject(\n+                    'app.Foo', models.CASCADE, from_fields=renamed_fields, to_fields=fields,\n+                )),\n+            ]),\n+        ]\n+        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['RenameField', 'RenameField'])\n+        self.assertOperationAttributes(\n+            changes, 'app', 0, 0, model_name='bar', old_name='first', new_name='first_renamed',\n+        )\n+        self.assertOperationAttributes(\n+            changes, 'app', 0, 1, model_name='bar', old_name='second', new_name='second_renamed',\n+        )\n+\n+    def test_rename_referenced_primary_key(self):\n+        before = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.CharField(primary_key=True, serialize=False)),\n+            ]),\n+            ModelState('app', 'Bar', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('foo', models.ForeignKey('app.Foo', models.CASCADE)),\n+            ]),\n+        ]\n+        after = [\n+            ModelState('app', 'Foo', [\n+                ('renamed_id', models.CharField(primary_key=True, serialize=False))\n+            ]),\n+            ModelState('app', 'Bar', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('foo', models.ForeignKey('app.Foo', models.CASCADE)),\n+            ]),\n+        ]\n+        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['RenameField'])\n+        self.assertOperationAttributes(changes, 'app', 0, 0, old_name='id', new_name='renamed_id')\n+\n+    def test_rename_field_preserved_db_column(self):\n+        \"\"\"\n+        RenameField is used if a field is renamed and db_column equal to the\n+        old field's column is added.\n+        \"\"\"\n+        before = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('field', models.IntegerField()),\n+            ]),\n+        ]\n+        after = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('renamed_field', models.IntegerField(db_column='field')),\n+            ]),\n+        ]\n+        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['RenameField', 'AlterField'])\n+        self.assertOperationAttributes(\n+            changes, 'app', 0, 0, model_name='foo', old_name='field', new_name='renamed_field',\n+        )\n+        self.assertOperationAttributes(changes, 'app', 0, 1, model_name='foo', name='renamed_field')\n+        self.assertEqual(changes['app'][0].operations[-1].field.deconstruct(), (\n+            'renamed_field', 'django.db.models.IntegerField', [], {'db_column': 'field'},\n+        ))\n+\n+    def test_rename_related_field_preserved_db_column(self):\n+        before = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.AutoField(primary_key=True)),\n+            ]),\n+            ModelState('app', 'Bar', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('foo', models.ForeignKey('app.Foo', models.CASCADE)),\n+            ]),\n+        ]\n+        after = [\n+            ModelState('app', 'Foo', [\n+                ('id', models.AutoField(primary_key=True)),\n+            ]),\n+            ModelState('app', 'Bar', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('renamed_foo', models.ForeignKey('app.Foo', models.CASCADE, db_column='foo_id')),\n+            ]),\n+        ]\n+        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['RenameField', 'AlterField'])\n+        self.assertOperationAttributes(\n+            changes, 'app', 0, 0, model_name='bar', old_name='foo', new_name='renamed_foo',\n+        )\n+        self.assertOperationAttributes(changes, 'app', 0, 1, model_name='bar', name='renamed_foo')\n+        self.assertEqual(changes['app'][0].operations[-1].field.deconstruct(), (\n+            'renamed_foo',\n+            'django.db.models.ForeignKey',\n+            [],\n+            {'to': 'app.foo', 'on_delete': models.CASCADE, 'db_column': 'foo_id'},\n+        ))\n+\n+    def test_rename_model(self):\n+        \"\"\"Tests autodetection of renamed models.\"\"\"\n+        changes = self.get_changes(\n+            [self.author_with_book, self.book],\n+            [self.author_renamed_with_book, self.book_with_author_renamed],\n+            MigrationQuestioner({\"ask_rename_model\": True}),\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"RenameModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name=\"Author\", new_name=\"Writer\")\n+        # Now that RenameModel handles related fields too, there should be\n+        # no AlterField for the related field.\n+        self.assertNumberMigrations(changes, 'otherapp', 0)\n+\n+    def test_rename_model_case(self):\n+        \"\"\"\n+        Model name is case-insensitive. Changing case doesn't lead to any\n+        autodetected operations.\n+        \"\"\"\n+        author_renamed = ModelState('testapp', 'author', [\n+            ('id', models.AutoField(primary_key=True)),\n+        ])\n+        changes = self.get_changes(\n+            [self.author_empty, self.book],\n+            [author_renamed, self.book],\n+            questioner=MigrationQuestioner({'ask_rename_model': True}),\n+        )\n+        self.assertNumberMigrations(changes, 'testapp', 0)\n+        self.assertNumberMigrations(changes, 'otherapp', 0)\n+\n+    def test_rename_m2m_through_model(self):\n+        \"\"\"\n+        Tests autodetection of renamed models that are used in M2M relations as\n+        through models.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_with_m2m_through, self.publisher, self.contract],\n+            [self.author_with_renamed_m2m_through, self.publisher, self.contract_renamed],\n+            MigrationQuestioner({'ask_rename_model': True})\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, ['RenameModel'])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name='Contract', new_name='Deal')\n+\n+    def test_rename_model_with_renamed_rel_field(self):\n+        \"\"\"\n+        Tests autodetection of renamed models while simultaneously renaming one\n+        of the fields that relate to the renamed model.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_with_book, self.book],\n+            [self.author_renamed_with_book, self.book_with_field_and_author_renamed],\n+            MigrationQuestioner({\"ask_rename\": True, \"ask_rename_model\": True}),\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"RenameModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name=\"Author\", new_name=\"Writer\")\n+        # Right number/type of migrations for related field rename?\n+        # Alter is already taken care of.\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\"RenameField\"])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, old_name=\"author\", new_name=\"writer\")\n+\n+    def test_rename_model_with_fks_in_different_position(self):\n+        \"\"\"\n+        #24537 - The order of fields in a model does not influence\n+        the RenameModel detection.\n+        \"\"\"\n+        before = [\n+            ModelState(\"testapp\", \"EntityA\", [\n+                (\"id\", models.AutoField(primary_key=True)),\n+            ]),\n+            ModelState(\"testapp\", \"EntityB\", [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"some_label\", models.CharField(max_length=255)),\n+                (\"entity_a\", models.ForeignKey(\"testapp.EntityA\", models.CASCADE)),\n+            ]),\n+        ]\n+        after = [\n+            ModelState(\"testapp\", \"EntityA\", [\n+                (\"id\", models.AutoField(primary_key=True)),\n+            ]),\n+            ModelState(\"testapp\", \"RenamedEntityB\", [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"entity_a\", models.ForeignKey(\"testapp.EntityA\", models.CASCADE)),\n+                (\"some_label\", models.CharField(max_length=255)),\n+            ]),\n+        ]\n+        changes = self.get_changes(before, after, MigrationQuestioner({\"ask_rename_model\": True}))\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"RenameModel\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, old_name=\"EntityB\", new_name=\"RenamedEntityB\")\n+\n+    def test_rename_model_reverse_relation_dependencies(self):\n+        \"\"\"\n+        The migration to rename a model pointed to by a foreign key in another\n+        app must run after the other app's migration that adds the foreign key\n+        with model's original name. Therefore, the renaming migration has a\n+        dependency on that other migration.\n+        \"\"\"\n+        before = [\n+            ModelState('testapp', 'EntityA', [\n+                ('id', models.AutoField(primary_key=True)),\n+            ]),\n+            ModelState('otherapp', 'EntityB', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('entity_a', models.ForeignKey('testapp.EntityA', models.CASCADE)),\n+            ]),\n+        ]\n+        after = [\n+            ModelState('testapp', 'RenamedEntityA', [\n+                ('id', models.AutoField(primary_key=True)),\n+            ]),\n+            ModelState('otherapp', 'EntityB', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('entity_a', models.ForeignKey('testapp.RenamedEntityA', models.CASCADE)),\n+            ]),\n+        ]\n+        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename_model': True}))\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertMigrationDependencies(changes, 'testapp', 0, [('otherapp', '__first__')])\n+        self.assertOperationTypes(changes, 'testapp', 0, ['RenameModel'])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name='EntityA', new_name='RenamedEntityA')\n+\n+    def test_fk_dependency(self):\n+        \"\"\"Having a ForeignKey automatically adds a dependency.\"\"\"\n+        # Note that testapp (author) has no dependencies,\n+        # otherapp (book) depends on testapp (author),\n+        # thirdapp (edition) depends on otherapp (book)\n+        changes = self.get_changes([], [self.author_name, self.book, self.edition])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"Author\")\n+        self.assertMigrationDependencies(changes, 'testapp', 0, [])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name=\"Book\")\n+        self.assertMigrationDependencies(changes, 'otherapp', 0, [(\"testapp\", \"auto_1\")])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'thirdapp', 1)\n+        self.assertOperationTypes(changes, 'thirdapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'thirdapp', 0, 0, name=\"Edition\")\n+        self.assertMigrationDependencies(changes, 'thirdapp', 0, [(\"otherapp\", \"auto_1\")])\n+\n+    def test_proxy_fk_dependency(self):\n+        \"\"\"FK dependencies still work on proxy models.\"\"\"\n+        # Note that testapp (author) has no dependencies,\n+        # otherapp (book) depends on testapp (authorproxy)\n+        changes = self.get_changes([], [self.author_empty, self.author_proxy_third, self.book_proxy_fk])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"Author\")\n+        self.assertMigrationDependencies(changes, 'testapp', 0, [])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name=\"Book\")\n+        self.assertMigrationDependencies(changes, 'otherapp', 0, [(\"thirdapp\", \"auto_1\")])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'thirdapp', 1)\n+        self.assertOperationTypes(changes, 'thirdapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'thirdapp', 0, 0, name=\"AuthorProxy\")\n+        self.assertMigrationDependencies(changes, 'thirdapp', 0, [(\"testapp\", \"auto_1\")])\n+\n+    def test_same_app_no_fk_dependency(self):\n+        \"\"\"\n+        A migration with a FK between two models of the same app\n+        does not have a dependency to itself.\n+        \"\"\"\n+        changes = self.get_changes([], [self.author_with_publisher, self.publisher])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\", \"CreateModel\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"Publisher\")\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 1, name=\"Author\")\n+        self.assertMigrationDependencies(changes, 'testapp', 0, [])\n+\n+    def test_circular_fk_dependency(self):\n+        \"\"\"\n+        Having a circular ForeignKey dependency automatically\n+        resolves the situation into 2 migrations on one side and 1 on the other.\n+        \"\"\"\n+        changes = self.get_changes([], [self.author_with_book, self.book, self.publisher_with_book])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\", \"CreateModel\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"Publisher\")\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 1, name=\"Author\")\n+        self.assertMigrationDependencies(changes, 'testapp', 0, [(\"otherapp\", \"auto_1\")])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'otherapp', 2)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\"CreateModel\"])\n+        self.assertOperationTypes(changes, 'otherapp', 1, [\"AddField\"])\n+        self.assertMigrationDependencies(changes, 'otherapp', 0, [])\n+        self.assertMigrationDependencies(changes, 'otherapp', 1, [(\"otherapp\", \"auto_1\"), (\"testapp\", \"auto_1\")])\n+        # both split migrations should be `initial`\n+        self.assertTrue(changes['otherapp'][0].initial)\n+        self.assertTrue(changes['otherapp'][1].initial)\n+\n+    def test_same_app_circular_fk_dependency(self):\n+        \"\"\"\n+        A migration with a FK between two models of the same app does\n+        not have a dependency to itself.\n+        \"\"\"\n+        changes = self.get_changes([], [self.author_with_publisher, self.publisher_with_author])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\", \"CreateModel\", \"AddField\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"Author\")\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 1, name=\"Publisher\")\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 2, name=\"publisher\")\n+        self.assertMigrationDependencies(changes, 'testapp', 0, [])\n+\n+    def test_same_app_circular_fk_dependency_with_unique_together_and_indexes(self):\n+        \"\"\"\n+        #22275 - A migration with circular FK dependency does not try\n+        to create unique together constraint and indexes before creating all\n+        required fields first.\n+        \"\"\"\n+        changes = self.get_changes([], [self.knight, self.rabbit])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'eggs', 1)\n+        self.assertOperationTypes(\n+            changes, 'eggs', 0, [\"CreateModel\", \"CreateModel\", \"AddIndex\", \"AlterUniqueTogether\"]\n+        )\n+        self.assertNotIn(\"unique_together\", changes['eggs'][0].operations[0].options)\n+        self.assertNotIn(\"unique_together\", changes['eggs'][0].operations[1].options)\n+        self.assertMigrationDependencies(changes, 'eggs', 0, [])\n+\n+    def test_alter_db_table_add(self):\n+        \"\"\"Tests detection for adding db_table in model's options.\"\"\"\n+        changes = self.get_changes([self.author_empty], [self.author_with_db_table_options])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterModelTable\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"author\", table=\"author_one\")\n+\n+    def test_alter_db_table_change(self):\n+        \"\"\"Tests detection for changing db_table in model's options'.\"\"\"\n+        changes = self.get_changes([self.author_with_db_table_options], [self.author_with_new_db_table_options])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterModelTable\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"author\", table=\"author_two\")\n+\n+    def test_alter_db_table_remove(self):\n+        \"\"\"Tests detection for removing db_table in model's options.\"\"\"\n+        changes = self.get_changes([self.author_with_db_table_options], [self.author_empty])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterModelTable\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"author\", table=None)\n+\n+    def test_alter_db_table_no_changes(self):\n+        \"\"\"\n+        Alter_db_table doesn't generate a migration if no changes have been made.\n+        \"\"\"\n+        changes = self.get_changes([self.author_with_db_table_options], [self.author_with_db_table_options])\n+        # Right number of migrations?\n+        self.assertEqual(len(changes), 0)\n+\n+    def test_keep_db_table_with_model_change(self):\n+        \"\"\"\n+        Tests when model changes but db_table stays as-is, autodetector must not\n+        create more than one operation.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_with_db_table_options],\n+            [self.author_renamed_with_db_table_options],\n+            MigrationQuestioner({\"ask_rename_model\": True}),\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"RenameModel\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, old_name=\"Author\", new_name=\"NewAuthor\")\n+\n+    def test_alter_db_table_with_model_change(self):\n+        \"\"\"\n+        Tests when model and db_table changes, autodetector must create two\n+        operations.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_with_db_table_options],\n+            [self.author_renamed_with_new_db_table_options],\n+            MigrationQuestioner({\"ask_rename_model\": True}),\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"RenameModel\", \"AlterModelTable\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, old_name=\"Author\", new_name=\"NewAuthor\")\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 1, name=\"newauthor\", table=\"author_three\")\n+\n+    def test_identical_regex_doesnt_alter(self):\n+        from_state = ModelState(\n+            \"testapp\", \"model\", [(\"id\", models.AutoField(primary_key=True, validators=[\n+                RegexValidator(\n+                    re.compile('^[-a-zA-Z0-9_]+\\Z'),\n+                    'Enter a valid \u201cslug\u201d consisting of letters, numbers, underscores or hyphens.',\n+                    'invalid'\n+                )\n+            ]))]\n+        )\n+        to_state = ModelState(\n+            \"testapp\", \"model\", [(\"id\", models.AutoField(primary_key=True, validators=[validate_slug]))]\n+        )\n+        changes = self.get_changes([from_state], [to_state])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 0)\n+\n+    def test_different_regex_does_alter(self):\n+        from_state = ModelState(\n+            \"testapp\", \"model\", [(\"id\", models.AutoField(primary_key=True, validators=[\n+                RegexValidator(\n+                    re.compile('^[a-z]+\\Z', 32),\n+                    'Enter a valid \u201cslug\u201d consisting of letters, numbers, underscores or hyphens.',\n+                    'invalid'\n+                )\n+            ]))]\n+        )\n+        to_state = ModelState(\n+            \"testapp\", \"model\", [(\"id\", models.AutoField(primary_key=True, validators=[validate_slug]))]\n+        )\n+        changes = self.get_changes([from_state], [to_state])\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterField\"])\n+\n+    def test_empty_foo_together(self):\n+        \"\"\"\n+        #23452 - Empty unique/index_together shouldn't generate a migration.\n+        \"\"\"\n+        # Explicitly testing for not specified, since this is the case after\n+        # a CreateModel operation w/o any definition on the original model\n+        model_state_not_specified = ModelState(\"a\", \"model\", [(\"id\", models.AutoField(primary_key=True))])\n+        # Explicitly testing for None, since this was the issue in #23452 after\n+        # an AlterFooTogether operation with e.g. () as value\n+        model_state_none = ModelState(\"a\", \"model\", [\n+            (\"id\", models.AutoField(primary_key=True))\n+        ], {\n+            \"index_together\": None,\n+            \"unique_together\": None,\n+        })\n+        # Explicitly testing for the empty set, since we now always have sets.\n+        # During removal (('col1', 'col2'),) --> () this becomes set([])\n+        model_state_empty = ModelState(\"a\", \"model\", [\n+            (\"id\", models.AutoField(primary_key=True))\n+        ], {\n+            \"index_together\": set(),\n+            \"unique_together\": set(),\n+        })\n+\n+        def test(from_state, to_state, msg):\n+            changes = self.get_changes([from_state], [to_state])\n+            if changes:\n+                ops = ', '.join(o.__class__.__name__ for o in changes['a'][0].operations)\n+                self.fail('Created operation(s) %s from %s' % (ops, msg))\n+\n+        tests = (\n+            (model_state_not_specified, model_state_not_specified, '\"not specified\" to \"not specified\"'),\n+            (model_state_not_specified, model_state_none, '\"not specified\" to \"None\"'),\n+            (model_state_not_specified, model_state_empty, '\"not specified\" to \"empty\"'),\n+            (model_state_none, model_state_not_specified, '\"None\" to \"not specified\"'),\n+            (model_state_none, model_state_none, '\"None\" to \"None\"'),\n+            (model_state_none, model_state_empty, '\"None\" to \"empty\"'),\n+            (model_state_empty, model_state_not_specified, '\"empty\" to \"not specified\"'),\n+            (model_state_empty, model_state_none, '\"empty\" to \"None\"'),\n+            (model_state_empty, model_state_empty, '\"empty\" to \"empty\"'),\n+        )\n+\n+        for t in tests:\n+            test(*t)\n+\n+    def test_create_model_with_indexes(self):\n+        \"\"\"Test creation of new model with indexes already defined.\"\"\"\n+        author = ModelState('otherapp', 'Author', [\n+            ('id', models.AutoField(primary_key=True)),\n+            ('name', models.CharField(max_length=200)),\n+        ], {'indexes': [models.Index(fields=['name'], name='create_model_with_indexes_idx')]})\n+        changes = self.get_changes([], [author])\n+        added_index = models.Index(fields=['name'], name='create_model_with_indexes_idx')\n+        # Right number of migrations?\n+        self.assertEqual(len(changes['otherapp']), 1)\n+        # Right number of actions?\n+        migration = changes['otherapp'][0]\n+        self.assertEqual(len(migration.operations), 2)\n+        # Right actions order?\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['CreateModel', 'AddIndex'])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name='Author')\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 1, model_name='author', index=added_index)\n+\n+    def test_add_indexes(self):\n+        \"\"\"Test change detection of new indexes.\"\"\"\n+        changes = self.get_changes([self.author_empty, self.book], [self.author_empty, self.book_indexes])\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['AddIndex'])\n+        added_index = models.Index(fields=['author', 'title'], name='book_title_author_idx')\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, model_name='book', index=added_index)\n+\n+    def test_remove_indexes(self):\n+        \"\"\"Test change detection of removed indexes.\"\"\"\n+        changes = self.get_changes([self.author_empty, self.book_indexes], [self.author_empty, self.book])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['RemoveIndex'])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, model_name='book', name='book_title_author_idx')\n+\n+    def test_order_fields_indexes(self):\n+        \"\"\"Test change detection of reordering of fields in indexes.\"\"\"\n+        changes = self.get_changes(\n+            [self.author_empty, self.book_indexes], [self.author_empty, self.book_unordered_indexes]\n+        )\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['RemoveIndex', 'AddIndex'])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, model_name='book', name='book_title_author_idx')\n+        added_index = models.Index(fields=['title', 'author'], name='book_author_title_idx')\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 1, model_name='book', index=added_index)\n+\n+    def test_create_model_with_check_constraint(self):\n+        \"\"\"Test creation of new model with constraints already defined.\"\"\"\n+        author = ModelState('otherapp', 'Author', [\n+            ('id', models.AutoField(primary_key=True)),\n+            ('name', models.CharField(max_length=200)),\n+        ], {'constraints': [models.CheckConstraint(check=models.Q(name__contains='Bob'), name='name_contains_bob')]})\n+        changes = self.get_changes([], [author])\n+        added_constraint = models.CheckConstraint(check=models.Q(name__contains='Bob'), name='name_contains_bob')\n+        # Right number of migrations?\n+        self.assertEqual(len(changes['otherapp']), 1)\n+        # Right number of actions?\n+        migration = changes['otherapp'][0]\n+        self.assertEqual(len(migration.operations), 2)\n+        # Right actions order?\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['CreateModel', 'AddConstraint'])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name='Author')\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 1, model_name='author', constraint=added_constraint)\n+\n+    def test_add_constraints(self):\n+        \"\"\"Test change detection of new constraints.\"\"\"\n+        changes = self.get_changes([self.author_name], [self.author_name_check_constraint])\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, ['AddConstraint'])\n+        added_constraint = models.CheckConstraint(check=models.Q(name__contains='Bob'), name='name_contains_bob')\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, model_name='author', constraint=added_constraint)\n+\n+    def test_remove_constraints(self):\n+        \"\"\"Test change detection of removed constraints.\"\"\"\n+        changes = self.get_changes([self.author_name_check_constraint], [self.author_name])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, ['RemoveConstraint'])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, model_name='author', name='name_contains_bob')\n+\n+    def test_add_foo_together(self):\n+        \"\"\"Tests index/unique_together detection.\"\"\"\n+        changes = self.get_changes([self.author_empty, self.book], [self.author_empty, self.book_foo_together])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"AlterUniqueTogether\", \"AlterIndexTogether\"])\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 0, name=\"book\", unique_together={(\"author\", \"title\")})\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 1, name=\"book\", index_together={(\"author\", \"title\")})\n+\n+    def test_remove_foo_together(self):\n+        \"\"\"Tests index/unique_together detection.\"\"\"\n+        changes = self.get_changes([self.author_empty, self.book_foo_together], [self.author_empty, self.book])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"AlterUniqueTogether\", \"AlterIndexTogether\"])\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 0, name=\"book\", unique_together=set())\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 1, name=\"book\", index_together=set())\n+\n+    def test_foo_together_remove_fk(self):\n+        \"\"\"Tests unique_together and field removal detection & ordering\"\"\"\n+        changes = self.get_changes(\n+            [self.author_empty, self.book_foo_together], [self.author_empty, self.book_with_no_author]\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\n+            \"AlterUniqueTogether\", \"AlterIndexTogether\", \"RemoveField\"\n+        ])\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 0, name=\"book\", unique_together=set())\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 1, name=\"book\", index_together=set())\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 2, model_name=\"book\", name=\"author\")\n+\n+    def test_foo_together_no_changes(self):\n+        \"\"\"\n+        index/unique_together doesn't generate a migration if no\n+        changes have been made.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_empty, self.book_foo_together], [self.author_empty, self.book_foo_together]\n+        )\n+        # Right number of migrations?\n+        self.assertEqual(len(changes), 0)\n+\n+    def test_foo_together_ordering(self):\n+        \"\"\"\n+        index/unique_together also triggers on ordering changes.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_empty, self.book_foo_together], [self.author_empty, self.book_foo_together_2]\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"AlterUniqueTogether\", \"AlterIndexTogether\"])\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 0, name=\"book\", unique_together={(\"title\", \"author\")})\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 1, name=\"book\", index_together={(\"title\", \"author\")})\n+\n+    def test_add_field_and_foo_together(self):\n+        \"\"\"\n+        Added fields will be created before using them in index/unique_together.\n+        \"\"\"\n+        changes = self.get_changes([self.author_empty, self.book], [self.author_empty, self.book_foo_together_3])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"AddField\", \"AlterUniqueTogether\", \"AlterIndexTogether\"])\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 1, name=\"book\", unique_together={(\"title\", \"newfield\")})\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 2, name=\"book\", index_together={(\"title\", \"newfield\")})\n+\n+    def test_create_model_and_unique_together(self):\n+        author = ModelState(\"otherapp\", \"Author\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"name\", models.CharField(max_length=200)),\n+        ])\n+        book_with_author = ModelState(\"otherapp\", \"Book\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"author\", models.ForeignKey(\"otherapp.Author\", models.CASCADE)),\n+            (\"title\", models.CharField(max_length=200)),\n+        ], {\n+            \"index_together\": {(\"title\", \"author\")},\n+            \"unique_together\": {(\"title\", \"author\")},\n+        })\n+        changes = self.get_changes([self.book_with_no_author], [author, book_with_author])\n+        # Right number of migrations?\n+        self.assertEqual(len(changes['otherapp']), 1)\n+        # Right number of actions?\n+        migration = changes['otherapp'][0]\n+        self.assertEqual(len(migration.operations), 4)\n+        # Right actions order?\n+        self.assertOperationTypes(\n+            changes, 'otherapp', 0,\n+            ['CreateModel', 'AddField', 'AlterUniqueTogether', 'AlterIndexTogether']\n+        )\n+\n+    def test_remove_field_and_foo_together(self):\n+        \"\"\"\n+        Removed fields will be removed after updating index/unique_together.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_empty, self.book_foo_together_3], [self.author_empty, self.book_foo_together]\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"AlterUniqueTogether\", \"AlterIndexTogether\", \"RemoveField\"])\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 0, name=\"book\", unique_together={(\"author\", \"title\")})\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 1, name=\"book\", index_together={(\"author\", \"title\")})\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 2, model_name=\"book\", name=\"newfield\")\n+\n+    def test_rename_field_and_foo_together(self):\n+        \"\"\"\n+        Removed fields will be removed after updating index/unique_together.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_empty, self.book_foo_together_3],\n+            [self.author_empty, self.book_foo_together_4],\n+            MigrationQuestioner({\"ask_rename\": True}),\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"RenameField\", \"AlterUniqueTogether\", \"AlterIndexTogether\"])\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 1, name=\"book\", unique_together={\n+            (\"title\", \"newfield2\")\n+        })\n+        self.assertOperationAttributes(changes, \"otherapp\", 0, 2, name=\"book\", index_together={(\"title\", \"newfield2\")})\n+\n+    def test_proxy(self):\n+        \"\"\"The autodetector correctly deals with proxy models.\"\"\"\n+        # First, we test adding a proxy model\n+        changes = self.get_changes([self.author_empty], [self.author_empty, self.author_proxy])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(\n+            changes, \"testapp\", 0, 0, name=\"AuthorProxy\", options={\"proxy\": True, \"indexes\": [], \"constraints\": []}\n+        )\n+        # Now, we test turning a proxy model into a non-proxy model\n+        # It should delete the proxy then make the real one\n+        changes = self.get_changes(\n+            [self.author_empty, self.author_proxy], [self.author_empty, self.author_proxy_notproxy]\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"DeleteModel\", \"CreateModel\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"AuthorProxy\")\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 1, name=\"AuthorProxy\", options={})\n+\n+    def test_proxy_custom_pk(self):\n+        \"\"\"\n+        #23415 - The autodetector must correctly deal with custom FK on proxy\n+        models.\n+        \"\"\"\n+        # First, we test the default pk field name\n+        changes = self.get_changes([], [self.author_empty, self.author_proxy_third, self.book_proxy_fk])\n+        # The field name the FK on the book model points to\n+        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'id')\n+        # Now, we test the custom pk field name\n+        changes = self.get_changes([], [self.author_custom_pk, self.author_proxy_third, self.book_proxy_fk])\n+        # The field name the FK on the book model points to\n+        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'pk_field')\n+\n+    def test_proxy_to_mti_with_fk_to_proxy(self):\n+        # First, test the pk table and field name.\n+        changes = self.get_changes(\n+            [],\n+            [self.author_empty, self.author_proxy_third, self.book_proxy_fk],\n+        )\n+        self.assertEqual(\n+            changes['otherapp'][0].operations[0].fields[2][1].remote_field.model._meta.db_table,\n+            'testapp_author',\n+        )\n+        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'id')\n+\n+        # Change AuthorProxy to use MTI.\n+        changes = self.get_changes(\n+            [self.author_empty, self.author_proxy_third, self.book_proxy_fk],\n+            [self.author_empty, self.author_proxy_third_notproxy, self.book_proxy_fk],\n+        )\n+        # Right number/type of migrations for the AuthorProxy model?\n+        self.assertNumberMigrations(changes, 'thirdapp', 1)\n+        self.assertOperationTypes(changes, 'thirdapp', 0, ['DeleteModel', 'CreateModel'])\n+        # Right number/type of migrations for the Book model with a FK to\n+        # AuthorProxy?\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['AlterField'])\n+        # otherapp should depend on thirdapp.\n+        self.assertMigrationDependencies(changes, 'otherapp', 0, [('thirdapp', 'auto_1')])\n+        # Now, test the pk table and field name.\n+        self.assertEqual(\n+            changes['otherapp'][0].operations[0].field.remote_field.model._meta.db_table,\n+            'thirdapp_authorproxy',\n+        )\n+        self.assertEqual(changes['otherapp'][0].operations[0].field.remote_field.field_name, 'author_ptr')\n+\n+    def test_proxy_to_mti_with_fk_to_proxy_proxy(self):\n+        # First, test the pk table and field name.\n+        changes = self.get_changes(\n+            [],\n+            [self.author_empty, self.author_proxy, self.author_proxy_proxy, self.book_proxy_proxy_fk],\n+        )\n+        self.assertEqual(\n+            changes['otherapp'][0].operations[0].fields[1][1].remote_field.model._meta.db_table,\n+            'testapp_author',\n+        )\n+        self.assertEqual(changes['otherapp'][0].operations[0].fields[1][1].remote_field.field_name, 'id')\n+\n+        # Change AuthorProxy to use MTI. FK still points to AAuthorProxyProxy,\n+        # a proxy of AuthorProxy.\n+        changes = self.get_changes(\n+            [self.author_empty, self.author_proxy, self.author_proxy_proxy, self.book_proxy_proxy_fk],\n+            [self.author_empty, self.author_proxy_notproxy, self.author_proxy_proxy, self.book_proxy_proxy_fk],\n+        )\n+        # Right number/type of migrations for the AuthorProxy model?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, ['DeleteModel', 'CreateModel'])\n+        # Right number/type of migrations for the Book model with a FK to\n+        # AAuthorProxyProxy?\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['AlterField'])\n+        # otherapp should depend on testapp.\n+        self.assertMigrationDependencies(changes, 'otherapp', 0, [('testapp', 'auto_1')])\n+        # Now, test the pk table and field name.\n+        self.assertEqual(\n+            changes['otherapp'][0].operations[0].field.remote_field.model._meta.db_table,\n+            'testapp_authorproxy',\n+        )\n+        self.assertEqual(changes['otherapp'][0].operations[0].field.remote_field.field_name, 'author_ptr')\n+\n+    def test_unmanaged_create(self):\n+        \"\"\"The autodetector correctly deals with managed models.\"\"\"\n+        # First, we test adding an unmanaged model\n+        changes = self.get_changes([self.author_empty], [self.author_empty, self.author_unmanaged])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"AuthorUnmanaged\", options={\"managed\": False})\n+\n+    def test_unmanaged_delete(self):\n+        changes = self.get_changes([self.author_empty, self.author_unmanaged], [self.author_empty])\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, ['DeleteModel'])\n+\n+    def test_unmanaged_to_managed(self):\n+        # Now, we test turning an unmanaged model into a managed model\n+        changes = self.get_changes(\n+            [self.author_empty, self.author_unmanaged], [self.author_empty, self.author_unmanaged_managed]\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterModelOptions\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"authorunmanaged\", options={})\n+\n+    def test_managed_to_unmanaged(self):\n+        # Now, we turn managed to unmanaged.\n+        changes = self.get_changes(\n+            [self.author_empty, self.author_unmanaged_managed], [self.author_empty, self.author_unmanaged]\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelOptions\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"authorunmanaged\", options={\"managed\": False})\n+\n+    def test_unmanaged_custom_pk(self):\n+        \"\"\"\n+        #23415 - The autodetector must correctly deal with custom FK on\n+        unmanaged models.\n+        \"\"\"\n+        # First, we test the default pk field name\n+        changes = self.get_changes([], [self.author_unmanaged_default_pk, self.book])\n+        # The field name the FK on the book model points to\n+        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'id')\n+        # Now, we test the custom pk field name\n+        changes = self.get_changes([], [self.author_unmanaged_custom_pk, self.book])\n+        # The field name the FK on the book model points to\n+        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'pk_field')\n+\n+    @override_settings(AUTH_USER_MODEL=\"thirdapp.CustomUser\")\n+    def test_swappable(self):\n+        with isolate_lru_cache(apps.get_swappable_settings_name):\n+            changes = self.get_changes([self.custom_user], [self.custom_user, self.author_with_custom_user])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"Author\")\n+        self.assertMigrationDependencies(changes, 'testapp', 0, [(\"__setting__\", \"AUTH_USER_MODEL\")])\n+\n+    def test_swappable_changed(self):\n+        with isolate_lru_cache(apps.get_swappable_settings_name):\n+            before = self.make_project_state([self.custom_user, self.author_with_user])\n+            with override_settings(AUTH_USER_MODEL=\"thirdapp.CustomUser\"):\n+                after = self.make_project_state([self.custom_user, self.author_with_custom_user])\n+            autodetector = MigrationAutodetector(before, after)\n+            changes = autodetector._detect_changes()\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, model_name=\"author\", name='user')\n+        fk_field = changes['testapp'][0].operations[0].field\n+        to_model = '%s.%s' % (\n+            fk_field.remote_field.model._meta.app_label,\n+            fk_field.remote_field.model._meta.object_name,\n+        )\n+        self.assertEqual(to_model, 'thirdapp.CustomUser')\n+\n+    def test_add_field_with_default(self):\n+        \"\"\"#22030 - Adding a field with a default should work.\"\"\"\n+        changes = self.get_changes([self.author_empty], [self.author_name_default])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"name\")\n+\n+    def test_custom_deconstructible(self):\n+        \"\"\"\n+        Two instances which deconstruct to the same value aren't considered a\n+        change.\n+        \"\"\"\n+        changes = self.get_changes([self.author_name_deconstructible_1], [self.author_name_deconstructible_2])\n+        # Right number of migrations?\n+        self.assertEqual(len(changes), 0)\n+\n+    def test_deconstruct_field_kwarg(self):\n+        \"\"\"Field instances are handled correctly by nested deconstruction.\"\"\"\n+        changes = self.get_changes([self.author_name_deconstructible_3], [self.author_name_deconstructible_4])\n+        self.assertEqual(changes, {})\n+\n+    def test_deconstructible_list(self):\n+        \"\"\"Nested deconstruction descends into lists.\"\"\"\n+        # When lists contain items that deconstruct to identical values, those lists\n+        # should be considered equal for the purpose of detecting state changes\n+        # (even if the original items are unequal).\n+        changes = self.get_changes(\n+            [self.author_name_deconstructible_list_1], [self.author_name_deconstructible_list_2]\n+        )\n+        self.assertEqual(changes, {})\n+        # Legitimate differences within the deconstructed lists should be reported\n+        # as a change\n+        changes = self.get_changes(\n+            [self.author_name_deconstructible_list_1], [self.author_name_deconstructible_list_3]\n+        )\n+        self.assertEqual(len(changes), 1)\n+\n+    def test_deconstructible_tuple(self):\n+        \"\"\"Nested deconstruction descends into tuples.\"\"\"\n+        # When tuples contain items that deconstruct to identical values, those tuples\n+        # should be considered equal for the purpose of detecting state changes\n+        # (even if the original items are unequal).\n+        changes = self.get_changes(\n+            [self.author_name_deconstructible_tuple_1], [self.author_name_deconstructible_tuple_2]\n+        )\n+        self.assertEqual(changes, {})\n+        # Legitimate differences within the deconstructed tuples should be reported\n+        # as a change\n+        changes = self.get_changes(\n+            [self.author_name_deconstructible_tuple_1], [self.author_name_deconstructible_tuple_3]\n+        )\n+        self.assertEqual(len(changes), 1)\n+\n+    def test_deconstructible_dict(self):\n+        \"\"\"Nested deconstruction descends into dict values.\"\"\"\n+        # When dicts contain items whose values deconstruct to identical values,\n+        # those dicts should be considered equal for the purpose of detecting\n+        # state changes (even if the original values are unequal).\n+        changes = self.get_changes(\n+            [self.author_name_deconstructible_dict_1], [self.author_name_deconstructible_dict_2]\n+        )\n+        self.assertEqual(changes, {})\n+        # Legitimate differences within the deconstructed dicts should be reported\n+        # as a change\n+        changes = self.get_changes(\n+            [self.author_name_deconstructible_dict_1], [self.author_name_deconstructible_dict_3]\n+        )\n+        self.assertEqual(len(changes), 1)\n+\n+    def test_nested_deconstructible_objects(self):\n+        \"\"\"\n+        Nested deconstruction is applied recursively to the args/kwargs of\n+        deconstructed objects.\n+        \"\"\"\n+        # If the items within a deconstructed object's args/kwargs have the same\n+        # deconstructed values - whether or not the items themselves are different\n+        # instances - then the object as a whole is regarded as unchanged.\n+        changes = self.get_changes(\n+            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_2]\n+        )\n+        self.assertEqual(changes, {})\n+        # Differences that exist solely within the args list of a deconstructed object\n+        # should be reported as changes\n+        changes = self.get_changes(\n+            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_changed_arg]\n+        )\n+        self.assertEqual(len(changes), 1)\n+        # Additional args should also be reported as a change\n+        changes = self.get_changes(\n+            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_extra_arg]\n+        )\n+        self.assertEqual(len(changes), 1)\n+        # Differences that exist solely within the kwargs dict of a deconstructed object\n+        # should be reported as changes\n+        changes = self.get_changes(\n+            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_changed_kwarg]\n+        )\n+        self.assertEqual(len(changes), 1)\n+        # Additional kwargs should also be reported as a change\n+        changes = self.get_changes(\n+            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_extra_kwarg]\n+        )\n+        self.assertEqual(len(changes), 1)\n+\n+    def test_deconstruct_type(self):\n+        \"\"\"\n+        #22951 -- Uninstantiated classes with deconstruct are correctly returned\n+        by deep_deconstruct during serialization.\n+        \"\"\"\n+        author = ModelState(\n+            \"testapp\",\n+            \"Author\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"name\", models.CharField(\n+                    max_length=200,\n+                    # IntegerField intentionally not instantiated.\n+                    default=models.IntegerField,\n+                ))\n+            ],\n+        )\n+        changes = self.get_changes([], [author])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\"])\n+\n+    def test_replace_string_with_foreignkey(self):\n+        \"\"\"\n+        #22300 - Adding an FK in the same \"spot\" as a deleted CharField should\n+        work.\n+        \"\"\"\n+        changes = self.get_changes([self.author_with_publisher_string], [self.author_with_publisher, self.publisher])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\", \"RemoveField\", \"AddField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"Publisher\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"publisher_name\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 2, name=\"publisher\")\n+\n+    def test_foreign_key_removed_before_target_model(self):\n+        \"\"\"\n+        Removing an FK and the model it targets in the same change must remove\n+        the FK field before the model to maintain consistency.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_with_publisher, self.publisher], [self.author_name]\n+        )  # removes both the model and FK\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"RemoveField\", \"DeleteModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"publisher\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"Publisher\")\n+\n+    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition',\n+                side_effect=AssertionError(\"Should not have prompted for not null addition\"))\n+    def test_add_many_to_many(self, mocked_ask_method):\n+        \"\"\"#22435 - Adding a ManyToManyField should not prompt for a default.\"\"\"\n+        changes = self.get_changes([self.author_empty, self.publisher], [self.author_with_m2m, self.publisher])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"publishers\")\n+\n+    def test_alter_many_to_many(self):\n+        changes = self.get_changes(\n+            [self.author_with_m2m, self.publisher], [self.author_with_m2m_blank, self.publisher]\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"publishers\")\n+\n+    def test_create_with_through_model(self):\n+        \"\"\"\n+        Adding a m2m with a through model and the models that use it should be\n+        ordered correctly.\n+        \"\"\"\n+        changes = self.get_changes([], [self.author_with_m2m_through, self.publisher, self.contract])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\n+            'CreateModel', 'CreateModel', 'CreateModel', 'AddField',\n+        ])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name='Author')\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name='Publisher')\n+        self.assertOperationAttributes(changes, 'testapp', 0, 2, name='Contract')\n+        self.assertOperationAttributes(changes, 'testapp', 0, 3, model_name='author', name='publishers')\n+\n+    def test_many_to_many_removed_before_through_model(self):\n+        \"\"\"\n+        Removing a ManyToManyField and the \"through\" model in the same change\n+        must remove the field before the model to maintain consistency.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.book_with_multiple_authors_through_attribution, self.author_name, self.attribution],\n+            [self.book_with_no_author, self.author_name],\n+        )\n+        # Remove both the through model and ManyToMany\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['RemoveField', 'DeleteModel'])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name='authors', model_name='book')\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 1, name='Attribution')\n+\n+    def test_many_to_many_removed_before_through_model_2(self):\n+        \"\"\"\n+        Removing a model that contains a ManyToManyField and the \"through\" model\n+        in the same change must remove the field before the model to maintain\n+        consistency.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.book_with_multiple_authors_through_attribution, self.author_name, self.attribution],\n+            [self.author_name],\n+        )\n+        # Remove both the through model and ManyToMany\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['RemoveField', 'DeleteModel', 'DeleteModel'])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name='authors', model_name='book')\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 1, name='Attribution')\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 2, name='Book')\n+\n+    def test_m2m_w_through_multistep_remove(self):\n+        \"\"\"\n+        A model with a m2m field that specifies a \"through\" model cannot be\n+        removed in the same migration as that through model as the schema will\n+        pass through an inconsistent state. The autodetector should produce two\n+        migrations to avoid this issue.\n+        \"\"\"\n+        changes = self.get_changes([self.author_with_m2m_through, self.publisher, self.contract], [self.publisher])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\n+            \"RemoveField\", \"RemoveField\", \"DeleteModel\", \"DeleteModel\"\n+        ])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"author\", model_name='contract')\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 1, name=\"publisher\", model_name='contract')\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 2, name=\"Author\")\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 3, name=\"Contract\")\n+\n+    def test_concrete_field_changed_to_many_to_many(self):\n+        \"\"\"\n+        #23938 - Changing a concrete field into a ManyToManyField\n+        first removes the concrete field and then adds the m2m field.\n+        \"\"\"\n+        changes = self.get_changes([self.author_with_former_m2m], [self.author_with_m2m, self.publisher])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"CreateModel\", \"RemoveField\", \"AddField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name='Publisher')\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"publishers\", model_name='author')\n+        self.assertOperationAttributes(changes, 'testapp', 0, 2, name=\"publishers\", model_name='author')\n+\n+    def test_many_to_many_changed_to_concrete_field(self):\n+        \"\"\"\n+        #23938 - Changing a ManyToManyField into a concrete field\n+        first removes the m2m field and then adds the concrete field.\n+        \"\"\"\n+        changes = self.get_changes([self.author_with_m2m, self.publisher], [self.author_with_former_m2m])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"RemoveField\", \"AddField\", \"DeleteModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"publishers\", model_name='author')\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"publishers\", model_name='author')\n+        self.assertOperationAttributes(changes, 'testapp', 0, 2, name='Publisher')\n+        self.assertOperationFieldAttributes(changes, 'testapp', 0, 1, max_length=100)\n+\n+    def test_non_circular_foreignkey_dependency_removal(self):\n+        \"\"\"\n+        If two models with a ForeignKey from one to the other are removed at the\n+        same time, the autodetector should remove them in the correct order.\n+        \"\"\"\n+        changes = self.get_changes([self.author_with_publisher, self.publisher_with_author], [])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"RemoveField\", \"DeleteModel\", \"DeleteModel\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"author\", model_name='publisher')\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 1, name=\"Author\")\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 2, name=\"Publisher\")\n+\n+    def test_alter_model_options(self):\n+        \"\"\"Changing a model's options should make a change.\"\"\"\n+        changes = self.get_changes([self.author_empty], [self.author_with_options])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelOptions\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, options={\n+            \"permissions\": [('can_hire', 'Can hire')],\n+            \"verbose_name\": \"Authi\",\n+        })\n+\n+        # Changing them back to empty should also make a change\n+        changes = self.get_changes([self.author_with_options], [self.author_empty])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelOptions\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"author\", options={})\n+\n+    def test_alter_model_options_proxy(self):\n+        \"\"\"Changing a proxy model's options should also make a change.\"\"\"\n+        changes = self.get_changes(\n+            [self.author_proxy, self.author_empty], [self.author_proxy_options, self.author_empty]\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelOptions\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"authorproxy\", options={\n+            \"verbose_name\": \"Super Author\"\n+        })\n+\n+    def test_set_alter_order_with_respect_to(self):\n+        \"\"\"Setting order_with_respect_to adds a field.\"\"\"\n+        changes = self.get_changes([self.book, self.author_with_book], [self.book, self.author_with_book_order_wrt])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterOrderWithRespectTo\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"author\", order_with_respect_to=\"book\")\n+\n+    def test_add_alter_order_with_respect_to(self):\n+        \"\"\"\n+        Setting order_with_respect_to when adding the FK too does\n+        things in the right order.\n+        \"\"\"\n+        changes = self.get_changes([self.author_name], [self.book, self.author_with_book_order_wrt])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\", \"AlterOrderWithRespectTo\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, model_name=\"author\", name=\"book\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"author\", order_with_respect_to=\"book\")\n+\n+    def test_remove_alter_order_with_respect_to(self):\n+        \"\"\"\n+        Removing order_with_respect_to when removing the FK too does\n+        things in the right order.\n+        \"\"\"\n+        changes = self.get_changes([self.book, self.author_with_book_order_wrt], [self.author_name])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AlterOrderWithRespectTo\", \"RemoveField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"author\", order_with_respect_to=None)\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, model_name=\"author\", name=\"book\")\n+\n+    def test_add_model_order_with_respect_to(self):\n+        \"\"\"\n+        Setting order_with_respect_to when adding the whole model\n+        does things in the right order.\n+        \"\"\"\n+        changes = self.get_changes([], [self.book, self.author_with_book_order_wrt])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(\n+            changes, 'testapp', 0, 0, name=\"Author\", options={'order_with_respect_to': 'book'}\n+        )\n+        self.assertNotIn(\"_order\", [name for name, field in changes['testapp'][0].operations[0].fields])\n+\n+    def test_alter_model_managers(self):\n+        \"\"\"\n+        Changing the model managers adds a new operation.\n+        \"\"\"\n+        changes = self.get_changes([self.other_pony], [self.other_pony_food])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\"AlterModelManagers\"])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name=\"pony\")\n+        self.assertEqual([name for name, mgr in changes['otherapp'][0].operations[0].managers],\n+                         ['food_qs', 'food_mgr', 'food_mgr_kwargs'])\n+        self.assertEqual(changes['otherapp'][0].operations[0].managers[1][1].args, ('a', 'b', 1, 2))\n+        self.assertEqual(changes['otherapp'][0].operations[0].managers[2][1].args, ('x', 'y', 3, 4))\n+\n+    def test_swappable_first_inheritance(self):\n+        \"\"\"Swappable models get their CreateModel first.\"\"\"\n+        changes = self.get_changes([], [self.custom_user, self.aardvark])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'thirdapp', 1)\n+        self.assertOperationTypes(changes, 'thirdapp', 0, [\"CreateModel\", \"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'thirdapp', 0, 0, name=\"CustomUser\")\n+        self.assertOperationAttributes(changes, 'thirdapp', 0, 1, name=\"Aardvark\")\n+\n+    def test_default_related_name_option(self):\n+        model_state = ModelState('app', 'model', [\n+            ('id', models.AutoField(primary_key=True)),\n+        ], options={'default_related_name': 'related_name'})\n+        changes = self.get_changes([], [model_state])\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['CreateModel'])\n+        self.assertOperationAttributes(\n+            changes, 'app', 0, 0, name='model',\n+            options={'default_related_name': 'related_name'},\n+        )\n+        altered_model_state = ModelState('app', 'Model', [\n+            ('id', models.AutoField(primary_key=True)),\n+        ])\n+        changes = self.get_changes([model_state], [altered_model_state])\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['AlterModelOptions'])\n+        self.assertOperationAttributes(changes, 'app', 0, 0, name='model', options={})\n+\n+    @override_settings(AUTH_USER_MODEL=\"thirdapp.CustomUser\")\n+    def test_swappable_first_setting(self):\n+        \"\"\"Swappable models get their CreateModel first.\"\"\"\n+        with isolate_lru_cache(apps.get_swappable_settings_name):\n+            changes = self.get_changes([], [self.custom_user_no_inherit, self.aardvark])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'thirdapp', 1)\n+        self.assertOperationTypes(changes, 'thirdapp', 0, [\"CreateModel\", \"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'thirdapp', 0, 0, name=\"CustomUser\")\n+        self.assertOperationAttributes(changes, 'thirdapp', 0, 1, name=\"Aardvark\")\n+\n+    def test_bases_first(self):\n+        \"\"\"Bases of other models come first.\"\"\"\n+        changes = self.get_changes([], [self.aardvark_based_on_author, self.author_name])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\", \"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"Author\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"Aardvark\")\n+\n+    def test_multiple_bases(self):\n+        \"\"\"#23956 - Inheriting models doesn't move *_ptr fields into AddField operations.\"\"\"\n+        A = ModelState(\"app\", \"A\", [(\"a_id\", models.AutoField(primary_key=True))])\n+        B = ModelState(\"app\", \"B\", [(\"b_id\", models.AutoField(primary_key=True))])\n+        C = ModelState(\"app\", \"C\", [], bases=(\"app.A\", \"app.B\"))\n+        D = ModelState(\"app\", \"D\", [], bases=(\"app.A\", \"app.B\"))\n+        E = ModelState(\"app\", \"E\", [], bases=(\"app.A\", \"app.B\"))\n+        changes = self.get_changes([], [A, B, C, D, E])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, \"app\", 1)\n+        self.assertOperationTypes(changes, \"app\", 0, [\n+            \"CreateModel\", \"CreateModel\", \"CreateModel\", \"CreateModel\", \"CreateModel\"\n+        ])\n+        self.assertOperationAttributes(changes, \"app\", 0, 0, name=\"A\")\n+        self.assertOperationAttributes(changes, \"app\", 0, 1, name=\"B\")\n+        self.assertOperationAttributes(changes, \"app\", 0, 2, name=\"C\")\n+        self.assertOperationAttributes(changes, \"app\", 0, 3, name=\"D\")\n+        self.assertOperationAttributes(changes, \"app\", 0, 4, name=\"E\")\n+\n+    def test_proxy_bases_first(self):\n+        \"\"\"Bases of proxies come first.\"\"\"\n+        changes = self.get_changes([], [self.author_empty, self.author_proxy, self.author_proxy_proxy])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\", \"CreateModel\", \"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"Author\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"AuthorProxy\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 2, name=\"AAuthorProxyProxy\")\n+\n+    def test_pk_fk_included(self):\n+        \"\"\"\n+        A relation used as the primary key is kept as part of CreateModel.\n+        \"\"\"\n+        changes = self.get_changes([], [self.aardvark_pk_fk_author, self.author_name])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\", \"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"Author\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"Aardvark\")\n+\n+    def test_first_dependency(self):\n+        \"\"\"\n+        A dependency to an app with no migrations uses __first__.\n+        \"\"\"\n+        # Load graph\n+        loader = MigrationLoader(connection)\n+        before = self.make_project_state([])\n+        after = self.make_project_state([self.book_migrations_fk])\n+        after.real_apps = [\"migrations\"]\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes(graph=loader.graph)\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name=\"Book\")\n+        self.assertMigrationDependencies(changes, 'otherapp', 0, [(\"migrations\", \"__first__\")])\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_last_dependency(self):\n+        \"\"\"\n+        A dependency to an app with existing migrations uses the\n+        last migration of that app.\n+        \"\"\"\n+        # Load graph\n+        loader = MigrationLoader(connection)\n+        before = self.make_project_state([])\n+        after = self.make_project_state([self.book_migrations_fk])\n+        after.real_apps = [\"migrations\"]\n+        autodetector = MigrationAutodetector(before, after)\n+        changes = autodetector._detect_changes(graph=loader.graph)\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name=\"Book\")\n+        self.assertMigrationDependencies(changes, 'otherapp', 0, [(\"migrations\", \"0002_second\")])\n+\n+    def test_alter_fk_before_model_deletion(self):\n+        \"\"\"\n+        ForeignKeys are altered _before_ the model they used to\n+        refer to are deleted.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_name, self.publisher_with_author],\n+            [self.aardvark_testapp, self.publisher_with_aardvark_author]\n+        )\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"CreateModel\", \"AlterField\", \"DeleteModel\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"Aardvark\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 1, name=\"author\")\n+        self.assertOperationAttributes(changes, 'testapp', 0, 2, name=\"Author\")\n+\n+    def test_fk_dependency_other_app(self):\n+        \"\"\"\n+        #23100 - ForeignKeys correctly depend on other apps' models.\n+        \"\"\"\n+        changes = self.get_changes([self.author_name, self.book], [self.author_with_book, self.book])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name=\"book\")\n+        self.assertMigrationDependencies(changes, 'testapp', 0, [(\"otherapp\", \"__first__\")])\n+\n+    def test_alter_field_to_fk_dependency_other_app(self):\n+        changes = self.get_changes(\n+            [self.author_empty, self.book_with_no_author_fk],\n+            [self.author_empty, self.book],\n+        )\n+        self.assertNumberMigrations(changes, 'otherapp', 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, ['AlterField'])\n+        self.assertMigrationDependencies(changes, 'otherapp', 0, [('testapp', '__first__')])\n+\n+    def test_circular_dependency_mixed_addcreate(self):\n+        \"\"\"\n+        #23315 - The dependency resolver knows to put all CreateModel\n+        before AddField and not become unsolvable.\n+        \"\"\"\n+        address = ModelState(\"a\", \"Address\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"country\", models.ForeignKey(\"b.DeliveryCountry\", models.CASCADE)),\n+        ])\n+        person = ModelState(\"a\", \"Person\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+        ])\n+        apackage = ModelState(\"b\", \"APackage\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"person\", models.ForeignKey(\"a.Person\", models.CASCADE)),\n+        ])\n+        country = ModelState(\"b\", \"DeliveryCountry\", [\n+            (\"id\", models.AutoField(primary_key=True)),\n+        ])\n+        changes = self.get_changes([], [address, person, apackage, country])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'a', 2)\n+        self.assertNumberMigrations(changes, 'b', 1)\n+        self.assertOperationTypes(changes, 'a', 0, [\"CreateModel\", \"CreateModel\"])\n+        self.assertOperationTypes(changes, 'a', 1, [\"AddField\"])\n+        self.assertOperationTypes(changes, 'b', 0, [\"CreateModel\", \"CreateModel\"])\n+\n+    @override_settings(AUTH_USER_MODEL=\"a.Tenant\")\n+    def test_circular_dependency_swappable(self):\n+        \"\"\"\n+        #23322 - The dependency resolver knows to explicitly resolve\n+        swappable models.\n+        \"\"\"\n+        with isolate_lru_cache(apps.get_swappable_settings_name):\n+            tenant = ModelState(\"a\", \"Tenant\", [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"primary_address\", models.ForeignKey(\"b.Address\", models.CASCADE))],\n+                bases=(AbstractBaseUser,)\n+            )\n+            address = ModelState(\"b\", \"Address\", [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"tenant\", models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE)),\n+            ])\n+            changes = self.get_changes([], [address, tenant])\n+\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'a', 2)\n+        self.assertOperationTypes(changes, 'a', 0, [\"CreateModel\"])\n+        self.assertOperationTypes(changes, 'a', 1, [\"AddField\"])\n+        self.assertMigrationDependencies(changes, 'a', 0, [])\n+        self.assertMigrationDependencies(changes, 'a', 1, [('a', 'auto_1'), ('b', 'auto_1')])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'b', 1)\n+        self.assertOperationTypes(changes, 'b', 0, [\"CreateModel\"])\n+        self.assertMigrationDependencies(changes, 'b', 0, [('__setting__', 'AUTH_USER_MODEL')])\n+\n+    @override_settings(AUTH_USER_MODEL=\"b.Tenant\")\n+    def test_circular_dependency_swappable2(self):\n+        \"\"\"\n+        #23322 - The dependency resolver knows to explicitly resolve\n+        swappable models but with the swappable not being the first migrated\n+        model.\n+        \"\"\"\n+        with isolate_lru_cache(apps.get_swappable_settings_name):\n+            address = ModelState(\"a\", \"Address\", [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"tenant\", models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE)),\n+            ])\n+            tenant = ModelState(\"b\", \"Tenant\", [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"primary_address\", models.ForeignKey(\"a.Address\", models.CASCADE))],\n+                bases=(AbstractBaseUser,)\n+            )\n+            changes = self.get_changes([], [address, tenant])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'a', 2)\n+        self.assertOperationTypes(changes, 'a', 0, [\"CreateModel\"])\n+        self.assertOperationTypes(changes, 'a', 1, [\"AddField\"])\n+        self.assertMigrationDependencies(changes, 'a', 0, [])\n+        self.assertMigrationDependencies(changes, 'a', 1, [('__setting__', 'AUTH_USER_MODEL'), ('a', 'auto_1')])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'b', 1)\n+        self.assertOperationTypes(changes, 'b', 0, [\"CreateModel\"])\n+        self.assertMigrationDependencies(changes, 'b', 0, [('a', 'auto_1')])\n+\n+    @override_settings(AUTH_USER_MODEL=\"a.Person\")\n+    def test_circular_dependency_swappable_self(self):\n+        \"\"\"\n+        #23322 - The dependency resolver knows to explicitly resolve\n+        swappable models.\n+        \"\"\"\n+        with isolate_lru_cache(apps.get_swappable_settings_name):\n+            person = ModelState(\"a\", \"Person\", [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"parent1\", models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE, related_name='children'))\n+            ])\n+            changes = self.get_changes([], [person])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'a', 1)\n+        self.assertOperationTypes(changes, 'a', 0, [\"CreateModel\"])\n+        self.assertMigrationDependencies(changes, 'a', 0, [])\n+\n+    @override_settings(AUTH_USER_MODEL='a.User')\n+    def test_swappable_circular_multi_mti(self):\n+        with isolate_lru_cache(apps.get_swappable_settings_name):\n+            parent = ModelState('a', 'Parent', [\n+                ('user', models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE))\n+            ])\n+            child = ModelState('a', 'Child', [], bases=('a.Parent',))\n+            user = ModelState('a', 'User', [], bases=(AbstractBaseUser, 'a.Child'))\n+            changes = self.get_changes([], [parent, child, user])\n+        self.assertNumberMigrations(changes, 'a', 1)\n+        self.assertOperationTypes(changes, 'a', 0, ['CreateModel', 'CreateModel', 'CreateModel', 'AddField'])\n+\n+    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition',\n+                side_effect=AssertionError(\"Should not have prompted for not null addition\"))\n+    def test_add_blank_textfield_and_charfield(self, mocked_ask_method):\n+        \"\"\"\n+        #23405 - Adding a NOT NULL and blank `CharField` or `TextField`\n+        without default should not prompt for a default.\n+        \"\"\"\n+        changes = self.get_changes([self.author_empty], [self.author_with_biography_blank])\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\", \"AddField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0)\n+\n+    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition')\n+    def test_add_non_blank_textfield_and_charfield(self, mocked_ask_method):\n+        \"\"\"\n+        #23405 - Adding a NOT NULL and non-blank `CharField` or `TextField`\n+        without default should prompt for a default.\n+        \"\"\"\n+        changes = self.get_changes([self.author_empty], [self.author_with_biography_non_blank])\n+        self.assertEqual(mocked_ask_method.call_count, 2)\n+        # Right number/type of migrations?\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\", \"AddField\"])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0)\n+\n+    def test_mti_inheritance_model_removal(self):\n+        Animal = ModelState('app', 'Animal', [\n+            (\"id\", models.AutoField(primary_key=True)),\n+        ])\n+        Dog = ModelState('app', 'Dog', [], bases=('app.Animal',))\n+        changes = self.get_changes([Animal, Dog], [Animal])\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['DeleteModel'])\n+        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n+\n+    def test_move_field_to_subclass(self):\n+        \"\"\"\n+        Tests that moving a field from a parent model to a new child model\n+        generates operations in the correct order (RemoveField, then\n+        CreateModel).\n+        \"\"\"\n+        readable_before = ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"title\", models.CharField(max_length=200)),\n+            ],\n+        )\n+        readable_after = ModelState(\n+            \"testapp\",\n+            \"Readable\",\n+            [(\"id\", models.AutoField(primary_key=True))],\n+        )\n+        book_after = ModelState(\n+            \"testapp\",\n+            \"Book\",\n+            [(\"title\", models.CharField(max_length=200))],\n+            bases=(\"testapp.Readable\",)\n+        )\n+        changes = self.get_changes(\n+            [readable_before],\n+            [readable_after, book_after],\n+        )\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"RemoveField\", \"CreateModel\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, model_name=\"Readable\", name=\"title\")\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 1, name=\"Book\")\n"], "arch": "x86_64", "base_commit": "18759b2209ff556aed7f20d83cbf23e3d234e41c", "test_directives": ["migrations.test_autodetector_bug"], "coverage_files": ["django/db/migrations/autodetector.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/migrations/autodetector\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 migrations.test_autodetector_bug", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}