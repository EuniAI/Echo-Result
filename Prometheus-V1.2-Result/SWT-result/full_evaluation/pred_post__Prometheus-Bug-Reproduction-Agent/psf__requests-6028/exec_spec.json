{"instance_id": "psf__requests-6028", "repo": "psf/requests", "version": "2.27", "environment_setup_commit": "0192aac24123735b3eaf9b08df46429bb770c283", "patch_list": ["diff --git a/requests/utils.py b/requests/utils.py\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -974,6 +974,10 @@ def prepend_scheme_if_needed(url, new_scheme):\n     if not netloc:\n         netloc, path = path, netloc\n \n+    if auth:\n+        # parse_url doesn't provide the netloc with auth\n+        # so we'll add it ourselves.\n+        netloc = '@'.join([auth, netloc])\n     if scheme is None:\n         scheme = new_scheme\n     if path is None:\n", "diff --git a/tests/test_proxy.py b/tests/test_proxy.py\nnew file mode 100644\nindex 00000000..c9faad6f\n--- /dev/null\n+++ b/tests/test_proxy.py\n@@ -0,0 +1,47 @@\n+# -*- coding: utf-8 -*-\n+import pytest\n+import requests\n+from unittest.mock import patch, Mock\n+\n+\n+def test_proxy_authentication_header_is_sent():\n+    \"\"\"\n+    Verifies that credentials in a proxy URL are sent as a\n+    'Proxy-Authorization' header.\n+\n+    This test patches the underlying `urlopen` call in `urllib3` to\n+    intercept the request before it goes over the network. This allows us\n+    to inspect the headers that `requests` prepares for the proxied\n+    request and assert that the `Proxy-Authorization` header is present.\n+    \"\"\"\n+    # The target to patch is the low-level method in urllib3 that sends requests.\n+    patch_target = 'urllib3.connectionpool.HTTPConnectionPool.urlopen'\n+\n+    with patch(patch_target, autospec=True) as mock_urlopen:\n+        # We must provide a mock response object for requests to process.\n+        mock_response = Mock()\n+        mock_response.status = 200\n+        mock_response.headers = {}\n+        # This is needed to prevent errors in redirect handling.\n+        mock_response.get_redirect_location.return_value = None\n+        mock_urlopen.return_value = mock_response\n+\n+        proxies = {\n+            'http': 'http://user:pass@myproxy.com:8080'\n+        }\n+\n+        # Use stream=True to prevent requests from trying to iterate over the\n+        # response body. Our mock is not iterable, and we don't care about\n+        # the body anyway. This resolves the TypeError.\n+        requests.get('http://example.com/', proxies=proxies, stream=True)\n+\n+        # Ensure the low-level send method was actually called.\n+        mock_urlopen.assert_called_once()\n+\n+        # Extract the headers from the arguments passed to urlopen.\n+        call_kwargs = mock_urlopen.call_args.kwargs\n+        sent_headers = call_kwargs['headers']\n+\n+        # This is the minimal assertion that will fail if the bug is present\n+        # and pass when the bug is fixed.\n+        assert 'Proxy-Authorization' in sent_headers\n"], "arch": "x86_64", "base_commit": "0192aac24123735b3eaf9b08df46429bb770c283", "test_directives": ["tests/test_proxy.py"], "coverage_files": ["requests/utils.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.9", "packages": "pytest", "install": "python -m pip install ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(requests/utils\\.py)' -m pytest --no-header -rA  -p no:cacheprovider tests/test_proxy.py", "req_install_commands": ["conda create -n testbed python=3.9 pytest -y"]}