{"instance_id": "django__django-12125", "repo": "django/django", "version": "3.1", "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab", "patch_list": ["diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -269,7 +269,7 @@ def serialize(self):\n             if module == builtins.__name__:\n                 return self.value.__name__, set()\n             else:\n-                return \"%s.%s\" % (module, self.value.__name__), {\"import %s\" % module}\n+                return \"%s.%s\" % (module, self.value.__qualname__), {\"import %s\" % module}\n \n \n class UUIDSerializer(BaseSerializer):\n", "diff --git a/tests/field_deconstruction/test_nested_field_deconstruction.py b/tests/field_deconstruction/test_nested_field_deconstruction.py\nnew file mode 100644\nindex 0000000000..05d06e3650\n--- /dev/null\n+++ b/tests/field_deconstruction/test_nested_field_deconstruction.py\n@@ -0,0 +1,511 @@\n+from django.apps import apps\n+from django.db import models\n+from django.test import SimpleTestCase, override_settings\n+from django.test.utils import isolate_lru_cache\n+\n+\n+class FieldDeconstructionTests(SimpleTestCase):\n+    \"\"\"\n+    Tests the deconstruct() method on all core fields.\n+    \"\"\"\n+\n+    def test_name(self):\n+        \"\"\"\n+        Tests the outputting of the correct name if assigned one.\n+        \"\"\"\n+        # First try using a \"normal\" field\n+        field = models.CharField(max_length=65)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertIsNone(name)\n+        field.set_attributes_from_name(\"is_awesome_test\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(name, \"is_awesome_test\")\n+        # Now try with a ForeignKey\n+        field = models.ForeignKey(\"some_fake.ModelName\", models.CASCADE)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertIsNone(name)\n+        field.set_attributes_from_name(\"author\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(name, \"author\")\n+\n+    def test_deconstruct_nested_field(self):\n+        \"\"\"\n+        A nested field class should deconstruct to a qualified path.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        field = Outer.Inner(max_length=20)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, 'field_deconstruction.tests.Outer.Inner')\n+\n+    def test_db_tablespace(self):\n+        field = models.Field()\n+        _, _, args, kwargs = field.deconstruct()\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+        # With a DEFAULT_DB_TABLESPACE.\n+        with self.settings(DEFAULT_DB_TABLESPACE='foo'):\n+            _, _, args, kwargs = field.deconstruct()\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+        # With a db_tablespace.\n+        field = models.Field(db_tablespace='foo')\n+        _, _, args, kwargs = field.deconstruct()\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {'db_tablespace': 'foo'})\n+        # With a db_tablespace equal to DEFAULT_DB_TABLESPACE.\n+        with self.settings(DEFAULT_DB_TABLESPACE='foo'):\n+            _, _, args, kwargs = field.deconstruct()\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {'db_tablespace': 'foo'})\n+\n+    def test_auto_field(self):\n+        field = models.AutoField(primary_key=True)\n+        field.set_attributes_from_name(\"id\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.AutoField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"primary_key\": True})\n+\n+    def test_big_integer_field(self):\n+        field = models.BigIntegerField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.BigIntegerField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_boolean_field(self):\n+        field = models.BooleanField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.BooleanField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+        field = models.BooleanField(default=True)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.BooleanField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"default\": True})\n+\n+    def test_char_field(self):\n+        field = models.CharField(max_length=65)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.CharField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"max_length\": 65})\n+        field = models.CharField(max_length=65, null=True, blank=True)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.CharField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"max_length\": 65, \"null\": True, \"blank\": True})\n+\n+    def test_char_field_choices(self):\n+        field = models.CharField(max_length=1, choices=((\"A\", \"One\"), (\"B\", \"Two\")))\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.CharField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"choices\": [(\"A\", \"One\"), (\"B\", \"Two\")], \"max_length\": 1})\n+\n+    def test_csi_field(self):\n+        field = models.CommaSeparatedIntegerField(max_length=100)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.CommaSeparatedIntegerField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"max_length\": 100})\n+\n+    def test_date_field(self):\n+        field = models.DateField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.DateField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+        field = models.DateField(auto_now=True)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.DateField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"auto_now\": True})\n+\n+    def test_datetime_field(self):\n+        field = models.DateTimeField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.DateTimeField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+        field = models.DateTimeField(auto_now_add=True)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.DateTimeField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"auto_now_add\": True})\n+        # Bug #21785\n+        field = models.DateTimeField(auto_now=True, auto_now_add=True)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.DateTimeField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"auto_now_add\": True, \"auto_now\": True})\n+\n+    def test_decimal_field(self):\n+        field = models.DecimalField(max_digits=5, decimal_places=2)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.DecimalField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"max_digits\": 5, \"decimal_places\": 2})\n+\n+    def test_decimal_field_0_decimal_places(self):\n+        \"\"\"\n+        A DecimalField with decimal_places=0 should work (#22272).\n+        \"\"\"\n+        field = models.DecimalField(max_digits=5, decimal_places=0)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.DecimalField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"max_digits\": 5, \"decimal_places\": 0})\n+\n+    def test_email_field(self):\n+        field = models.EmailField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.EmailField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"max_length\": 254})\n+        field = models.EmailField(max_length=255)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.EmailField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"max_length\": 255})\n+\n+    def test_file_field(self):\n+        field = models.FileField(upload_to=\"foo/bar\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.FileField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"upload_to\": \"foo/bar\"})\n+        # Test max_length\n+        field = models.FileField(upload_to=\"foo/bar\", max_length=200)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.FileField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"upload_to\": \"foo/bar\", \"max_length\": 200})\n+\n+    def test_file_path_field(self):\n+        field = models.FilePathField(match=r\".*\\.txt$\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.FilePathField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"match\": r\".*\\.txt$\"})\n+        field = models.FilePathField(recursive=True, allow_folders=True, max_length=123)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.FilePathField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"recursive\": True, \"allow_folders\": True, \"max_length\": 123})\n+\n+    def test_float_field(self):\n+        field = models.FloatField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.FloatField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_foreign_key(self):\n+        # Test basic pointing\n+        from django.contrib.auth.models import Permission\n+        field = models.ForeignKey(\"auth.Permission\", models.CASCADE)\n+        field.remote_field.model = Permission\n+        field.remote_field.field_name = \"id\"\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"on_delete\": models.CASCADE})\n+        self.assertFalse(hasattr(kwargs['to'], \"setting_name\"))\n+        # Test swap detection for swappable model\n+        field = models.ForeignKey(\"auth.User\", models.CASCADE)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.User\", \"on_delete\": models.CASCADE})\n+        self.assertEqual(kwargs['to'].setting_name, \"AUTH_USER_MODEL\")\n+        # Test nonexistent (for now) model\n+        field = models.ForeignKey(\"something.Else\", models.CASCADE)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"something.Else\", \"on_delete\": models.CASCADE})\n+        # Test on_delete\n+        field = models.ForeignKey(\"auth.User\", models.SET_NULL)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.User\", \"on_delete\": models.SET_NULL})\n+        # Test to_field preservation\n+        field = models.ForeignKey(\"auth.Permission\", models.CASCADE, to_field=\"foobar\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"to_field\": \"foobar\", \"on_delete\": models.CASCADE})\n+        # Test related_name preservation\n+        field = models.ForeignKey(\"auth.Permission\", models.CASCADE, related_name=\"foobar\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"related_name\": \"foobar\", \"on_delete\": models.CASCADE})\n+        # Test related_query_name\n+        field = models.ForeignKey(\"auth.Permission\", models.CASCADE, related_query_name=\"foobar\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(\n+            kwargs,\n+            {\"to\": \"auth.Permission\", \"related_query_name\": \"foobar\", \"on_delete\": models.CASCADE}\n+        )\n+        # Test limit_choices_to\n+        field = models.ForeignKey(\"auth.Permission\", models.CASCADE, limit_choices_to={'foo': 'bar'})\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(\n+            kwargs,\n+            {\"to\": \"auth.Permission\", \"limit_choices_to\": {'foo': 'bar'}, \"on_delete\": models.CASCADE}\n+        )\n+        # Test unique\n+        field = models.ForeignKey(\"auth.Permission\", models.CASCADE, unique=True)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"unique\": True, \"on_delete\": models.CASCADE})\n+\n+    @override_settings(AUTH_USER_MODEL=\"auth.Permission\")\n+    def test_foreign_key_swapped(self):\n+        with isolate_lru_cache(apps.get_swappable_settings_name):\n+            # It doesn't matter that we swapped out user for permission;\n+            # there's no validation. We just want to check the setting stuff works.\n+            field = models.ForeignKey(\"auth.Permission\", models.CASCADE)\n+            name, path, args, kwargs = field.deconstruct()\n+\n+        self.assertEqual(path, \"django.db.models.ForeignKey\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"on_delete\": models.CASCADE})\n+        self.assertEqual(kwargs['to'].setting_name, \"AUTH_USER_MODEL\")\n+\n+    def test_one_to_one(self):\n+        # Test basic pointing\n+        from django.contrib.auth.models import Permission\n+        field = models.OneToOneField(\"auth.Permission\", models.CASCADE)\n+        field.remote_field.model = Permission\n+        field.remote_field.field_name = \"id\"\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.OneToOneField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"on_delete\": models.CASCADE})\n+        self.assertFalse(hasattr(kwargs['to'], \"setting_name\"))\n+        # Test swap detection for swappable model\n+        field = models.OneToOneField(\"auth.User\", models.CASCADE)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.OneToOneField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.User\", \"on_delete\": models.CASCADE})\n+        self.assertEqual(kwargs['to'].setting_name, \"AUTH_USER_MODEL\")\n+        # Test nonexistent (for now) model\n+        field = models.OneToOneField(\"something.Else\", models.CASCADE)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.OneToOneField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"something.Else\", \"on_delete\": models.CASCADE})\n+        # Test on_delete\n+        field = models.OneToOneField(\"auth.User\", models.SET_NULL)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.OneToOneField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.User\", \"on_delete\": models.SET_NULL})\n+        # Test to_field\n+        field = models.OneToOneField(\"auth.Permission\", models.CASCADE, to_field=\"foobar\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.OneToOneField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"to_field\": \"foobar\", \"on_delete\": models.CASCADE})\n+        # Test related_name\n+        field = models.OneToOneField(\"auth.Permission\", models.CASCADE, related_name=\"foobar\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.OneToOneField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"related_name\": \"foobar\", \"on_delete\": models.CASCADE})\n+        # Test related_query_name\n+        field = models.OneToOneField(\"auth.Permission\", models.CASCADE, related_query_name=\"foobar\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.OneToOneField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(\n+            kwargs,\n+            {\"to\": \"auth.Permission\", \"related_query_name\": \"foobar\", \"on_delete\": models.CASCADE}\n+        )\n+        # Test limit_choices_to\n+        field = models.OneToOneField(\"auth.Permission\", models.CASCADE, limit_choices_to={'foo': 'bar'})\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.OneToOneField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(\n+            kwargs,\n+            {\"to\": \"auth.Permission\", \"limit_choices_to\": {'foo': 'bar'}, \"on_delete\": models.CASCADE}\n+        )\n+        # Test unique\n+        field = models.OneToOneField(\"auth.Permission\", models.CASCADE, unique=True)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.OneToOneField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"on_delete\": models.CASCADE})\n+\n+    def test_image_field(self):\n+        field = models.ImageField(upload_to=\"foo/barness\", width_field=\"width\", height_field=\"height\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ImageField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"upload_to\": \"foo/barness\", \"width_field\": \"width\", \"height_field\": \"height\"})\n+\n+    def test_integer_field(self):\n+        field = models.IntegerField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.IntegerField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_ip_address_field(self):\n+        field = models.IPAddressField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.IPAddressField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_generic_ip_address_field(self):\n+        field = models.GenericIPAddressField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.GenericIPAddressField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+        field = models.GenericIPAddressField(protocol=\"IPv6\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.GenericIPAddressField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"protocol\": \"IPv6\"})\n+\n+    def test_many_to_many_field(self):\n+        # Test normal\n+        field = models.ManyToManyField(\"auth.Permission\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ManyToManyField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\"})\n+        self.assertFalse(hasattr(kwargs['to'], \"setting_name\"))\n+        # Test swappable\n+        field = models.ManyToManyField(\"auth.User\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ManyToManyField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.User\"})\n+        self.assertEqual(kwargs['to'].setting_name, \"AUTH_USER_MODEL\")\n+        # Test through\n+        field = models.ManyToManyField(\"auth.Permission\", through=\"auth.Group\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ManyToManyField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"through\": \"auth.Group\"})\n+        # Test custom db_table\n+        field = models.ManyToManyField(\"auth.Permission\", db_table=\"custom_table\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ManyToManyField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"db_table\": \"custom_table\"})\n+        # Test related_name\n+        field = models.ManyToManyField(\"auth.Permission\", related_name=\"custom_table\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ManyToManyField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"related_name\": \"custom_table\"})\n+        # Test related_query_name\n+        field = models.ManyToManyField(\"auth.Permission\", related_query_name=\"foobar\")\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ManyToManyField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"related_query_name\": \"foobar\"})\n+        # Test limit_choices_to\n+        field = models.ManyToManyField(\"auth.Permission\", limit_choices_to={'foo': 'bar'})\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.ManyToManyField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\", \"limit_choices_to\": {'foo': 'bar'}})\n+\n+    @override_settings(AUTH_USER_MODEL=\"auth.Permission\")\n+    def test_many_to_many_field_swapped(self):\n+        with isolate_lru_cache(apps.get_swappable_settings_name):\n+            # It doesn't matter that we swapped out user for permission;\n+            # there's no validation. We just want to check the setting stuff works.\n+            field = models.ManyToManyField(\"auth.Permission\")\n+            name, path, args, kwargs = field.deconstruct()\n+\n+        self.assertEqual(path, \"django.db.models.ManyToManyField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"to\": \"auth.Permission\"})\n+        self.assertEqual(kwargs['to'].setting_name, \"AUTH_USER_MODEL\")\n+\n+    def test_null_boolean_field(self):\n+        field = models.NullBooleanField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.NullBooleanField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_positive_integer_field(self):\n+        field = models.PositiveIntegerField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.PositiveIntegerField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_positive_small_integer_field(self):\n+        field = models.PositiveSmallIntegerField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.PositiveSmallIntegerField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_positive_big_integer_field(self):\n+        field = models.PositiveBigIntegerField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, 'django.db.models.PositiveBigIntegerField')\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_slug_field(self):\n+        field = models.SlugField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.SlugField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+        field = models.SlugField(db_index=False, max_length=231)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.SlugField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\"db_index\": False, \"max_length\": 231})\n+\n+    def test_small_integer_field(self):\n+        field = models.SmallIntegerField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.SmallIntegerField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_text_field(self):\n+        field = models.TextField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.TextField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_time_field(self):\n+        field = models.TimeField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, \"django.db.models.TimeField\")\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+        field = models.TimeField(auto_now=True)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {'auto_now': True})\n"], "arch": "x86_64", "base_commit": "89d41cba392b759732ba9f1db4ff29ed47da6a56", "test_directives": ["field_deconstruction.test_nested_field_deconstruction"], "coverage_files": ["django/db/migrations/serializer.py"], "env_name": "testbed", "run_id": "full_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/migrations/serializer\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 field_deconstruction.test_nested_field_deconstruction", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.2\nargon2-cffi >= 16.1.0\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}