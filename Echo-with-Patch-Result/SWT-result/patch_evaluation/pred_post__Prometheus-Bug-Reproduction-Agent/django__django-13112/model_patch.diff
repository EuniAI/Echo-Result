diff --git a/tests/migrations/test_foreign_key_deconstruction.py b/tests/migrations/test_foreign_key_deconstruction.py
new file mode 100644
index 0000000000..ca376b4295
--- /dev/null
+++ b/tests/migrations/test_foreign_key_deconstruction.py
@@ -0,0 +1,50 @@
+from django.db import models
+from django.db.migrations.state import ModelState, ProjectState
+from django.test import TestCase
+
+
+class MixedCaseAppLabelForeignKeyTests(TestCase):
+    def test_deconstruct_and_reconstruct_with_mixed_case_app(self):
+        """
+        Tests that a ForeignKey pointing to a model in an app with a mixed-case
+        label can be deconstructed and reconstructed without producing a state
+        that fails validation.
+        """
+        # 1. Define a ForeignKey to a model in a mixed-case app.
+        original_field = models.ForeignKey('DJ_RegLogin.Category', models.CASCADE)
+        original_field.set_attributes_from_name('category')
+
+        # 2. Deconstruct the field, simulating `makemigrations`.
+        # On unpatched code, this incorrectly lowercases the app label,
+        # resulting in kwargs['to'] = 'dj_reglogin.category'.
+        name, path, args, kwargs = original_field.deconstruct()
+
+        # 3. Reconstruct the field from the deconstructed parts.
+        reconstructed_field = models.ForeignKey(*args, **kwargs)
+
+        # 4. Build a project state using the reconstructed field.
+        state = ProjectState()
+        state.add_model(ModelState(
+            app_label='DJ_RegLogin',
+            name='Category',
+            fields=[('id', models.AutoField(primary_key=True))],
+        ))
+        state.add_model(ModelState(
+            app_label='DJ_RegLogin',
+            name='Content',
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('category', reconstructed_field),
+            ]
+        ))
+
+        # 5. Trigger state validation. This will raise a ValueError on
+        # unpatched code because the reconstructed field holds a lazy
+        # reference to 'dj_reglogin.category', but the only app available
+        # is 'DJ_RegLogin'. The patched code creates a correct reference,
+        # so no exception is raised.
+        _ = state.apps
+
+        # 6. If no error was raised, the test passes on patched code.
+        # This assertion confirms the models were correctly registered.
+        self.assertIn(('DJ_RegLogin', 'category'), state.models)
