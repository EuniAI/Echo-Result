{"instance_id": "django__django-13346", "repo": "django/django", "version": "3.2", "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d", "patch_list": ["diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -378,6 +378,30 @@ def as_sqlite(self, compiler, connection):\n         return super().as_sql(compiler, connection)\n \n \n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        if not connection.features.has_native_json_field:\n+            func = ()\n+            if connection.vendor == 'oracle':\n+                func = []\n+                for value in rhs_params:\n+                    value = json.loads(value)\n+                    function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'\n+                    func.append(\"%s('%s', '$.value')\" % (\n+                        function,\n+                        json.dumps({'value': value}),\n+                    ))\n+                func = tuple(func)\n+                rhs_params = ()\n+            elif connection.vendor == 'mysql' and connection.mysql_is_mariadb:\n+                func = (\"JSON_UNQUOTE(JSON_EXTRACT(%s, '$'))\",) * len(rhs_params)\n+            elif connection.vendor in {'sqlite', 'mysql'}:\n+                func = (\"JSON_EXTRACT(%s, '$')\",) * len(rhs_params)\n+            rhs = rhs % func\n+        return rhs, rhs_params\n+\n+\n class KeyTransformExact(JSONExact):\n     def process_lhs(self, compiler, connection):\n         lhs, lhs_params = super().process_lhs(compiler, connection)\n@@ -479,6 +503,7 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n", "diff --git a/model_fields/tests/test_jsonfield.py b/model_fields/tests/test_jsonfield.py\nnew file mode 100644\nindex 0000000000..1e5292bb1c\n--- /dev/null\n+++ b/model_fields/tests/test_jsonfield.py\n@@ -0,0 +1,505 @@\n+import operator\n+import uuid\n+from unittest import mock, skipIf\n+\n+from django import forms\n+from django.core import serializers\n+from django.core.exceptions import ValidationError\n+from django.core.serializers.json import DjangoJSONEncoder\n+from django.db import (\n+    DataError, IntegrityError, NotSupportedError, OperationalError, connection,\n+    models,\n+)\n+from django.db.models import Count, F, OuterRef, Q, Subquery, Transform, Value\n+from django.db.models.expressions import RawSQL\n+from django.db.models.fields.json import (\n+    KeyTextTransform, KeyTransform, KeyTransformFactory,\n+    KeyTransformTextLookupMixin,\n+)\n+from django.db.models.functions import Cast\n+from django.test import (\n+    SimpleTestCase, TestCase, skipIfDBFeature, skipUnlessDBFeature,\n+)\n+from django.test.utils import CaptureQueriesContext\n+\n+from .models import CustomJSONDecoder, JSONModel, NullableJSONModel\n+\n+\n+@skipUnlessDBFeature('supports_json_field')\n+class JSONFieldTests(TestCase):\n+    def test_invalid_value(self):\n+        msg = 'is not JSON serializable'\n+        with self.assertRaisesMessage(TypeError, msg):\n+            NullableJSONModel.objects.create(value={\n+                'uuid': uuid.UUID('d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475'),\n+            })\n+\n+    def test_custom_encoder_decoder(self):\n+        value = {'uuid': uuid.UUID('{d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475}')}\n+        obj = NullableJSONModel(value_custom=value)\n+        obj.clean_fields()\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.value_custom, value)\n+\n+    def test_db_check_constraints(self):\n+        value = '{@!invalid json value 123 $!@#}'\n+        with mock.patch.object(DjangoJSONEncoder, 'encode', return_value=value):\n+            with self.assertRaises((IntegrityError, DataError, OperationalError)):\n+                NullableJSONModel.objects.create(value_custom=value)\n+\n+\n+class TestMethods(SimpleTestCase):\n+    def test_deconstruct(self):\n+        field = models.JSONField()\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(path, 'django.db.models.JSONField')\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {})\n+\n+    def test_deconstruct_custom_encoder_decoder(self):\n+        field = models.JSONField(encoder=DjangoJSONEncoder, decoder=CustomJSONDecoder)\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(kwargs['encoder'], DjangoJSONEncoder)\n+        self.assertEqual(kwargs['decoder'], CustomJSONDecoder)\n+\n+    def test_get_transforms(self):\n+        @models.JSONField.register_lookup\n+        class MyTransform(Transform):\n+            lookup_name = 'my_transform'\n+        field = models.JSONField()\n+        transform = field.get_transform('my_transform')\n+        self.assertIs(transform, MyTransform)\n+        models.JSONField._unregister_lookup(MyTransform)\n+        models.JSONField._clear_cached_lookups()\n+        transform = field.get_transform('my_transform')\n+        self.assertIsInstance(transform, KeyTransformFactory)\n+\n+    def test_key_transform_text_lookup_mixin_non_key_transform(self):\n+        transform = Transform('test')\n+        msg = (\n+            'Transform should be an instance of KeyTransform in order to use '\n+            'this lookup.'\n+        )\n+        with self.assertRaisesMessage(TypeError, msg):\n+            KeyTransformTextLookupMixin(transform)\n+\n+\n+class TestValidation(SimpleTestCase):\n+    def test_invalid_encoder(self):\n+        msg = 'The encoder parameter must be a callable object.'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            models.JSONField(encoder=DjangoJSONEncoder())\n+\n+    def test_invalid_decoder(self):\n+        msg = 'The decoder parameter must be a callable object.'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            models.JSONField(decoder=CustomJSONDecoder())\n+\n+    def test_validation_error(self):\n+        field = models.JSONField()\n+        msg = 'Value must be valid JSON.'\n+        value = uuid.UUID('{d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475}')\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            field.clean({'uuid': value}, None)\n+\n+    def test_custom_encoder(self):\n+        field = models.JSONField(encoder=DjangoJSONEncoder)\n+        value = uuid.UUID('{d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475}')\n+        field.clean({'uuid': value}, None)\n+\n+\n+class TestFormField(SimpleTestCase):\n+    def test_formfield(self):\n+        model_field = models.JSONField()\n+        form_field = model_field.formfield()\n+        self.assertIsInstance(form_field, forms.JSONField)\n+\n+    def test_formfield_custom_encoder_decoder(self):\n+        model_field = models.JSONField(encoder=DjangoJSONEncoder, decoder=CustomJSONDecoder)\n+        form_field = model_field.formfield()\n+        self.assertIs(form_field.encoder, DjangoJSONEncoder)\n+        self.assertIs(form_field.decoder, CustomJSONDecoder)\n+\n+\n+class TestSerialization(SimpleTestCase):\n+    test_data = (\n+        '[{\"fields\": {\"value\": %s}, '\n+        '\"model\": \"model_fields.jsonmodel\", \"pk\": null}]'\n+    )\n+    test_values = (\n+        # (Python value, serialized value),\n+        ({'a': 'b', 'c': None}, '{\"a\": \"b\", \"c\": null}'),\n+        ('abc', '\"abc\"'),\n+        ('{\"a\": \"a\"}', '\"{\\\"a\\\": \\\"a\\\"}\"'),\n+    )\n+\n+    def test_dumping(self):\n+        for value, serialized in self.test_values:\n+            with self.subTest(value=value):\n+                instance = JSONModel(value=value)\n+                data = serializers.serialize('json', [instance])\n+                self.assertJSONEqual(data, self.test_data % serialized)\n+\n+    def test_loading(self):\n+        for value, serialized in self.test_values:\n+            with self.subTest(value=value):\n+                instance = list(\n+                    serializers.deserialize('json', self.test_data % serialized)\n+                )[0].object\n+                self.assertEqual(instance.value, value)\n+\n+    def test_xml_serialization(self):\n+        test_xml_data = (\n+            '<django-objects version=\"1.0\">'\n+            '<object model=\"model_fields.nullablejsonmodel\">'\n+            '<field name=\"value\" type=\"JSONField\">%s'\n+            '</field></object></django-objects>'\n+        )\n+        for value, serialized in self.test_values:\n+            with self.subTest(value=value):\n+                instance = NullableJSONModel(value=value)\n+                data = serializers.serialize('xml', [instance], fields=['value'])\n+                self.assertXMLEqual(data, test_xml_data % serialized)\n+                new_instance = list(serializers.deserialize('xml', data))[0].object\n+                self.assertEqual(new_instance.value, instance.value)\n+\n+\n+@skipUnlessDBFeature('supports_json_field')\n+class TestSaveLoad(TestCase):\n+    def test_null(self):\n+        obj = NullableJSONModel(value=None)\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    @skipUnlessDBFeature('supports_primitives_in_json_field')\n+    def test_json_null_different_from_sql_null(self):\n+        json_null = NullableJSONModel.objects.create(value=Value('null'))\n+        json_null.refresh_from_db()\n+        sql_null = NullableJSONModel.objects.create(value=None)\n+        sql_null.refresh_from_db()\n+        # 'null' is not equal to NULL in the database.\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value=Value('null')),\n+            [json_null],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value=None),\n+            [json_null],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True),\n+            [sql_null],\n+        )\n+        # 'null' is equal to NULL in Python (None).\n+        self.assertEqual(json_null.value, sql_null.value)\n+\n+    @skipUnlessDBFeature('supports_primitives_in_json_field')\n+    def test_primitives(self):\n+        values = [\n+            True,\n+            1,\n+            1.45,\n+            'String',\n+            '',\n+        ]\n+        for value in values:\n+            with self.subTest(value=value):\n+                obj = JSONModel(value=value)\n+                obj.save()\n+                obj.refresh_from_db()\n+                self.assertEqual(obj.value, value)\n+\n+    def test_dict(self):\n+        values = [\n+            {},\n+            {'name': 'John', 'age': 20, 'height': 180.3},\n+            {'a': True, 'b': {'b1': False, 'b2': None}},\n+        ]\n+        for value in values:\n+            with self.subTest(value=value):\n+                obj = JSONModel.objects.create(value=value)\n+                obj.refresh_from_db()\n+                self.assertEqual(obj.value, value)\n+\n+    def test_list(self):\n+        values = [\n+            [],\n+            ['John', 20, 180.3],\n+            [True, [False, None]],\n+        ]\n+        for value in values:\n+            with self.subTest(value=value):\n+                obj = JSONModel.objects.create(value=value)\n+                obj.refresh_from_db()\n+                self.assertEqual(obj.value, value)\n+\n+    def test_realistic_object(self):\n+        value = {\n+            'name': 'John',\n+            'age': 20,\n+            'pets': [\n+                {'name': 'Kit', 'type': 'cat', 'age': 2},\n+                {'name': 'Max', 'type': 'dog', 'age': 1},\n+            ],\n+            'courses': [\n+                ['A1', 'A2', 'A3'],\n+                ['B1', 'B2'],\n+                ['C1'],\n+            ],\n+        }\n+        obj = JSONModel.objects.create(value=value)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.value, value)\n+\n+\n+@skipUnlessDBFeature('supports_json_field')\n+class TestQuerying(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.primitives = [True, False, 'yes', 7, 9.6]\n+        values = [\n+            None,\n+            [],\n+            {},\n+            {'a': 'b', 'c': 14},\n+            {\n+                'a': 'b',\n+                'c': 14,\n+                'd': ['e', {'f': 'g'}],\n+                'h': True,\n+                'i': False,\n+                'j': None,\n+                'k': {'l': 'm'},\n+                'n': [None],\n+            },\n+            [1, [2]],\n+            {'k': True, 'l': False},\n+            {\n+                'foo': 'bar',\n+                'baz': {'a': 'b', 'c': 'd'},\n+                'bar': ['foo', 'bar'],\n+                'bax': {'foo': 'bar'},\n+            },\n+        ]\n+        cls.objs = [\n+            NullableJSONModel.objects.create(value=value)\n+            for value in values\n+        ]\n+        if connection.features.supports_primitives_in_json_field:\n+            cls.objs.extend([\n+                NullableJSONModel.objects.create(value=value)\n+                for value in cls.primitives\n+            ])\n+        cls.raw_sql = '%s::jsonb' if connection.vendor == 'postgresql' else '%s'\n+\n+    def test_exact(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__exact={}),\n+            [self.objs[2]],\n+        )\n+\n+    def test_exact_complex(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__exact={'a': 'b', 'c': 14}),\n+            [self.objs[3]],\n+        )\n+\n+    def test_isnull(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True),\n+            [self.objs[0]],\n+        )\n+\n+    def test_key_in_lookup(self):\n+        self.assertCountEqual(\n+            NullableJSONModel.objects.filter(value__c__in=[14]),\n+            [self.objs[3], self.objs[4]],\n+        )\n+\n+    def test_ordering_by_transform(self):\n+        objs = [\n+            NullableJSONModel.objects.create(value={'ord': 93, 'name': 'bar'}),\n+            NullableJSONModel.objects.create(value={'ord': 22.1, 'name': 'foo'}),\n+            NullableJSONModel.objects.create(value={'ord': -1, 'name': 'baz'}),\n+            NullableJSONModel.objects.create(value={'ord': 21.931902, 'name': 'spam'}),\n+            NullableJSONModel.objects.create(value={'ord': -100291029, 'name': 'eggs'}),\n+        ]\n+        query = NullableJSONModel.objects.filter(value__name__isnull=False).order_by('value__ord')\n+        expected = [objs[4], objs[2], objs[3], objs[1], objs[0]]\n+        mariadb = connection.vendor == 'mysql' and connection.mysql_is_mariadb\n+        if mariadb or connection.vendor == 'oracle':\n+            # MariaDB and Oracle return JSON values as strings.\n+            expected = [objs[2], objs[4], objs[3], objs[1], objs[0]]\n+        self.assertSequenceEqual(query, expected)\n+\n+    def test_ordering_grouping_by_key_transform(self):\n+        base_qs = NullableJSONModel.objects.filter(value__d__0__isnull=False)\n+        for qs in (\n+            base_qs.order_by('value__d__0'),\n+            base_qs.annotate(key=KeyTransform('0', KeyTransform('d', 'value'))).order_by('key'),\n+        ):\n+            self.assertSequenceEqual(qs, [self.objs[4]])\n+        qs = NullableJSONModel.objects.filter(value__isnull=False)\n+        self.assertQuerysetEqual(\n+            qs.filter(value__isnull=False).annotate(\n+                key=KeyTextTransform('f', KeyTransform('1', KeyTransform('d', 'value'))),\n+            ).values('key').annotate(count=Count('key')).order_by('count'),\n+            [(None, 0), ('g', 1)],\n+            operator.itemgetter('key', 'count'),\n+        )\n+\n+    @skipIf(connection.vendor == 'oracle', \"Oracle doesn't support grouping by LOBs, see #24096.\")\n+    def test_ordering_grouping_by_count(self):\n+        qs = NullableJSONModel.objects.filter(\n+            value__isnull=False,\n+        ).values('value__d__0').annotate(count=Count('value__d__0')).order_by('count')\n+        self.assertQuerysetEqual(qs, [1, 11], operator.itemgetter('count'))\n+\n+    def test_key_transform_raw_expression(self):\n+        expr = RawSQL(self.raw_sql, ['{\"x\": \"bar\"}'])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__foo=KeyTransform('x', expr)),\n+            [self.objs[7]],\n+        )\n+\n+    def test_nested_key_transform_raw_expression(self):\n+        expr = RawSQL(self.raw_sql, ['{\"x\": {\"y\": \"bar\"}}'])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__foo=KeyTransform('y', KeyTransform('x', expr))),\n+            [self.objs[7]],\n+        )\n+\n+    def test_key_transform_expression(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__0__isnull=False).annotate(\n+                key=KeyTransform('d', 'value'),\n+                chain=KeyTransform('0', 'key'),\n+                expr=KeyTransform('0', Cast('key', models.JSONField())),\n+            ).filter(chain=F('expr')),\n+            [self.objs[4]],\n+        )\n+\n+    def test_nested_key_transform_expression(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__0__isnull=False).annotate(\n+                key=KeyTransform('d', 'value'),\n+                chain=KeyTransform('f', KeyTransform('1', 'key')),\n+                expr=KeyTransform('f', KeyTransform('1', Cast('key', models.JSONField()))),\n+            ).filter(chain=F('expr')),\n+            [self.objs[4]],\n+        )\n+\n+    def test_has_key(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_key='a'),\n+            [self.objs[3], self.objs[4]],\n+        )\n+\n+    def test_has_key_null_value(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_key='j'),\n+            [self.objs[4]],\n+        )\n+\n+    def test_has_key_deep(self):\n+        tests = [\n+            (Q(value__baz__has_key='a'), self.objs[7]),\n+            (Q(value__has_key=KeyTransform('a', KeyTransform('baz', 'value'))), self.objs[7]),\n+            (Q(value__has_key=KeyTransform('c', KeyTransform('baz', 'value'))), self.objs[7]),\n+            (Q(value__d__1__has_key='f'), self.objs[4]),\n+            (\n+                Q(value__has_key=KeyTransform('f', KeyTransform('1', KeyTransform('d', 'value')))),\n+                self.objs[4],\n+            )\n+        ]\n+        for condition, expected in tests:\n+            with self.subTest(condition=condition):\n+                self.assertSequenceEqual(\n+                    NullableJSONModel.objects.filter(condition),\n+                    [expected],\n+                )\n+\n+    def test_has_key_list(self):\n+        obj = NullableJSONModel.objects.create(value=[{'a': 1}, {'b': 'x'}])\n+        tests = [\n+            Q(value__1__has_key='b'),\n+            Q(value__has_key=KeyTransform('b', KeyTransform(1, 'value'))),\n+            Q(value__has_key=KeyTransform('b', KeyTransform('1', 'value'))),\n+        ]\n+        for condition in tests:\n+            with self.subTest(condition=condition):\n+                self.assertSequenceEqual(\n+                    NullableJSONModel.objects.filter(condition),\n+                    [obj],\n+                )\n+\n+    def test_has_keys(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_keys=['a', 'c', 'h']),\n+            [self.objs[4]],\n+        )\n+\n+    def test_has_any_keys(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_any_keys=['c', 'l']),\n+            [self.objs[3], self.objs[4], self.objs[6]],\n+        )\n+\n+    @skipUnlessDBFeature('supports_json_field_contains')\n+    def test_contains(self):\n+        tests = [\n+            ({}, self.objs[2:5] + self.objs[6:8]),\n+            ({'baz': {'a': 'b', 'c': 'd'}}, [self.objs[7]]),\n+            ({'baz': {'a': 'b'}}, [self.objs[7]]),\n+            ({'baz': {'c': 'd'}}, [self.objs[7]]),\n+            ({'k': True, 'l': False}, [self.objs[6]]),\n+            ({'d': ['e', {'f': 'g'}]}, [self.objs[4]]),\n+            ({'d': ['e']}, [self.objs[4]]),\n+            ({'d': [{'f': 'g'}]}, [self.objs[4]]),\n+            ([1, [2]], [self.objs[5]]),\n+            ([1], [self.objs[5]]),\n+            ([[2]], [self.objs[5]]),\n+            ({'n': [None]}, [self.objs[4]]),\n+            ({'j': None}, [self.objs[4]]),\n+        ]\n+        for value, expected in tests:\n+            with self.subTest(value=value):\n+                qs = NullableJSONModel.objects.filter(value__contains=value)\n+                selfse.assertSequenceEqual(qs, expected)\n+\n+    @skipIfDBFeature('supports_json_field_contains')\n+    def test_contains_unsupported(self):\n+        msg = 'contains lookup is not supported on this database backend.'\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            NullableJSONModel.objects.filter(\n+                value__contains={'baz': {'a': 'b', 'c': 'd'}},\n+            ).get()\n+\n+    @skipUnlessDBFeature(\n+        'supports_primitives_in_json_field',\n+        'supports_json_field_contains',\n+    )\n+    def test_contains_primitives(self):\n+        for value in self.primitives:\n+            with self.subTest(value=value):\n+                qs = NullableJSONModel.objects.filter(value__contains=value)\n+                self.assertIs(qs.exists(), True)\n+\n+    @skipUnlessDBFeature('supports_json_field_contains')\n+    def test_contained_by(self):\n+        qs = NullableJSONModel.objects.filter(value__contained_by={'a': 'b', 'c': 14, 'h': True})\n+        self.assertSequenceEqual(qs, self.objs[2:4])\n+\n+    @skipIfDBFeature('supports_json_field_contains')\n+    def test_contained_by_unsupported(self):\n+        msg = 'contained_by lookup is not supported on this database backend.'\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            NullableJSONModel.objects.filter(value__contained_by={'a': 'b'}).get()\n+\n+    def test_deep_values(self):\n+        qs = NullableJSONModel.objects.values_list('value__k__l')\n+        expected_objs = [(None,)] * len(self.objs)\n+        expected_objs[4] = ('m',)\n+        self.assertSequenceEqual(qs, expected_objs)\n"], "arch": "x86_64", "base_commit": "9c92924cd5d164701e2514e1c2d6574126bd7cc2", "test_directives": ["model_fields.tests.test_jsonfield"], "coverage_files": ["django/db/models/fields/json.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/models/fields/json\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 model_fields.tests.test_jsonfield", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}