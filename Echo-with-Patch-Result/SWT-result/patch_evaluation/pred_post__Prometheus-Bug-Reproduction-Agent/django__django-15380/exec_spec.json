{"instance_id": "django__django-15380", "repo": "django/django", "version": "4.1", "environment_setup_commit": "647480166bfe7532e8c471fef0146e3a17e6c0c9", "patch_list": ["diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -824,7 +824,7 @@ def generate_renamed_fields(self):\n         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n             old_model_state = self.from_state.models[app_label, old_model_name]\n-            new_model_state = self.to_state.models[app_label, old_model_name]\n+            new_model_state = self.to_state.models[app_label, model_name]\n             field = new_model_state.get_field(field_name)\n             # Scan to see if this is actually a rename!\n             field_dec = self.deep_deconstruct(field)\n", "diff --git a/tests/migrations/test_rename_model_and_field.py b/tests/migrations/test_rename_model_and_field.py\nnew file mode 100644\nindex 0000000000..6a89b438b8\n--- /dev/null\n+++ b/tests/migrations/test_rename_model_and_field.py\n@@ -0,0 +1,126 @@\n+import unittest\n+\n+from django.db import models\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.questioner import MigrationQuestioner\n+from django.db.migrations.state import ModelState, ProjectState\n+from django.test import TestCase\n+\n+\n+class RenameModelAndFieldAutodetectorTests(TestCase):\n+    \"\"\"\n+    Tests the migration autodetector for model and field renames.\n+    \"\"\"\n+\n+    def repr_changes(self, changes):\n+        output = \"\"\n+        for app_label, migrations_ in sorted(changes.items()):\n+            output += \"  %s:\\n\" % app_label\n+            for migration in migrations_:\n+                output += \"    %s\\n\" % migration.name\n+                for operation in migration.operations:\n+                    output += \"      %s\\n\" % operation\n+        return output\n+\n+    def assertNumberMigrations(self, changes, app_label, number):\n+        if len(changes.get(app_label, [])) != number:\n+            self.fail(\"Incorrect number of migrations (%s) for %s (expected %s)\\n%s\" % (\n+                len(changes.get(app_label, [])),\n+                app_label,\n+                number,\n+                self.repr_changes(changes),\n+            ))\n+\n+    def assertOperationTypes(self, changes, app_label, position, types):\n+        if not changes.get(app_label):\n+            self.fail(\"No migrations found for %s\\n%s\" % (app_label, self.repr_changes(changes)))\n+        if len(changes[app_label]) < position + 1:\n+            self.fail(\"No migration at index %s for %s\\n%s\" % (position, app_label, self.repr_changes(changes)))\n+        migration = changes[app_label][position]\n+        real_types = [operation.__class__.__name__ for operation in migration.operations]\n+        if types != real_types:\n+            self.fail(\"Operation type mismatch for %s.%s (expected %s):\\n%s\" % (\n+                app_label,\n+                migration.name,\n+                types,\n+                self.repr_changes(changes),\n+            ))\n+\n+    def assertOperationAttributes(self, changes, app_label, position, operation_position, **attrs):\n+        if not changes.get(app_label):\n+            self.fail(\"No migrations found for %s\\n%s\" % (app_label, self.repr_changes(changes)))\n+        if len(changes[app_label]) < position + 1:\n+            self.fail(\"No migration at index %s for %s\\n%s\" % (position, app_label, self.repr_changes(changes)))\n+        migration = changes[app_label][position]\n+        if len(migration.operations) < operation_position + 1:\n+            self.fail(\"No operation at index %s for %s.%s\\n%s\" % (\n+                operation_position,\n+                app_label,\n+                migration.name,\n+                self.repr_changes(changes),\n+            ))\n+        operation = migration.operations[operation_position]\n+        for attr, value in attrs.items():\n+            if getattr(operation, attr, None) != value:\n+                self.fail(\"Attribute mismatch for %s.%s op #%s, %s (expected %r, got %r):\\n%s\" % (\n+                    app_label,\n+                    migration.name,\n+                    operation_position,\n+                    attr,\n+                    value,\n+                    getattr(operation, attr, None),\n+                    self.repr_changes(changes),\n+                ))\n+\n+    def make_project_state(self, model_states):\n+        \"Shortcut to make ProjectStates from lists of predefined models\"\n+        project_state = ProjectState()\n+        for model_state in model_states:\n+            project_state.add_model(model_state.clone())\n+        return project_state\n+\n+    def get_changes(self, before_states, after_states, questioner=None):\n+        if not isinstance(before_states, ProjectState):\n+            before_states = self.make_project_state(before_states)\n+        if not isinstance(after_states, ProjectState):\n+            after_states = self.make_project_state(after_states)\n+        return MigrationAutodetector(\n+            before_states,\n+            after_states,\n+            questioner,\n+        )._detect_changes()\n+\n+    def test_rename_model_and_field(self):\n+        \"\"\"\n+        The autodetector shouldn't crash when a model and a field on it are\n+        renamed.\n+        \"\"\"\n+        before_states = self.make_project_state([\n+            ModelState(\n+                'test_one', 'MyModel', [\n+                    ('id', models.AutoField(primary_key=True)),\n+                    ('field_one', models.IntegerField()),\n+                ],\n+            ),\n+        ])\n+        after_states = self.make_project_state([\n+            ModelState(\n+                'test_one', 'MyModel2', [\n+                    ('id', models.AutoField(primary_key=True)),\n+                    ('field_two', models.IntegerField()),\n+                ],\n+            ),\n+        ])\n+        questioner = MigrationQuestioner({'ask_rename_model': True, 'ask_rename': True})\n+        changes = self.get_changes(before_states, after_states, questioner=questioner)\n+        self.assertNumberMigrations(changes, 'test_one', 1)\n+        self.assertOperationTypes(changes, 'test_one', 0, ['RenameModel', 'RenameField'])\n+        self.assertOperationAttributes(\n+            changes, 'test_one', 0, 0, old_name='MyModel', new_name='MyModel2',\n+        )\n+        self.assertOperationAttributes(\n+            changes, 'test_one', 0, 1,\n+            model_name='mymodel2',\n+            old_name='field_one',\n+            new_name='field_two',\n+        )\n\\ No newline at end of file\n"], "arch": "x86_64", "base_commit": "71e7c8e73712419626f1c2b6ec036e8559a2d667", "test_directives": ["migrations.test_rename_model_and_field"], "coverage_files": ["django/db/migrations/autodetector.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.9", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/migrations/autodetector\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 migrations.test_rename_model_and_field", "req_install_commands": ["conda create -n testbed python=3.9 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\naiosmtpd\nasgiref >= 3.4.1\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\nblack\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}