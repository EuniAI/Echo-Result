{"instance_id": "django__django-16901", "repo": "django/django", "version": "5.0", "environment_setup_commit": "4a72da71001f154ea60906a2f74898d32b7322a7", "patch_list": ["diff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -6,6 +6,7 @@\n \n from django.core.exceptions import EmptyResultSet, FullResultSet\n from django.db.models.expressions import Case, When\n+from django.db.models.functions import Mod\n from django.db.models.lookups import Exact\n from django.utils import tree\n from django.utils.functional import cached_property\n@@ -129,12 +130,16 @@ def as_sql(self, compiler, connection):\n             # Convert if the database doesn't support XOR:\n             #   a XOR b XOR c XOR ...\n             # to:\n-            #   (a OR b OR c OR ...) AND (a + b + c + ...) == 1\n+            #   (a OR b OR c OR ...) AND MOD(a + b + c + ..., 2) == 1\n+            # The result of an n-ary XOR is true when an odd number of operands\n+            # are true.\n             lhs = self.__class__(self.children, OR)\n             rhs_sum = reduce(\n                 operator.add,\n                 (Case(When(c, then=1), default=0) for c in self.children),\n             )\n+            if len(self.children) > 2:\n+                rhs_sum = Mod(rhs_sum, 2)\n             rhs = Exact(1, rhs_sum)\n             return self.__class__([lhs, rhs], AND, self.negated).as_sql(\n                 compiler, connection\n", "diff --git a/tests/queries/test_q_expressions.py b/tests/queries/test_q_expressions.py\nnew file mode 100644\nindex 0000000000..082cea9762\n--- /dev/null\n+++ b/tests/queries/test_q_expressions.py\n@@ -0,0 +1,283 @@\n+from unittest.mock import patch\n+\n+from django.core.exceptions import FieldError\n+from django.db import connection\n+from django.db.models import (\n+    BooleanField,\n+    Exists,\n+    ExpressionWrapper,\n+    F,\n+    OuterRef,\n+    Q,\n+    Value,\n+)\n+from django.db.models.expressions import NegatedExpression, RawSQL\n+from django.db.models.functions import Lower\n+from django.db.models.sql.where import NothingNode\n+from django.test import SimpleTestCase, TestCase\n+\n+from .models import Tag\n+\n+\n+class QTests(SimpleTestCase):\n+    def test_combine_and_empty(self):\n+        q = Q(x=1)\n+        self.assertEqual(q & Q(), q)\n+        self.assertEqual(Q() & q, q)\n+\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q & Q(), q)\n+        self.assertEqual(Q() & q, q)\n+\n+    def test_combine_and_both_empty(self):\n+        self.assertEqual(Q() & Q(), Q())\n+\n+    def test_combine_or_empty(self):\n+        q = Q(x=1)\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n+\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n+\n+    def test_combine_xor_empty(self):\n+        q = Q(x=1)\n+        self.assertEqual(q ^ Q(), q)\n+        self.assertEqual(Q() ^ q, q)\n+\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q ^ Q(), q)\n+        self.assertEqual(Q() ^ q, q)\n+\n+    def test_combine_empty_copy(self):\n+        base_q = Q(x=1)\n+        tests = [\n+            base_q | Q(),\n+            Q() | base_q,\n+            base_q & Q(),\n+            Q() & base_q,\n+            base_q ^ Q(),\n+            Q() ^ base_q,\n+        ]\n+        for i, q in enumerate(tests):\n+            with self.subTest(i=i):\n+                self.assertEqual(q, base_q)\n+                self.assertIsNot(q, base_q)\n+\n+    def test_combine_or_both_empty(self):\n+        self.assertEqual(Q() | Q(), Q())\n+\n+    def test_combine_xor_both_empty(self):\n+        self.assertEqual(Q() ^ Q(), Q())\n+\n+    def test_combine_not_q_object(self):\n+        obj = object()\n+        q = Q(x=1)\n+        with self.assertRaisesMessage(TypeError, str(obj)):\n+            q | obj\n+        with self.assertRaisesMessage(TypeError, str(obj)):\n+            q & obj\n+        with self.assertRaisesMessage(TypeError, str(obj)):\n+            q ^ obj\n+\n+    def test_combine_negated_boolean_expression(self):\n+        tagged = Tag.objects.filter(category=OuterRef(\"pk\"))\n+        tests = [\n+            Q() & ~Exists(tagged),\n+            Q() | ~Exists(tagged),\n+            Q() ^ ~Exists(tagged),\n+        ]\n+        for q in tests:\n+            with self.subTest(q=q):\n+                self.assertIsInstance(q, NegatedExpression)\n+\n+    def test_deconstruct(self):\n+        q = Q(price__gt=F(\"discounted_price\"))\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(path, \"django.db.models.Q\")\n+        self.assertEqual(args, ((\"price__gt\", F(\"discounted_price\")),))\n+        self.assertEqual(kwargs, {})\n+\n+    def test_deconstruct_negated(self):\n+        q = ~Q(price__gt=F(\"discounted_price\"))\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(args, ((\"price__gt\", F(\"discounted_price\")),))\n+        self.assertEqual(kwargs, {\"_negated\": True})\n+\n+    def test_deconstruct_or(self):\n+        q1 = Q(price__gt=F(\"discounted_price\"))\n+        q2 = Q(price=F(\"discounted_price\"))\n+        q = q1 | q2\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(\n+            args,\n+            (\n+                (\"price__gt\", F(\"discounted_price\")),\n+                (\"price\", F(\"discounted_price\")),\n+            ),\n+        )\n+        self.assertEqual(kwargs, {\"_connector\": Q.OR})\n+\n+    def test_deconstruct_xor(self):\n+        q1 = Q(price__gt=F(\"discounted_price\"))\n+        q2 = Q(price=F(\"discounted_price\"))\n+        q = q1 ^ q2\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(\n+            args,\n+            (\n+                (\"price__gt\", F(\"discounted_price\")),\n+                (\"price\", F(\"discounted_price\")),\n+            ),\n+        )\n+        self.assertEqual(kwargs, {\"_connector\": Q.XOR})\n+\n+    def test_deconstruct_and(self):\n+        q1 = Q(price__gt=F(\"discounted_price\"))\n+        q2 = Q(price=F(\"discounted_price\"))\n+        q = q1 & q2\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(\n+            args,\n+            (\n+                (\"price__gt\", F(\"discounted_price\")),\n+                (\"price\", F(\"discounted_price\")),\n+            ),\n+        )\n+        self.assertEqual(kwargs, {})\n+\n+    def test_deconstruct_multiple_kwargs(self):\n+        q = Q(price__gt=F(\"discounted_price\"), price=F(\"discounted_price\"))\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(\n+            args,\n+            (\n+                (\"price\", F(\"discounted_price\")),\n+                (\"price__gt\", F(\"discounted_price\")),\n+            ),\n+        )\n+        self.assertEqual(kwargs, {})\n+\n+    def test_deconstruct_nested(self):\n+        q = Q(Q(price__gt=F(\"discounted_price\")))\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(args, (Q(price__gt=F(\"discounted_price\")),))\n+        self.assertEqual(kwargs, {})\n+\n+    def test_deconstruct_boolean_expression(self):\n+        expr = RawSQL(\"1 = 1\", BooleanField())\n+        q = Q(expr)\n+        _, args, kwargs = q.deconstruct()\n+        self.assertEqual(args, (expr,))\n+        self.assertEqual(kwargs, {})\n+\n+    def test_reconstruct(self):\n+        q = Q(price__gt=F(\"discounted_price\"))\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(Q(*args, **kwargs), q)\n+\n+    def test_reconstruct_negated(self):\n+        q = ~Q(price__gt=F(\"discounted_price\"))\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(Q(*args, **kwargs), q)\n+\n+    def test_reconstruct_or(self):\n+        q1 = Q(price__gt=F(\"discounted_price\"))\n+        q2 = Q(price=F(\"discounted_price\"))\n+        q = q1 | q2\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(Q(*args, **kwargs), q)\n+\n+    def test_reconstruct_xor(self):\n+        q1 = Q(price__gt=F(\"discounted_price\"))\n+        q2 = Q(price=F(\"discounted_price\"))\n+        q = q1 ^ q2\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(Q(*args, **kwargs), q)\n+\n+    def test_reconstruct_and(self):\n+        q1 = Q(price__gt=F(\"discounted_price\"))\n+        q2 = Q(price=F(\"discounted_price\"))\n+        q = q1 & q2\n+        path, args, kwargs = q.deconstruct()\n+        self.assertEqual(Q(*args, **kwargs), q)\n+\n+    def test_flatten(self):\n+        q = Q()\n+        self.assertEqual(list(q.flatten()), [q])\n+        q = Q(NothingNode())\n+        self.assertEqual(list(q.flatten()), [q, q.children[0]])\n+        q = Q(\n+            ExpressionWrapper(\n+                Q(RawSQL(\"id = 0\", params=(), output_field=BooleanField()))\n+                | Q(price=Value(\"4.55\"))\n+                | Q(name=Lower(\"category\")),\n+                output_field=BooleanField(),\n+            )\n+        )\n+        flatten = list(q.flatten())\n+        self.assertEqual(len(flatten), 7)\n+\n+    def test_create_helper(self):\n+        items = [(\"a\", 1), (\"b\", 2), (\"c\", 3)]\n+        for connector in [Q.AND, Q.OR, Q.XOR]:\n+            with self.subTest(connector=connector):\n+                self.assertEqual(\n+                    Q.create(items, connector=connector),\n+                    Q(*items, _connector=connector),\n+                )\n+\n+\n+class QXorTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.tag = Tag.objects.create(name=\"t1\")\n+\n+    @patch.object(connection.features, \"supports_logical_xor\", False)\n+    def test_chained_xor(self):\n+        \"\"\"\n+        Chained Q.__xor__ operations are compiled correctly on databases that\n+        don't support XOR.\n+        \"\"\"\n+        q = Q(pk=self.tag.pk)\n+        # On dbs without native XOR, a ^ b ^ c should be interpreted as\n+        # \"an odd number are true\", not \"exactly one is true\".\n+        self.assertEqual(Tag.objects.filter(q ^ q ^ q).count(), 1)\n+\n+\n+class QCheckTests(TestCase):\n+    def test_basic(self):\n+        q = Q(price__gt=20)\n+        self.assertIs(q.check({\"price\": 30}), True)\n+        self.assertIs(q.check({\"price\": 10}), False)\n+\n+    def test_expression(self):\n+        q = Q(name=\"test\")\n+        self.assertIs(q.check({\"name\": Lower(Value(\"TeSt\"))}), True)\n+        self.assertIs(q.check({\"name\": Value(\"other\")}), False)\n+\n+    def test_missing_field(self):\n+        q = Q(description__startswith=\"prefix\")\n+        msg = \"Cannot resolve keyword 'description' into field.\"\n+        with self.assertRaisesMessage(FieldError, msg):\n+            q.check({\"name\": \"test\"})\n+\n+    def test_boolean_expression(self):\n+        q = Q(ExpressionWrapper(Q(price__gt=20), output_field=BooleanField()))\n+        self.assertIs(q.check({\"price\": 25}), True)\n+        self.assertIs(q.check({\"price\": Value(10)}), False)\n+\n+    def test_rawsql(self):\n+        \"\"\"\n+        RawSQL expressions cause a database error because \"price\" cannot be\n+        replaced by its value. In this case, Q.check() logs a warning and\n+        return True.\n+        \"\"\"\n+        q = Q(RawSQL(\"price > %s\", params=(20,), output_field=BooleanField()))\n+        with self.assertLogs(\"django.db.models\", \"WARNING\") as cm:\n+            self.assertIs(q.check({\"price\": 10}), True)\n+        self.assertIn(\n+            f\"Got a database error calling check() on {q!r}: \",\n+            cm.records[0].getMessage(),\n+        )\n"], "arch": "x86_64", "base_commit": "ee36e101e8f8c0acde4bb148b738ab7034e902a0", "test_directives": ["queries.test_q_expressions"], "coverage_files": ["django/db/models/sql/where.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.11", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/models/sql/where\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 queries.test_q_expressions", "req_install_commands": ["conda create -n testbed python=3.11 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\naiosmtpd\nasgiref >= 3.7.0\nargon2-cffi >= 19.2.0\nbcrypt\nblack\ndocutils\ngeoip2; python_version < '3.12'\njinja2 >= 2.11.0\nnumpy; python_version < '3.12'\nPillow >= 6.2.1; sys.platform != 'win32' or python_version < '3.12'\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.4.0\nselenium >= 4.8.0\nsqlparse >= 0.3.1\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}