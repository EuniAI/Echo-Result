diff --git a/tests/management/test_prog_name.py b/tests/management/test_prog_name.py
new file mode 100644
index 0000000000..bdfa3c8c0c
--- /dev/null
+++ b/tests/management/test_prog_name.py
@@ -0,0 +1,41 @@
+import sys
+from io import StringIO
+from unittest.mock import patch
+
+from django.core.management import ManagementUtility
+from django.test import SimpleTestCase
+
+
+class ManagementUtilityProgNameTests(SimpleTestCase):
+    @patch('sys.stdout', new_callable=StringIO)
+    def test_prog_name_passed_to_preliminary_parser(self, mock_stdout):
+        """
+        ManagementUtility passes the computed prog_name to the preliminary
+        CommandParser, so it doesn't fall back to using sys.argv.
+        """
+        argv = ['custom_prog', 'check', '--help']
+        utility = ManagementUtility(argv)
+        raised_type_error = False
+
+        with patch('sys.argv', [None]):
+            try:
+                # On patched code, this raises SystemExit after printing help.
+                # On unpatched code, this raises TypeError before SystemExit.
+                with self.assertRaises(SystemExit):
+                    utility.execute()
+            except TypeError:
+                # This is the bug we expect to see on the unpatched code.
+                # We catch it and convert it into a test failure.
+                raised_type_error = True
+
+        # This assertion will fail on the old code (since raised_type_error
+        # will be True) and pass on the new code (since it will be False).
+        self.assertFalse(
+            raised_type_error,
+            "TypeError was raised because ManagementUtility did not pass "
+            "prog_name to its preliminary CommandParser."
+        )
+        # This assertion confirms the fix works correctly on the new code by
+        # checking the output, which is only generated if the TypeError is not
+        # raised.
+        self.assertIn('usage: custom_prog subcommand [options] [args]', mock_stdout.getvalue())
