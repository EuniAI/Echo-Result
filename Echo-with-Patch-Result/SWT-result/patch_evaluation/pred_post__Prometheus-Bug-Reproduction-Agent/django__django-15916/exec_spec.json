{"instance_id": "django__django-15916", "repo": "django/django", "version": "4.2", "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5", "patch_list": ["diff --git a/django/forms/models.py b/django/forms/models.py\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -253,18 +253,11 @@ def __init__(self, options=None):\n         self.help_texts = getattr(options, \"help_texts\", None)\n         self.error_messages = getattr(options, \"error_messages\", None)\n         self.field_classes = getattr(options, \"field_classes\", None)\n+        self.formfield_callback = getattr(options, \"formfield_callback\", None)\n \n \n class ModelFormMetaclass(DeclarativeFieldsMetaclass):\n     def __new__(mcs, name, bases, attrs):\n-        base_formfield_callback = None\n-        for b in bases:\n-            if hasattr(b, \"Meta\") and hasattr(b.Meta, \"formfield_callback\"):\n-                base_formfield_callback = b.Meta.formfield_callback\n-                break\n-\n-        formfield_callback = attrs.pop(\"formfield_callback\", base_formfield_callback)\n-\n         new_class = super().__new__(mcs, name, bases, attrs)\n \n         if bases == (BaseModelForm,):\n@@ -308,7 +301,7 @@ def __new__(mcs, name, bases, attrs):\n                 opts.fields,\n                 opts.exclude,\n                 opts.widgets,\n-                formfield_callback,\n+                opts.formfield_callback,\n                 opts.localized_fields,\n                 opts.labels,\n                 opts.help_texts,\n@@ -636,7 +629,7 @@ def modelform_factory(\n     class_name = model.__name__ + \"Form\"\n \n     # Class attributes for the new form class.\n-    form_class_attrs = {\"Meta\": Meta, \"formfield_callback\": formfield_callback}\n+    form_class_attrs = {\"Meta\": Meta}\n \n     if getattr(Meta, \"fields\", None) is None and getattr(Meta, \"exclude\", None) is None:\n         raise ImproperlyConfigured(\n", "diff --git a/tests/model_forms/test_formfield_callback.py b/tests/model_forms/test_formfield_callback.py\nnew file mode 100644\nindex 0000000000..074068a53e\n--- /dev/null\n+++ b/tests/model_forms/test_formfield_callback.py\n@@ -0,0 +1,131 @@\n+from django import forms\n+from django.core.exceptions import ImproperlyConfigured\n+from django.db import models\n+from django.forms.models import modelform_factory\n+from django.test import SimpleTestCase\n+\n+from .models import Person, Post\n+\n+\n+def all_required(field, **kwargs):\n+    \"\"\"A callback that makes every form field required.\"\"\"\n+    formfield = field.formfield(**kwargs)\n+    if formfield:\n+        formfield.required = True\n+    return formfield\n+\n+\n+class FormFieldCallbackTests(SimpleTestCase):\n+    def test_baseform_with_widgets_in_meta(self):\n+        \"\"\"\n+        Using base forms with widgets defined in Meta should not raise errors.\n+        \"\"\"\n+        widget = forms.Textarea()\n+\n+        class BaseForm(forms.ModelForm):\n+            class Meta:\n+                model = Person\n+                widgets = {\"name\": widget}\n+                fields = \"__all__\"\n+\n+        Form = modelform_factory(Person, form=BaseForm)\n+        self.assertIsInstance(Form.base_fields[\"name\"].widget, forms.Textarea)\n+\n+    def test_factory_with_widget_argument(self):\n+        \"\"\"Regression for #15315: modelform_factory should accept widgets\n+        argument\n+        \"\"\"\n+        widget = forms.Textarea()\n+\n+        # Without a widget should not set the widget to textarea\n+        Form = modelform_factory(Person, fields=\"__all__\")\n+        self.assertNotEqual(Form.base_fields[\"name\"].widget.__class__, forms.Textarea)\n+\n+        # With a widget should not set the widget to textarea\n+        Form = modelform_factory(Person, fields=\"__all__\", widgets={\"name\": widget})\n+        self.assertEqual(Form.base_fields[\"name\"].widget.__class__, forms.Textarea)\n+\n+    def test_modelform_factory_without_fields(self):\n+        \"\"\"Regression for #19733\"\"\"\n+        message = (\n+            \"Calling modelform_factory without defining 'fields' or 'exclude' \"\n+            \"explicitly is prohibited.\"\n+        )\n+        with self.assertRaisesMessage(ImproperlyConfigured, message):\n+            modelform_factory(Person)\n+\n+    def test_modelform_factory_with_all_fields(self):\n+        \"\"\"Regression for #19733\"\"\"\n+        form = modelform_factory(Person, fields=\"__all__\")\n+        self.assertEqual(list(form.base_fields), [\"name\"])\n+\n+    def test_custom_callback(self):\n+        \"\"\"A custom formfield_callback is used if provided\"\"\"\n+        callback_args = []\n+\n+        def callback(db_field, **kwargs):\n+            callback_args.append((db_field, kwargs))\n+            return db_field.formfield(**kwargs)\n+\n+        widget = forms.Textarea()\n+\n+        class BaseForm(forms.ModelForm):\n+            class Meta:\n+                model = Person\n+                widgets = {\"name\": widget}\n+                fields = \"__all__\"\n+\n+        modelform_factory(Person, form=BaseForm, formfield_callback=callback)\n+        id_field, name_field = Person._meta.fields\n+\n+        self.assertEqual(\n+            callback_args, [(id_field, {}), (name_field, {\"widget\": widget})]\n+        )\n+\n+    def test_bad_callback(self):\n+        # A bad callback provided by user still gives an error\n+        with self.assertRaises(TypeError):\n+            modelform_factory(\n+                Person,\n+                fields=\"__all__\",\n+                formfield_callback=\"not a function or callable\",\n+            )\n+\n+    def test_inherit_after_custom_callback(self):\n+        def callback(db_field, **kwargs):\n+            if isinstance(db_field, models.CharField):\n+                return forms.CharField(widget=forms.Textarea)\n+            return db_field.formfield(**kwargs)\n+\n+        class BaseForm(forms.ModelForm):\n+            class Meta:\n+                model = Person\n+                fields = \"__all__\"\n+\n+        NewForm = modelform_factory(Person, form=BaseForm, formfield_callback=callback)\n+\n+        class InheritedForm(NewForm):\n+            pass\n+\n+        for name in NewForm.base_fields:\n+            self.assertEqual(\n+                type(InheritedForm.base_fields[name].widget),\n+                type(NewForm.base_fields[name].widget),\n+            )\n+\n+    def test_factory_inherits_formfield_callback_from_meta(self):\n+        \"\"\"\n+        modelform_factory() should inherit formfield_callback from the base\n+        form's Meta.\n+        \"\"\"\n+\n+        class PostForm(forms.ModelForm):\n+            class Meta:\n+                model = Post\n+                fields = [\"title\", \"posted\"]\n+                formfield_callback = all_required\n+\n+        FactoryForm = modelform_factory(Post, form=PostForm)\n+        # Post.title is blank=True, so the form field is not required by\n+        # default. The callback should make it required.\n+        self.assertTrue(FactoryForm.base_fields[\"title\"].required)\n"], "arch": "x86_64", "base_commit": "88e67a54b7ed0210c11523a337b498aadb2f5187", "test_directives": ["model_forms.test_formfield_callback"], "coverage_files": ["django/forms/models.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.9", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/forms/models\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 model_forms.test_formfield_callback", "req_install_commands": ["conda create -n testbed python=3.9 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\naiosmtpd\nasgiref >= 3.6.0\nargon2-cffi >= 19.2.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\nblack\ndocutils\ngeoip2; python_version < '3.12'\njinja2 >= 2.11.0\nnumpy; python_version < '3.12'\nPillow >= 6.2.1; sys.platform != 'win32' or python_version < '3.12'\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.4.0\nselenium\nsqlparse >= 0.3.1\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}