{"instance_id": "django__django-11141", "repo": "django/django", "version": "3.1", "environment_setup_commit": "0668164b4ac93a5be79f5b87fae83c657124d9ab", "patch_list": ["diff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py\n--- a/django/db/migrations/loader.py\n+++ b/django/db/migrations/loader.py\n@@ -84,11 +84,6 @@ def load_disk(self):\n                     continue\n                 raise\n             else:\n-                # Empty directories are namespaces.\n-                # getattr() needed on PY36 and older (replace w/attribute access).\n-                if getattr(module, '__file__', None) is None:\n-                    self.unmigrated_apps.add(app_config.label)\n-                    continue\n                 # Module is not a package (e.g. migrations.py).\n                 if not hasattr(module, '__path__'):\n                     self.unmigrated_apps.add(app_config.label)\n@@ -96,11 +91,14 @@ def load_disk(self):\n                 # Force a reload if it's already loaded (tests need this)\n                 if was_loaded:\n                     reload(module)\n-            self.migrated_apps.add(app_config.label)\n             migration_names = {\n                 name for _, name, is_pkg in pkgutil.iter_modules(module.__path__)\n                 if not is_pkg and name[0] not in '_~'\n             }\n+            if migration_names or self.ignore_no_migrations:\n+                self.migrated_apps.add(app_config.label)\n+            else:\n+                self.unmigrated_apps.add(app_config.label)\n             # Load migrations\n             for migration_name in migration_names:\n                 migration_path = '%s.%s' % (module_name, migration_name)\n", "diff --git a/tests/migrations/test_loader_recorder.py b/tests/migrations/test_loader_recorder.py\nnew file mode 100644\nindex 0000000000..8e6373a69e\n--- /dev/null\n+++ b/tests/migrations/test_loader_recorder.py\n@@ -0,0 +1,504 @@\n+import compileall\n+import os\n+\n+from django.db import connection, connections\n+from django.db.migrations.exceptions import (\n+    AmbiguityError, InconsistentMigrationHistory, NodeNotFoundError,\n+)\n+from django.db.migrations.loader import MigrationLoader\n+from django.db.migrations.recorder import MigrationRecorder\n+from django.test import TestCase, modify_settings, override_settings\n+\n+from .test_base import MigrationTestBase\n+\n+\n+class RecorderTests(TestCase):\n+    \"\"\"\n+    Tests recording migrations as applied or not.\n+    \"\"\"\n+    databases = {'default', 'other'}\n+\n+    def test_apply(self):\n+        \"\"\"\n+        Tests marking migrations as applied/unapplied.\n+        \"\"\"\n+        recorder = MigrationRecorder(connection)\n+        self.assertEqual(\n+            {(x, y) for (x, y) in recorder.applied_migrations() if x == \"myapp\"},\n+            set(),\n+        )\n+        recorder.record_applied(\"myapp\", \"0432_ponies\")\n+        self.assertEqual(\n+            {(x, y) for (x, y) in recorder.applied_migrations() if x == \"myapp\"},\n+            {(\"myapp\", \"0432_ponies\")},\n+        )\n+        # That should not affect records of another database\n+        recorder_other = MigrationRecorder(connections['other'])\n+        self.assertEqual(\n+            {(x, y) for (x, y) in recorder_other.applied_migrations() if x == \"myapp\"},\n+            set(),\n+        )\n+        recorder.record_unapplied(\"myapp\", \"0432_ponies\")\n+        self.assertEqual(\n+            {(x, y) for (x, y) in recorder.applied_migrations() if x == \"myapp\"},\n+            set(),\n+        )\n+\n+\n+class LoaderTests(TestCase):\n+    \"\"\"\n+    Tests the disk and database loader, and running through migrations\n+    in memory.\n+    \"\"\"\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    @modify_settings(INSTALLED_APPS={'append': 'basic'})\n+    def test_load(self):\n+        \"\"\"\n+        Makes sure the loader can load the migrations for the test apps,\n+        and then render them out to a new Apps.\n+        \"\"\"\n+        # Load and test the plan\n+        migration_loader = MigrationLoader(connection)\n+        self.assertEqual(\n+            migration_loader.graph.forwards_plan((\"migrations\", \"0002_second\")),\n+            [\n+                (\"migrations\", \"0001_initial\"),\n+                (\"migrations\", \"0002_second\"),\n+            ],\n+        )\n+        # Now render it out!\n+        project_state = migration_loader.project_state((\"migrations\", \"0002_second\"))\n+        self.assertEqual(len(project_state.models), 2)\n+\n+        author_state = project_state.models[\"migrations\", \"author\"]\n+        self.assertEqual(\n+            [x for x, y in author_state.fields],\n+            [\"id\", \"name\", \"slug\", \"age\", \"rating\"]\n+        )\n+\n+        book_state = project_state.models[\"migrations\", \"book\"]\n+        self.assertEqual(\n+            [x for x, y in book_state.fields],\n+            [\"id\", \"author\"]\n+        )\n+\n+        # Ensure we've included unmigrated apps in there too\n+        self.assertIn(\"basic\", project_state.real_apps)\n+\n+    @override_settings(MIGRATION_MODULES={\n+        'migrations': 'migrations.test_migrations',\n+        'migrations2': 'migrations2.test_migrations_2',\n+    })\n+    @modify_settings(INSTALLED_APPS={'append': 'migrations2'})\n+    def test_plan_handles_repeated_migrations(self):\n+        \"\"\"\n+        _generate_plan() doesn't readd migrations already in the plan (#29180).\n+        \"\"\"\n+        migration_loader = MigrationLoader(connection)\n+        nodes = [('migrations', '0002_second'), ('migrations2', '0001_initial')]\n+        self.assertEqual(\n+            migration_loader.graph._generate_plan(nodes, at_end=True),\n+            [('migrations', '0001_initial'), ('migrations', '0002_second'), ('migrations2', '0001_initial')]\n+        )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_unmigdep\"})\n+    def test_load_unmigrated_dependency(self):\n+        \"\"\"\n+        Makes sure the loader can load migrations with a dependency on an unmigrated app.\n+        \"\"\"\n+        # Load and test the plan\n+        migration_loader = MigrationLoader(connection)\n+        self.assertEqual(\n+            migration_loader.graph.forwards_plan((\"migrations\", \"0001_initial\")),\n+            [\n+                ('contenttypes', '0001_initial'),\n+                ('auth', '0001_initial'),\n+                (\"migrations\", \"0001_initial\"),\n+            ],\n+        )\n+        # Now render it out!\n+        project_state = migration_loader.project_state((\"migrations\", \"0001_initial\"))\n+        self.assertEqual(len([m for a, m in project_state.models if a == \"migrations\"]), 1)\n+\n+        book_state = project_state.models[\"migrations\", \"book\"]\n+        self.assertEqual(\n+            [x for x, y in book_state.fields],\n+            [\"id\", \"user\"]\n+        )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_run_before\"})\n+    def test_run_before(self):\n+        \"\"\"\n+        Makes sure the loader uses Migration.run_before.\n+        \"\"\"\n+        # Load and test the plan\n+        migration_loader = MigrationLoader(connection)\n+        self.assertEqual(\n+            migration_loader.graph.forwards_plan((\"migrations\", \"0002_second\")),\n+            [\n+                (\"migrations\", \"0001_initial\"),\n+                (\"migrations\", \"0003_third\"),\n+                (\"migrations\", \"0002_second\"),\n+            ],\n+        )\n+\n+    @override_settings(MIGRATION_MODULES={\n+        \"migrations\": \"migrations.test_migrations_first\",\n+        \"migrations2\": \"migrations2.test_migrations_2_first\",\n+    })\n+    @modify_settings(INSTALLED_APPS={'append': 'migrations2'})\n+    def test_first(self):\n+        \"\"\"\n+        Makes sure the '__first__' migrations build correctly.\n+        \"\"\"\n+        migration_loader = MigrationLoader(connection)\n+        self.assertEqual(\n+            migration_loader.graph.forwards_plan((\"migrations\", \"second\")),\n+            [\n+                (\"migrations\", \"thefirst\"),\n+                (\"migrations2\", \"0001_initial\"),\n+                (\"migrations2\", \"0002_second\"),\n+                (\"migrations\", \"second\"),\n+            ],\n+        )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_name_match(self):\n+        \"Tests prefix name matching\"\n+        migration_loader = MigrationLoader(connection)\n+        self.assertEqual(\n+            migration_loader.get_migration_by_prefix(\"migrations\", \"0001\").name,\n+            \"0001_initial\",\n+        )\n+        with self.assertRaises(AmbiguityError):\n+            migration_loader.get_migration_by_prefix(\"migrations\", \"0\")\n+        with self.assertRaises(KeyError):\n+            migration_loader.get_migration_by_prefix(\"migrations\", \"blarg\")\n+\n+    def test_load_import_error(self):\n+        with override_settings(MIGRATION_MODULES={\"migrations\": \"import_error_package\"}):\n+            with self.assertRaises(ImportError):\n+                MigrationLoader(connection)\n+\n+    def test_load_module_file(self):\n+        with override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.faulty_migrations.file\"}):\n+            loader = MigrationLoader(connection)\n+            self.assertIn(\n+                \"migrations\", loader.unmigrated_apps,\n+                \"App with migrations module file not in unmigrated apps.\"\n+            )\n+\n+    @modify_settings(INSTALLED_APPS={'append': 'migrations'})\n+    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.faulty_migrations.namespace'})\n+    def test_load_namespace_package(self):\n+        \"\"\"\n+        Migrations in a namespace package (directory without __init__.py) are\n+        loaded.\n+        \"\"\"\n+        loader = MigrationLoader(connection)\n+        self.assertIn('migrations', loader.migrated_apps)\n+        self.assertNotIn('migrations', loader.unmigrated_apps)\n+\n+    @override_settings(\n+        INSTALLED_APPS=['migrations.migrations_test_apps.migrated_app'],\n+    )\n+    def test_marked_as_migrated(self):\n+        \"\"\"\n+        Undefined MIGRATION_MODULES implies default migration module.\n+        \"\"\"\n+        migration_loader = MigrationLoader(connection)\n+        self.assertEqual(migration_loader.migrated_apps, {'migrated_app'})\n+        self.assertEqual(migration_loader.unmigrated_apps, set())\n+\n+    @override_settings(\n+        INSTALLED_APPS=['migrations.migrations_test_apps.migrated_app'],\n+        MIGRATION_MODULES={\"migrated_app\": None},\n+    )\n+    def test_marked_as_unmigrated(self):\n+        \"\"\"\n+        MIGRATION_MODULES allows disabling of migrations for a particular app.\n+        \"\"\"\n+        migration_loader = MigrationLoader(connection)\n+        self.assertEqual(migration_loader.migrated_apps, set())\n+        self.assertEqual(migration_loader.unmigrated_apps, {'migrated_app'})\n+\n+    @override_settings(\n+        INSTALLED_APPS=['migrations.migrations_test_apps.migrated_app'],\n+        MIGRATION_MODULES={'migrated_app': 'missing-module'},\n+    )\n+    def test_explicit_missing_module(self):\n+        \"\"\"\n+        If a MIGRATION_MODULES override points to a missing module, the error\n+        raised during the importation attempt should be propagated unless\n+        `ignore_no_migrations=True`.\n+        \"\"\"\n+        with self.assertRaisesMessage(ImportError, 'missing-module'):\n+            migration_loader = MigrationLoader(connection)\n+        migration_loader = MigrationLoader(connection, ignore_no_migrations=True)\n+        self.assertEqual(migration_loader.migrated_apps, set())\n+        self.assertEqual(migration_loader.unmigrated_apps, {'migrated_app'})\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"})\n+    def test_loading_squashed(self):\n+        \"Tests loading a squashed migration\"\n+        migration_loader = MigrationLoader(connection)\n+        recorder = MigrationRecorder(connection)\n+        self.addCleanup(recorder.flush)\n+        # Loading with nothing applied should just give us the one node\n+        self.assertEqual(\n+            len([x for x in migration_loader.graph.nodes if x[0] == \"migrations\"]),\n+            1,\n+        )\n+        # However, fake-apply one migration and it should now use the old two\n+        recorder.record_applied(\"migrations\", \"0001_initial\")\n+        migration_loader.build_graph()\n+        self.assertEqual(\n+            len([x for x in migration_loader.graph.nodes if x[0] == \"migrations\"]),\n+            2,\n+        )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed_complex\"})\n+    def test_loading_squashed_complex(self):\n+        \"Tests loading a complex set of squashed migrations\"\n+\n+        loader = MigrationLoader(connection)\n+        recorder = MigrationRecorder(connection)\n+        self.addCleanup(recorder.flush)\n+\n+        def num_nodes():\n+            plan = set(loader.graph.forwards_plan(('migrations', '7_auto')))\n+            return len(plan - loader.applied_migrations.keys())\n+\n+        # Empty database: use squashed migration\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 5)\n+\n+        # Starting at 1 or 2 should use the squashed migration too\n+        recorder.record_applied(\"migrations\", \"1_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 4)\n+\n+        recorder.record_applied(\"migrations\", \"2_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 3)\n+\n+        # However, starting at 3 to 5 cannot use the squashed migration\n+        recorder.record_applied(\"migrations\", \"3_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 4)\n+\n+        recorder.record_applied(\"migrations\", \"4_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 3)\n+\n+        # Starting at 5 to 7 we are passed the squashed migrations\n+        recorder.record_applied(\"migrations\", \"5_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 2)\n+\n+        recorder.record_applied(\"migrations\", \"6_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 1)\n+\n+        recorder.record_applied(\"migrations\", \"7_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 0)\n+\n+    @override_settings(MIGRATION_MODULES={\n+        \"app1\": \"migrations.test_migrations_squashed_complex_multi_apps.app1\",\n+        \"app2\": \"migrations.test_migrations_squashed_complex_multi_apps.app2\",\n+    })\n+    @modify_settings(INSTALLED_APPS={'append': [\n+        \"migrations.test_migrations_squashed_complex_multi_apps.app1\",\n+        \"migrations.test_migrations_squashed_complex_multi_apps.app2\",\n+    ]})\n+    def test_loading_squashed_complex_multi_apps(self):\n+        loader = MigrationLoader(connection)\n+        loader.build_graph()\n+\n+        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))\n+        expected_plan = {\n+            ('app1', '1_auto'),\n+            ('app2', '1_squashed_2'),\n+            ('app1', '2_squashed_3'),\n+            ('app1', '4_auto'),\n+        }\n+        self.assertEqual(plan, expected_plan)\n+\n+    @override_settings(MIGRATION_MODULES={\n+        \"app1\": \"migrations.test_migrations_squashed_complex_multi_apps.app1\",\n+        \"app2\": \"migrations.test_migrations_squashed_complex_multi_apps.app2\",\n+    })\n+    @modify_settings(INSTALLED_APPS={'append': [\n+        \"migrations.test_migrations_squashed_complex_multi_apps.app1\",\n+        \"migrations.test_migrations_squashed_complex_multi_apps.app2\",\n+    ]})\n+    def test_loading_squashed_complex_multi_apps_partially_applied(self):\n+        loader = MigrationLoader(connection)\n+        recorder = MigrationRecorder(connection)\n+        recorder.record_applied('app1', '1_auto')\n+        recorder.record_applied('app1', '2_auto')\n+        loader.build_graph()\n+\n+        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))\n+        plan = plan - loader.applied_migrations.keys()\n+        expected_plan = {\n+            ('app2', '1_squashed_2'),\n+            ('app1', '3_auto'),\n+            ('app1', '4_auto'),\n+        }\n+\n+        self.assertEqual(plan, expected_plan)\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed_erroneous\"})\n+    def test_loading_squashed_erroneous(self):\n+        \"Tests loading a complex but erroneous set of squashed migrations\"\n+\n+        loader = MigrationLoader(connection)\n+        recorder = MigrationRecorder(connection)\n+        self.addCleanup(recorder.flush)\n+\n+        def num_nodes():\n+            plan = set(loader.graph.forwards_plan(('migrations', '7_auto')))\n+            return len(plan - loader.applied_migrations.keys())\n+\n+        # Empty database: use squashed migration\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 5)\n+\n+        # Starting at 1 or 2 should use the squashed migration too\n+        recorder.record_applied(\"migrations\", \"1_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 4)\n+\n+        recorder.record_applied(\"migrations\", \"2_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 3)\n+\n+        # However, starting at 3 or 4, nonexistent migrations would be needed.\n+        msg = (\"Migration migrations.6_auto depends on nonexistent node ('migrations', '5_auto'). \"\n+               \"Django tried to replace migration migrations.5_auto with any of \"\n+               \"[migrations.3_squashed_5] but wasn't able to because some of the replaced \"\n+               \"migrations are already applied.\")\n+\n+        recorder.record_applied(\"migrations\", \"3_auto\")\n+        with self.assertRaisesMessage(NodeNotFoundError, msg):\n+            loader.build_graph()\n+\n+        recorder.record_applied(\"migrations\", \"4_auto\")\n+        with self.assertRaisesMessage(NodeNotFoundError, msg):\n+            loader.build_graph()\n+\n+        # Starting at 5 to 7 we are passed the squashed migrations\n+        recorder.record_applied(\"migrations\", \"5_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 2)\n+\n+        recorder.record_applied(\"migrations\", \"6_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 1)\n+\n+        recorder.record_applied(\"migrations\", \"7_auto\")\n+        loader.build_graph()\n+        self.assertEqual(num_nodes(), 0)\n+\n+    @override_settings(\n+        MIGRATION_MODULES={'migrations': 'migrations.test_migrations'},\n+        INSTALLED_APPS=['migrations'],\n+    )\n+    def test_check_consistent_history(self):\n+        loader = MigrationLoader(connection=None)\n+        loader.check_consistent_history(connection)\n+        recorder = MigrationRecorder(connection)\n+        recorder.record_applied('migrations', '0002_second')\n+        msg = (\n+            \"Migration migrations.0002_second is applied before its dependency \"\n+            \"migrations.0001_initial on database 'default'.\"\n+        )\n+        with self.assertRaisesMessage(InconsistentMigrationHistory, msg):\n+            loader.check_consistent_history(connection)\n+\n+    @override_settings(\n+        MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed_extra'},\n+        INSTALLED_APPS=['migrations'],\n+    )\n+    def test_check_consistent_history_squashed(self):\n+        \"\"\"\n+        MigrationLoader.check_consistent_history() should ignore unapplied\n+        squashed migrations that have all of their `replaces` applied.\n+        \"\"\"\n+        loader = MigrationLoader(connection=None)\n+        recorder = MigrationRecorder(connection)\n+        recorder.record_applied('migrations', '0001_initial')\n+        recorder.record_applied('migrations', '0002_second')\n+        loader.check_consistent_history(connection)\n+        recorder.record_applied('migrations', '0003_third')\n+        loader.check_consistent_history(connection)\n+\n+    @override_settings(MIGRATION_MODULES={\n+        \"app1\": \"migrations.test_migrations_squashed_ref_squashed.app1\",\n+        \"app2\": \"migrations.test_migrations_squashed_ref_squashed.app2\",\n+    })\n+    @modify_settings(INSTALLED_APPS={'append': [\n+        \"migrations.test_migrations_squashed_ref_squashed.app1\",\n+        \"migrations.test_migrations_squashed_ref_squashed.app2\",\n+    ]})\n+    def test_loading_squashed_ref_squashed(self):\n+        \"Tests loading a squashed migration with a new migration referencing it\"\n+        r\"\"\"\n+        The sample migrations are structured like this:\n+\n+        app_1       1 --> 2 ---------------------*--> 3        *--> 4\n+                     \\                          /             /\n+                      *-------------------*----/--> 2_sq_3 --*\n+                       \\                 /    /\n+        =============== \\ ============= / == / ======================\n+        app_2            *--> 1_sq_2 --*    /\n+                          \\                /\n+                           *--> 1 --> 2 --*\n+\n+        Where 2_sq_3 is a replacing migration for 2 and 3 in app_1,\n+        as 1_sq_2 is a replacing migration for 1 and 2 in app_2.\n+        \"\"\"\n+\n+        loader = MigrationLoader(connection)\n+        recorder = MigrationRecorder(connection)\n+        self.addCleanup(recorder.flush)\n+\n+        # Load with nothing applied: both migrations squashed.\n+        loader.build_graph()\n+        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))\n+        plan = plan - loader.applied_migrations.keys()\n+        expected_plan = {\n+            ('app1', '1_auto'),\n+            ('app2', '1_squashed_2'),\n+            ('app1', '2_squashed_3'),\n+            ('app1', '4_auto'),\n+        }\n+        self.assertEqual(plan, expected_plan)\n+\n+        # Fake-apply a few from app1: unsquashes migration in app1.\n+        recorder.record_applied('app1', '1_auto')\n+        recorder.record_applied('app1', '2_auto')\n+        loader.build_graph()\n+        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))\n+        plan = plan - loader.applied_migrations.keys()\n+        expected_plan = {\n+            ('app2', '1_squashed_2'),\n+            ('app1', '3_auto'),\n+            ('app1', '4_auto'),\n+        }\n+        self.assertEqual(plan, expected_plan)\n+\n+        # Fake-apply one from app2: unsquashes migration in app2 too.\n+        recorder.record_applied('app2', '1_auto')\n+        loader.build_graph()\n+        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))\n+        plan = plan - loader.applied_migrations.keys()\n+        expected_plan = {\n+            ('app2', '2_auto'),\n+            ('app1', '3_auto'),\n+            ('app1', '4_auto'),\n+        }\n+        self.assertEqual(plan, expected_plan)\n"], "arch": "x86_64", "base_commit": "5d9cf79baf07fc4aed7ad1b06990532a65378155", "test_directives": ["migrations.test_loader_recorder"], "coverage_files": ["django/db/migrations/loader.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/migrations/loader\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 migrations.test_loader_recorder", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.2\nargon2-cffi >= 16.1.0\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}