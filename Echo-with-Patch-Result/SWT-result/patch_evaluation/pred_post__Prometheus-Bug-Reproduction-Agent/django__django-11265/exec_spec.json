{"instance_id": "django__django-11265", "repo": "django/django", "version": "3.0", "environment_setup_commit": "419a78300f7cd27611196e1e464d50fd0385ff27", "patch_list": ["diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1666,6 +1666,7 @@ def split_exclude(self, filter_expr, can_reuse, names_with_path):\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\n+        query._filtered_relations = self._filtered_relations\n         query.add_filter(filter_expr)\n         query.clear_ordering(True)\n         # Try to have as simple as possible subquery -> trim leading joins from\n@@ -2140,9 +2141,13 @@ def trim_start(self, names_with_path):\n             join_field.foreign_related_fields[0].name)\n         trimmed_prefix = LOOKUP_SEP.join(trimmed_prefix)\n         # Lets still see if we can trim the first join from the inner query\n-        # (that is, self). We can't do this for LEFT JOINs because we would\n-        # miss those rows that have nothing on the outer side.\n-        if self.alias_map[lookup_tables[trimmed_paths + 1]].join_type != LOUTER:\n+        # (that is, self). We can't do this for:\n+        # - LEFT JOINs because we would miss those rows that have nothing on\n+        #   the outer side,\n+        # - INNER JOINs from filtered relations because we would miss their\n+        #   filters.\n+        first_join = self.alias_map[lookup_tables[trimmed_paths + 1]]\n+        if first_join.join_type != LOUTER and not first_join.filtered_relation:\n             select_fields = [r[0] for r in join_field.related_fields]\n             select_alias = lookup_tables[trimmed_paths + 1]\n             self.unref_alias(lookup_tables[trimmed_paths])\n", "diff --git a/filtered_relation/tests.py b/filtered_relation/tests.py\nnew file mode 100644\nindex 0000000000..f363bfee6a\n--- /dev/null\n+++ b/filtered_relation/tests.py\n@@ -0,0 +1,322 @@\n+from django.db import connection, transaction\n+from django.db.models import Case, Count, F, FilteredRelation, Q, When\n+from django.test import TestCase\n+from django.test.testcases import skipUnlessDBFeature\n+\n+from .models import Author, Book, Borrower, Editor, RentalSession, Reservation\n+\n+\n+class FilteredRelationTests(TestCase):\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.author1 = Author.objects.create(name='Alice')\n+        cls.author2 = Author.objects.create(name='Jane')\n+        cls.editor_a = Editor.objects.create(name='a')\n+        cls.editor_b = Editor.objects.create(name='b')\n+        cls.book1 = Book.objects.create(\n+            title='Poem by Alice',\n+            editor=cls.editor_a,\n+            author=cls.author1,\n+        )\n+        cls.book1.generic_author.set([cls.author2])\n+        cls.book2 = Book.objects.create(\n+            title='The book by Jane A',\n+            editor=cls.editor_b,\n+            author=cls.author2,\n+        )\n+        cls.book3 = Book.objects.create(\n+            title='The book by Jane B',\n+            editor=cls.editor_b,\n+            author=cls.author2,\n+        )\n+        cls.book4 = Book.objects.create(\n+            title='The book by Alice',\n+            editor=cls.editor_a,\n+            author=cls.author1,\n+        )\n+        cls.author1.favorite_books.add(cls.book2)\n+        cls.author1.favorite_books.add(cls.book3)\n+\n+    def test_exclude_on_filtered_relation_annotation(self):\n+        qs = Author.objects.annotate(\n+            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+        ).exclude(book_alice__isnull=False)\n+        self.assertSequenceEqual(qs, [self.author2])\n+\n+    def test_select_related(self):\n+        qs = Author.objects.annotate(\n+            book_join=FilteredRelation('book'),\n+        ).select_related('book_join__editor').order_by('pk', 'book_join__pk')\n+        with self.assertNumQueries(1):\n+            self.assertQuerysetEqual(qs, [\n+                (self.author1, self.book1, self.editor_a, self.author1),\n+                (self.author1, self.book4, self.editor_a, self.author1),\n+                (self.author2, self.book2, self.editor_b, self.author2),\n+                (self.author2, self.book3, self.editor_b, self.author2),\n+            ], lambda x: (x, x.book_join, x.book_join.editor, x.book_join.author))\n+\n+    def test_select_related_with_empty_relation(self):\n+        qs = Author.objects.annotate(\n+            book_join=FilteredRelation('book', condition=Q(pk=-1)),\n+        ).select_related('book_join').order_by('pk')\n+        self.assertSequenceEqual(qs, [self.author1, self.author2])\n+\n+    def test_select_related_foreign_key(self):\n+        qs = Book.objects.annotate(\n+            author_join=FilteredRelation('author'),\n+        ).select_related('author_join').order_by('pk')\n+        with self.assertNumQueries(1):\n+            self.assertQuerysetEqual(qs, [\n+                (self.book1, self.author1),\n+                (self.book2, self.author2),\n+                (self.book3, self.author2),\n+                (self.book4, self.author1),\n+            ], lambda x: (x, x.author_join))\n+\n+    @skipUnlessDBFeature('has_select_for_update', 'has_select_for_update_of')\n+    def test_select_related_foreign_key_for_update_of(self):\n+        with transaction.atomic():\n+            qs = Book.objects.annotate(\n+                author_join=FilteredRelation('author'),\n+            ).select_related('author_join').select_for_update(of=('self',)).order_by('pk')\n+            with self.assertNumQueries(1):\n+                self.assertQuerysetEqual(qs, [\n+                    (self.book1, self.author1),\n+                    (self.book2, self.author2),\n+                    (self.book3, self.author2),\n+                    (self.book4, self.author1),\n+                ], lambda x: (x, x.author_join))\n+\n+    def test_without_join(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ),\n+            [self.author1, self.author2]\n+        )\n+\n+    def test_with_join(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).filter(book_alice__isnull=False),\n+            [self.author1]\n+        )\n+\n+    def test_with_join_and_complex_condition(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation(\n+                    'book', condition=Q(\n+                        Q(book__title__iexact='poem by alice') |\n+                        Q(book__state=Book.RENTED)\n+                    ),\n+                ),\n+            ).filter(book_alice__isnull=False),\n+            [self.author1]\n+        )\n+\n+    def test_internal_queryset_alias_mapping(self):\n+        queryset = Author.objects.annotate(\n+            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+        ).filter(book_alice__isnull=False)\n+        self.assertIn(\n+            'INNER JOIN {} book_alice ON'.format(connection.ops.quote_name('filtered_relation_book')),\n+            str(queryset.query)\n+        )\n+\n+    def test_with_multiple_filter(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_editor_a=FilteredRelation(\n+                    'book',\n+                    condition=Q(book__title__icontains='book', book__editor_id=self.editor_a.pk),\n+                ),\n+            ).filter(book_editor_a__isnull=False),\n+            [self.author1]\n+        )\n+\n+    def test_multiple_times(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_title_alice=FilteredRelation('book', condition=Q(book__title__icontains='alice')),\n+            ).filter(book_title_alice__isnull=False).filter(book_title_alice__isnull=False).distinct(),\n+            [self.author1]\n+        )\n+\n+    def test_exclude_relation_with_join(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=~Q(book__title__icontains='alice')),\n+            ).filter(book_alice__isnull=False).distinct(),\n+            [self.author2]\n+        )\n+\n+    def test_with_m2m(self):\n+        qs = Author.objects.annotate(\n+            favorite_books_written_by_jane=FilteredRelation(\n+                'favorite_books', condition=Q(favorite_books__in=[self.book2]),\n+            ),\n+        ).filter(favorite_books_written_by_jane__isnull=False)\n+        self.assertSequenceEqual(qs, [self.author1])\n+\n+    def test_with_m2m_deep(self):\n+        qs = Author.objects.annotate(\n+            favorite_books_written_by_jane=FilteredRelation(\n+                'favorite_books', condition=Q(favorite_books__author=self.author2),\n+            ),\n+        ).filter(favorite_books_written_by_jane__title='The book by Jane B')\n+        self.assertSequenceEqual(qs, [self.author1])\n+\n+    def test_with_m2m_multijoin(self):\n+        qs = Author.objects.annotate(\n+            favorite_books_written_by_jane=FilteredRelation(\n+                'favorite_books', condition=Q(favorite_books__author=self.author2),\n+            )\n+        ).filter(favorite_books_written_by_jane__editor__name='b').distinct()\n+        self.assertSequenceEqual(qs, [self.author1])\n+\n+    def test_values_list(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).filter(book_alice__isnull=False).values_list('book_alice__title', flat=True),\n+            ['Poem by Alice']\n+        )\n+\n+    def test_values(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).filter(book_alice__isnull=False).values(),\n+            [{'id': self.author1.pk, 'name': 'Alice', 'content_type_id': None, 'object_id': None}]\n+        )\n+\n+    def test_extra(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).filter(book_alice__isnull=False).extra(where=['1 = 1']),\n+            [self.author1]\n+        )\n+\n+    @skipUnlessDBFeature('supports_select_union')\n+    def test_union(self):\n+        qs1 = Author.objects.annotate(\n+            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+        ).filter(book_alice__isnull=False)\n+        qs2 = Author.objects.annotate(\n+            book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n+        ).filter(book_jane__isnull=False)\n+        self.assertSequenceEqual(qs1.union(qs2), [self.author1, self.author2])\n+\n+    @skipUnlessDBFeature('supports_select_intersection')\n+    def test_intersection(self):\n+        qs1 = Author.objects.annotate(\n+            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+        ).filter(book_alice__isnull=False)\n+        qs2 = Author.objects.annotate(\n+            book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n+        ).filter(book_jane__isnull=False)\n+        self.assertSequenceEqual(qs1.intersection(qs2), [])\n+\n+    @skipUnlessDBFeature('supports_select_difference')\n+    def test_difference(self):\n+        qs1 = Author.objects.annotate(\n+            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+        ).filter(book_alice__isnull=False)\n+        qs2 = Author.objects.annotate(\n+            book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n+        ).filter(book_jane__isnull=False)\n+        self.assertSequenceEqual(qs1.difference(qs2), [self.author1])\n+\n+    def test_select_for_update(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n+            ).filter(book_jane__isnull=False).select_for_update(),\n+            [self.author2]\n+        )\n+\n+    def test_defer(self):\n+        # One query for the list and one query for the deferred title.\n+        with self.assertNumQueries(2):\n+            self.assertQuerysetEqual(\n+                Author.objects.annotate(\n+                    book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+                ).filter(book_alice__isnull=False).select_related('book_alice').defer('book_alice__title'),\n+                ['Poem by Alice'], lambda author: author.book_alice.title\n+            )\n+\n+    def test_only_not_supported(self):\n+        msg = 'only() is not supported with FilteredRelation.'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).filter(book_alice__isnull=False).select_related('book_alice').only('book_alice__state')\n+\n+    def test_as_subquery(self):\n+        inner_qs = Author.objects.annotate(\n+            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+        ).filter(book_alice__isnull=False)\n+        qs = Author.objects.filter(id__in=inner_qs)\n+        self.assertSequenceEqual(qs, [self.author1])\n+\n+    def test_with_foreign_key_error(self):\n+        msg = (\n+            \"FilteredRelation's condition doesn't support nested relations \"\n+            \"(got 'author__favorite_books__author').\"\n+        )\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(Book.objects.annotate(\n+                alice_favorite_books=FilteredRelation(\n+                    'author__favorite_books',\n+                    condition=Q(author__favorite_books__author=self.author1),\n+                )\n+            ))\n+\n+    def test_with_foreign_key_on_condition_error(self):\n+        msg = (\n+            \"FilteredRelation's condition doesn't support nested relations \"\n+            \"(got 'book__editor__name__icontains').\"\n+        )\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(Author.objects.annotate(\n+                book_edited_by_b=FilteredRelation('book', condition=Q(book__editor__name__icontains='b')),\n+            ))\n+\n+    def test_with_empty_relation_name_error(self):\n+        with self.assertRaisesMessage(ValueError, 'relation_name cannot be empty.'):\n+            FilteredRelation('', condition=Q(blank=''))\n+\n+    def test_with_condition_as_expression_error(self):\n+        msg = 'condition argument must be a Q() instance.'\n+        expression = Case(\n+            When(book__title__iexact='poem by alice', then=True), default=False,\n+        )\n+        with self.assertRaisesMessage(ValueError, msg):\n+            FilteredRelation('book', condition=expression)\n+\n+    def test_with_prefetch_related(self):\n+        msg = 'prefetch_related() is not supported with FilteredRelation.'\n+        qs = Author.objects.annotate(\n+            book_title_contains_b=FilteredRelation('book', condition=Q(book__title__icontains='b')),\n+        ).filter(\n+            book_title_contains_b__isnull=False,\n+        )\n+        with self.assertRaisesMessage(ValueError, msg):\n+            qs.prefetch_related('book_title_contains_b')\n+        with self.assertRaisesMessage(ValueError, msg):\n+            qs.prefetch_related('book_title_contains_b__editor')\n+\n+    def test_with_generic_foreign_key(self):\n+        self.assertSequenceEqual(\n+            Book.objects.annotate(\n+                generic_authored_book=FilteredRelation(\n+                    'generic_author',\n+                    condition=Q(generic_author__isnull=False)\n+                ),\n+            ).filter(generic_authored_book__isnull=False),\n+            [self.book1]\n+        )\n"], "arch": "x86_64", "base_commit": "21aa2a5e785eef1f47beb1c3760fdd7d8915ae09", "test_directives": ["filtered_relation.tests"], "coverage_files": ["django/db/models/sql/query.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/models/sql/query\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 filtered_relation.tests", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref ~= 3.2\nargon2-cffi >= 16.1.0\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow != 5.4.0\npylibmc; sys.platform != 'win32'\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}