{"instance_id": "django__django-13128", "repo": "django/django", "version": "3.2", "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d", "patch_list": ["diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -443,23 +443,6 @@ def set_source_expressions(self, exprs):\n         self.lhs, self.rhs = exprs\n \n     def as_sql(self, compiler, connection):\n-        try:\n-            lhs_type = self.lhs.output_field.get_internal_type()\n-        except FieldError:\n-            lhs_type = None\n-        try:\n-            rhs_type = self.rhs.output_field.get_internal_type()\n-        except FieldError:\n-            rhs_type = None\n-        if (\n-            not connection.features.has_native_duration_field and\n-            'DurationField' in {lhs_type, rhs_type} and\n-            lhs_type != rhs_type\n-        ):\n-            return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)\n-        datetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\n-        if self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\n-            return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)\n         expressions = []\n         expression_params = []\n         sql, params = compiler.compile(self.lhs)\n@@ -474,10 +457,30 @@ def as_sql(self, compiler, connection):\n         return expression_wrapper % sql, expression_params\n \n     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        lhs = self.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        rhs = self.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        if not isinstance(self, (DurationExpression, TemporalSubtraction)):\n+            try:\n+                lhs_type = lhs.output_field.get_internal_type()\n+            except (AttributeError, FieldError):\n+                lhs_type = None\n+            try:\n+                rhs_type = rhs.output_field.get_internal_type()\n+            except (AttributeError, FieldError):\n+                rhs_type = None\n+            if 'DurationField' in {lhs_type, rhs_type} and lhs_type != rhs_type:\n+                return DurationExpression(self.lhs, self.connector, self.rhs).resolve_expression(\n+                    query, allow_joins, reuse, summarize, for_save,\n+                )\n+            datetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\n+            if self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\n+                return TemporalSubtraction(self.lhs, self.rhs).resolve_expression(\n+                    query, allow_joins, reuse, summarize, for_save,\n+                )\n         c = self.copy()\n         c.is_summary = summarize\n-        c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n-        c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        c.lhs = lhs\n+        c.rhs = rhs\n         return c\n \n \n@@ -494,6 +497,8 @@ def compile(self, side, compiler, connection):\n         return compiler.compile(side)\n \n     def as_sql(self, compiler, connection):\n+        if connection.features.has_native_duration_field:\n+            return super().as_sql(compiler, connection)\n         connection.ops.check_expression_support(self)\n         expressions = []\n         expression_params = []\n", "diff --git a/tests/expressions/test_temporal_subtraction_chaining.py b/tests/expressions/test_temporal_subtraction_chaining.py\nnew file mode 100644\nindex 0000000000..6b0f05da9e\n--- /dev/null\n+++ b/tests/expressions/test_temporal_subtraction_chaining.py\n@@ -0,0 +1,132 @@\n+import datetime\n+import pickle\n+import unittest\n+from copy import deepcopy\n+from unittest import mock\n+\n+from django.core.exceptions import FieldError\n+from django.db import DatabaseError, NotSupportedError, connection\n+from django.db.models import (\n+    Avg, BooleanField, Case, CharField, Count, DateField, DateTimeField,\n+    DurationField, Exists, Expression, ExpressionList, ExpressionWrapper, F,\n+    Func, IntegerField, Max, Min, Model, OrderBy, OuterRef, Q, StdDev,\n+    Subquery, Sum, TimeField, UUIDField, Value, Variance, When,\n+)\n+from django.db.models.expressions import Col, Combinable, Random, RawSQL, Ref\n+from django.db.models.functions import (\n+    Coalesce, Concat, Left, Length, Lower, Substr, Upper,\n+)\n+from django.db.models.sql import constants\n+from django.db.models.sql.datastructures import Join\n+from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n+from django.test.utils import Approximate, isolate_apps\n+from django.utils.functional import SimpleLazyObject\n+\n+from .models import (\n+    UUID, UUIDPK, Company, Employee, Experiment, Manager, Number,\n+    RemoteEmployee, Result, SimulationRun, Time,\n+)\n+\n+\n+class FTimeDeltaTests(TestCase):\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.sday = sday = datetime.date(2010, 6, 25)\n+        cls.stime = stime = datetime.datetime(2010, 6, 25, 12, 15, 30, 747000)\n+        midnight = datetime.time(0)\n+\n+        delta0 = datetime.timedelta(0)\n+        delta1 = datetime.timedelta(microseconds=253000)\n+        delta2 = datetime.timedelta(seconds=44)\n+        delta3 = datetime.timedelta(hours=21, minutes=8)\n+        delta4 = datetime.timedelta(days=10)\n+        delta5 = datetime.timedelta(days=90)\n+\n+        # Test data is set so that deltas and delays will be\n+        # strictly increasing.\n+        cls.deltas = []\n+        cls.delays = []\n+        cls.days_long = []\n+\n+        # e0: started same day as assigned, zero duration\n+        end = stime + delta0\n+        cls.e0 = Experiment.objects.create(\n+            name='e0', assigned=sday, start=stime, end=end,\n+            completed=end.date(), estimated_time=delta0,\n+        )\n+        cls.deltas.append(delta0)\n+        cls.delays.append(cls.e0.start - datetime.datetime.combine(cls.e0.assigned, midnight))\n+        cls.days_long.append(cls.e0.completed - cls.e0.assigned)\n+\n+        # e1: started one day after assigned, tiny duration, data\n+        # set so that end time has no fractional seconds, which\n+        # tests an edge case on sqlite.\n+        delay = datetime.timedelta(1)\n+        end = stime + delay + delta1\n+        e1 = Experiment.objects.create(\n+            name='e1', assigned=sday, start=stime + delay, end=end,\n+            completed=end.date(), estimated_time=delta1,\n+        )\n+        cls.deltas.append(delta1)\n+        cls.delays.append(e1.start - datetime.datetime.combine(e1.assigned, midnight))\n+        cls.days_long.append(e1.completed - e1.assigned)\n+\n+        # e2: started three days after assigned, small duration\n+        end = stime + delta2\n+        e2 = Experiment.objects.create(\n+            name='e2', assigned=sday - datetime.timedelta(3), start=stime,\n+            end=end, completed=end.date(), estimated_time=datetime.timedelta(hours=1),\n+        )\n+        cls.deltas.append(delta2)\n+        cls.delays.append(e2.start - datetime.datetime.combine(e2.assigned, midnight))\n+        cls.days_long.append(e2.completed - e2.assigned)\n+\n+        # e3: started four days after assigned, medium duration\n+        delay = datetime.timedelta(4)\n+        end = stime + delay + delta3\n+        e3 = Experiment.objects.create(\n+            name='e3', assigned=sday, start=stime + delay, end=end,\n+            completed=end.date(), estimated_time=delta3,\n+        )\n+        cls.deltas.append(delta3)\n+        cls.delays.append(e3.start - datetime.datetime.combine(e3.assigned, midnight))\n+        cls.days_long.append(e3.completed - e3.assigned)\n+\n+        # e4: started 10 days after assignment, long duration\n+        end = stime + delta4\n+        e4 = Experiment.objects.create(\n+            name='e4', assigned=sday - datetime.timedelta(10), start=stime,\n+            end=end, completed=end.date(), estimated_time=delta4 - datetime.timedelta(1),\n+        )\n+        cls.deltas.append(delta4)\n+        cls.delays.append(e4.start - datetime.datetime.combine(e4.assigned, midnight))\n+        cls.days_long.append(e4.completed - e4.assigned)\n+\n+        # e5: started a month after assignment, very long duration\n+        delay = datetime.timedelta(30)\n+        end = stime + delay + delta5\n+        e5 = Experiment.objects.create(\n+            name='e5', assigned=sday, start=stime + delay, end=end,\n+            completed=end.date(), estimated_time=delta5,\n+        )\n+        cls.deltas.append(delta5)\n+        cls.delays.append(e5.start - datetime.datetime.combine(e5.assigned, midnight))\n+        cls.days_long.append(e5.completed - e5.assigned)\n+\n+        cls.expnames = [e.name for e in Experiment.objects.all()]\n+\n+    @skipUnlessDBFeature('supports_temporal_subtraction')\n+    def test_temporal_subtraction_chaining_without_wrapper(self):\n+        \"\"\"\n+        F(datetime) - F(datetime) should be resolvable as a DurationField\n+        without needing an explicit ExpressionWrapper.\n+        \"\"\"\n+        # This is the expression from the bug report.\n+        # Before the fix, F('end') - F('start') doesn't resolve to a\n+        # DurationField, causing a FieldError when added to another one.\n+        qs = Experiment.objects.annotate(\n+            delta=F('end') - F('start') + Value(datetime.timedelta(), output_field=DurationField())\n+        )\n+        # For self.e0, start and end are the same.\n+        self.assertEqual(qs.get(name='e0').delta, datetime.timedelta(0))\n"], "arch": "x86_64", "base_commit": "2d67222472f80f251607ae1b720527afceba06ad", "test_directives": ["expressions.test_temporal_subtraction_chaining"], "coverage_files": ["django/db/models/expressions.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_post__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/models/expressions\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 expressions.test_temporal_subtraction_chaining", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}