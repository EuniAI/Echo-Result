{"instance_id": "django__django-14500", "repo": "django/django", "version": "4.0", "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4", "patch_list": ["diff --git a/tests/migrations/test_executor_squashed_bug.py b/tests/migrations/test_executor_squashed_bug.py\nnew file mode 100644\nindex 0000000000..1c88a54daa\n--- /dev/null\n+++ b/tests/migrations/test_executor_squashed_bug.py\n@@ -0,0 +1,877 @@\n+from unittest import mock\n+\n+from django.apps.registry import apps as global_apps\n+from django.db import DatabaseError, connection, migrations, models\n+from django.db.migrations.exceptions import InvalidMigrationPlan\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.graph import MigrationGraph\n+from django.db.migrations.recorder import MigrationRecorder\n+from django.db.migrations.state import ProjectState\n+from django.test import (\n+    SimpleTestCase, modify_settings, override_settings, skipUnlessDBFeature,\n+)\n+\n+from .test_base import MigrationTestBase\n+\n+\n+@modify_settings(INSTALLED_APPS={'append': 'migrations2'})\n+class ExecutorTests(MigrationTestBase):\n+    \"\"\"\n+    Tests the migration executor (full end-to-end running).\n+\n+    Bear in mind that if these are failing you should fix the other\n+    test failures first, as they may be propagating into here.\n+    \"\"\"\n+\n+    available_apps = [\"migrations\", \"migrations2\", \"django.contrib.auth\", \"django.contrib.contenttypes\"]\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_run(self):\n+        \"\"\"\n+        Tests running a simple set of migrations.\n+        \"\"\"\n+        executor = MigrationExecutor(connection)\n+        # Let's look at the plan first and make sure it's up to scratch\n+        plan = executor.migration_plan([(\"migrations\", \"0002_second\")])\n+        self.assertEqual(\n+            plan,\n+            [\n+                (executor.loader.graph.nodes[\"migrations\", \"0001_initial\"], False),\n+                (executor.loader.graph.nodes[\"migrations\", \"0002_second\"], False),\n+            ],\n+        )\n+        # Were the tables there before?\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_book\")\n+        # Alright, let's try running it\n+        executor.migrate([(\"migrations\", \"0002_second\")])\n+        # Are the tables there now?\n+        self.assertTableExists(\"migrations_author\")\n+        self.assertTableExists(\"migrations_book\")\n+        # Rebuild the graph to reflect the new DB state\n+        executor.loader.build_graph()\n+        # Alright, let's undo what we did\n+        plan = executor.migration_plan([(\"migrations\", None)])\n+        self.assertEqual(\n+            plan,\n+            [\n+                (executor.loader.graph.nodes[\"migrations\", \"0002_second\"], True),\n+                (executor.loader.graph.nodes[\"migrations\", \"0001_initial\"], True),\n+            ],\n+        )\n+        executor.migrate([(\"migrations\", None)])\n+        # Are the tables gone?\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_book\")\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"})\n+    def test_run_with_squashed(self):\n+        \"\"\"\n+        Tests running a squashed migration from zero (should ignore what it replaces)\n+        \"\"\"\n+        executor = MigrationExecutor(connection)\n+        # Check our leaf node is the squashed one\n+        leaves = [key for key in executor.loader.graph.leaf_nodes() if key[0] == \"migrations\"]\n+        self.assertEqual(leaves, [(\"migrations\", \"0001_squashed_0002\")])\n+        # Check the plan\n+        plan = executor.migration_plan([(\"migrations\", \"0001_squashed_0002\")])\n+        self.assertEqual(\n+            plan,\n+            [\n+                (executor.loader.graph.nodes[\"migrations\", \"0001_squashed_0002\"], False),\n+            ],\n+        )\n+        # Were the tables there before?\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_book\")\n+        # Alright, let's try running it\n+        executor.migrate([(\"migrations\", \"0001_squashed_0002\")])\n+        # Are the tables there now?\n+        self.assertTableExists(\"migrations_author\")\n+        self.assertTableExists(\"migrations_book\")\n+        # Rebuild the graph to reflect the new DB state\n+        executor.loader.build_graph()\n+        # Alright, let's undo what we did. Should also just use squashed.\n+        plan = executor.migration_plan([(\"migrations\", None)])\n+        self.assertEqual(\n+            plan,\n+            [\n+                (executor.loader.graph.nodes[\"migrations\", \"0001_squashed_0002\"], True),\n+            ],\n+        )\n+        executor.migrate([(\"migrations\", None)])\n+        # Are the tables gone?\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_book\")\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"})\n+    def test_unapply_squashed_migration_marks_as_unapplied(self):\n+        \"\"\"\n+        When a squashed migration is unapplied, it should be marked as\n+        unapplied in the migration recorder.\n+        \"\"\"\n+        executor = MigrationExecutor(connection)\n+        recorder = MigrationRecorder(connection)\n+        # Simulate the inconsistent state left by the bug: record the squashed\n+        # migration as applied, but not its replacements.\n+        recorder.record_applied(\"migrations\", \"0001_squashed_0002\")\n+\n+        self.assertIn((\"migrations\", \"0001_squashed_0002\"), recorder.applied_migrations())\n+\n+        # check_replacements() is called at the end of migrate() and should\n+        # fix the inconsistent state.\n+        executor.migrate([])\n+\n+        self.assertNotIn(\n+            (\"migrations\", \"0001_squashed_0002\"),\n+            recorder.applied_migrations(),\n+        )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_non_atomic\"})\n+    def test_non_atomic_migration(self):\n+        \"\"\"\n+        Applying a non-atomic migration works as expected.\n+        \"\"\"\n+        executor = MigrationExecutor(connection)\n+        with self.assertRaisesMessage(RuntimeError, \"Abort migration\"):\n+            executor.migrate([(\"migrations\", \"0001_initial\")])\n+        self.assertTableExists(\"migrations_publisher\")\n+        migrations_apps = executor.loader.project_state((\"migrations\", \"0001_initial\")).apps\n+        Publisher = migrations_apps.get_model(\"migrations\", \"Publisher\")\n+        self.assertTrue(Publisher.objects.exists())\n+        self.assertTableNotExists(\"migrations_book\")\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_atomic_operation\"})\n+    def test_atomic_operation_in_non_atomic_migration(self):\n+        \"\"\"\n+        An atomic operation is properly rolled back inside a non-atomic\n+        migration.\n+        \"\"\"\n+        executor = MigrationExecutor(connection)\n+        with self.assertRaisesMessage(RuntimeError, \"Abort migration\"):\n+            executor.migrate([(\"migrations\", \"0001_initial\")])\n+        migrations_apps = executor.loader.project_state((\"migrations\", \"0001_initial\")).apps\n+        Editor = migrations_apps.get_model(\"migrations\", \"Editor\")\n+        self.assertFalse(Editor.objects.exists())\n+        # Record previous migration as successful.\n+        executor.migrate([(\"migrations\", \"0001_initial\")], fake=True)\n+        # Rebuild the graph to reflect the new DB state.\n+        executor.loader.build_graph()\n+        # Migrating backwards is also atomic.\n+        with self.assertRaisesMessage(RuntimeError, \"Abort migration\"):\n+            executor.migrate([(\"migrations\", None)])\n+        self.assertFalse(Editor.objects.exists())\n+\n+    @override_settings(MIGRATION_MODULES={\n+        \"migrations\": \"migrations.test_migrations\",\n+        \"migrations2\": \"migrations2.test_migrations_2\",\n+    })\n+    def test_empty_plan(self):\n+        \"\"\"\n+        Re-planning a full migration of a fully-migrated set doesn't\n+        perform spurious unmigrations and remigrations.\n+\n+        There was previously a bug where the executor just always performed the\n+        backwards plan for applied migrations - which even for the most recent\n+        migration in an app, might include other, dependent apps, and these\n+        were being unmigrated.\n+        \"\"\"\n+        # Make the initial plan, check it\n+        executor = MigrationExecutor(connection)\n+        plan = executor.migration_plan([\n+            (\"migrations\", \"0002_second\"),\n+            (\"migrations2\", \"0001_initial\"),\n+        ])\n+        self.assertEqual(\n+            plan,\n+            [\n+                (executor.loader.graph.nodes[\"migrations\", \"0001_initial\"], False),\n+                (executor.loader.graph.nodes[\"migrations\", \"0002_second\"], False),\n+                (executor.loader.graph.nodes[\"migrations2\", \"0001_initial\"], False),\n+            ],\n+        )\n+        # Fake-apply all migrations\n+        executor.migrate([\n+            (\"migrations\", \"0002_second\"),\n+            (\"migrations2\", \"0001_initial\")\n+        ], fake=True)\n+        # Rebuild the graph to reflect the new DB state\n+        executor.loader.build_graph()\n+        # Now plan a second time and make sure it's empty\n+        plan = executor.migration_plan([\n+            (\"migrations\", \"0002_second\"),\n+            (\"migrations2\", \"0001_initial\"),\n+        ])\n+        self.assertEqual(plan, [])\n+        # The resulting state should include applied migrations.\n+        state = executor.migrate([\n+            (\"migrations\", \"0002_second\"),\n+            (\"migrations2\", \"0001_initial\"),\n+        ])\n+        self.assertIn(('migrations', 'book'), state.models)\n+        self.assertIn(('migrations', 'author'), state.models)\n+        self.assertIn(('migrations2', 'otherauthor'), state.models)\n+        # Erase all the fake records\n+        executor.recorder.record_unapplied(\"migrations2\", \"0001_initial\")\n+        executor.recorder.record_unapplied(\"migrations\", \"0002_second\")\n+        executor.recorder.record_unapplied(\"migrations\", \"0001_initial\")\n+\n+    @override_settings(MIGRATION_MODULES={\n+        \"migrations\": \"migrations.test_migrations\",\n+        \"migrations2\": \"migrations2.test_migrations_2_no_deps\",\n+    })\n+    def test_mixed_plan_not_supported(self):\n+        \"\"\"\n+        Although the MigrationExecutor interfaces allows for mixed migration\n+        plans (combined forwards and backwards migrations) this is not\n+        supported.\n+        \"\"\"\n+        # Prepare for mixed plan\n+        executor = MigrationExecutor(connection)\n+        plan = executor.migration_plan([(\"migrations\", \"0002_second\")])\n+        self.assertEqual(\n+            plan,\n+            [\n+                (executor.loader.graph.nodes[\"migrations\", \"0001_initial\"], False),\n+                (executor.loader.graph.nodes[\"migrations\", \"0002_second\"], False),\n+            ],\n+        )\n+        executor.migrate(None, plan)\n+        # Rebuild the graph to reflect the new DB state\n+        executor.loader.build_graph()\n+        self.assertIn(('migrations', '0001_initial'), executor.loader.applied_migrations)\n+        self.assertIn(('migrations', '0002_second'), executor.loader.applied_migrations)\n+        self.assertNotIn(('migrations2', '0001_initial'), executor.loader.applied_migrations)\n+\n+        # Generate mixed plan\n+        plan = executor.migration_plan([\n+            (\"migrations\", None),\n+            (\"migrations2\", \"0001_initial\"),\n+        ])\n+        msg = (\n+            'Migration plans with both forwards and backwards migrations are '\n+            'not supported. Please split your migration process into separate '\n+            'plans of only forwards OR backwards migrations.'\n+        )\n+        with self.assertRaisesMessage(InvalidMigrationPlan, msg) as cm:\n+            executor.migrate(None, plan)\n+        self.assertEqual(\n+            cm.exception.args[1],\n+            [\n+                (executor.loader.graph.nodes[\"migrations\", \"0002_second\"], True),\n+                (executor.loader.graph.nodes[\"migrations\", \"0001_initial\"], True),\n+                (executor.loader.graph.nodes[\"migrations2\", \"0001_initial\"], False),\n+            ],\n+        )\n+        # Rebuild the graph to reflect the new DB state\n+        executor.loader.build_graph()\n+        executor.migrate([\n+            (\"migrations\", None),\n+            (\"migrations2\", None),\n+        ])\n+        # Are the tables gone?\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_book\")\n+        self.assertTableNotExists(\"migrations2_otherauthor\")\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_soft_apply(self):\n+        \"\"\"\n+        Tests detection of initial migrations already having been applied.\n+        \"\"\"\n+        state = {\"faked\": None}\n+\n+        def fake_storer(phase, migration=None, fake=None):\n+            state[\"faked\"] = fake\n+        executor = MigrationExecutor(connection, progress_callback=fake_storer)\n+        # Were the tables there before?\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_tribble\")\n+        # Run it normally\n+        self.assertEqual(\n+            executor.migration_plan([(\"migrations\", \"0001_initial\")]),\n+            [\n+                (executor.loader.graph.nodes[\"migrations\", \"0001_initial\"], False),\n+            ],\n+        )\n+        executor.migrate([(\"migrations\", \"0001_initial\")])\n+        # Are the tables there now?\n+        self.assertTableExists(\"migrations_author\")\n+        self.assertTableExists(\"migrations_tribble\")\n+        # We shouldn't have faked that one\n+        self.assertIs(state[\"faked\"], False)\n+        # Rebuild the graph to reflect the new DB state\n+        executor.loader.build_graph()\n+        # Fake-reverse that\n+        executor.migrate([(\"migrations\", None)], fake=True)\n+        # Are the tables still there?\n+        self.assertTableExists(\"migrations_author\")\n+        self.assertTableExists(\"migrations_tribble\")\n+        # Make sure that was faked\n+        self.assertIs(state[\"faked\"], True)\n+        # Finally, migrate forwards; this should fake-apply our initial migration\n+        executor.loader.build_graph()\n+        self.assertEqual(\n+            executor.migration_plan([(\"migrations\", \"0001_initial\")]),\n+            [\n+                (executor.loader.graph.nodes[\"migrations\", \"0001_initial\"], False),\n+            ],\n+        )\n+        # Applying the migration should raise a database level error\n+        # because we haven't given the --fake-initial option\n+        with self.assertRaises(DatabaseError):\n+            executor.migrate([(\"migrations\", \"0001_initial\")])\n+        # Reset the faked state\n+        state = {\"faked\": None}\n+        # Allow faking of initial CreateModel operations\n+        executor.migrate([(\"migrations\", \"0001_initial\")], fake_initial=True)\n+        self.assertIs(state[\"faked\"], True)\n+        # And migrate back to clean up the database\n+        executor.loader.build_graph()\n+        executor.migrate([(\"migrations\", None)])\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_tribble\")\n+\n+    @override_settings(\n+        MIGRATION_MODULES={\n+            \"migrations\": \"migrations.test_migrations_custom_user\",\n+            \"django.contrib.auth\": \"django.contrib.auth.migrations\",\n+        },\n+        AUTH_USER_MODEL=\"migrations.Author\",\n+    )\n+    def test_custom_user(self):\n+        \"\"\"\n+        Regression test for #22325 - references to a custom user model defined in the\n+        same app are not resolved correctly.\n+        \"\"\"\n+        executor = MigrationExecutor(connection)\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_tribble\")\n+        # Migrate forwards\n+        executor.migrate([(\"migrations\", \"0001_initial\")])\n+        self.assertTableExists(\"migrations_author\")\n+        self.assertTableExists(\"migrations_tribble\")\n+        # Make sure the soft-application detection works (#23093)\n+        # Change table_names to not return auth_user during this as\n+        # it wouldn't be there in a normal run, and ensure migrations.Author\n+        # exists in the global app registry temporarily.\n+        old_table_names = connection.introspection.table_names\n+        connection.introspection.table_names = lambda c: [x for x in old_table_names(c) if x != \"auth_user\"]\n+        migrations_apps = executor.loader.project_state((\"migrations\", \"0001_initial\")).apps\n+        global_apps.get_app_config(\"migrations\").models[\"author\"] = migrations_apps.get_model(\"migrations\", \"author\")\n+        try:\n+            migration = executor.loader.get_migration(\"auth\", \"0001_initial\")\n+            self.assertIs(executor.detect_soft_applied(None, migration)[0], True)\n+        finally:\n+            connection.introspection.table_names = old_table_names\n+            del global_apps.get_app_config(\"migrations\").models[\"author\"]\n+        # And migrate back to clean up the database\n+        executor.loader.build_graph()\n+        executor.migrate([(\"migrations\", None)])\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_tribble\")\n+\n+    @override_settings(\n+        MIGRATION_MODULES={\n+            \"migrations\": \"migrations.test_add_many_to_many_field_initial\",\n+        },\n+    )\n+    def test_detect_soft_applied_add_field_manytomanyfield(self):\n+        \"\"\"\n+        executor.detect_soft_applied() detects ManyToManyField tables from an\n+        AddField operation. This checks the case of AddField in a migration\n+        with other operations (0001) and the case of AddField in its own\n+        migration (0002).\n+        \"\"\"\n+        tables = [\n+            # from 0001\n+            \"migrations_project\",\n+            \"migrations_task\",\n+            \"migrations_project_tasks\",\n+            # from 0002\n+            \"migrations_task_projects\",\n+        ]\n+        executor = MigrationExecutor(connection)\n+        # Create the tables for 0001 but make it look like the migration hasn't\n+        # been applied.\n+        executor.migrate([(\"migrations\", \"0001_initial\")])\n+        executor.migrate([(\"migrations\", None)], fake=True)\n+        for table in tables[:3]:\n+            self.assertTableExists(table)\n+        # Table detection sees 0001 is applied but not 0002.\n+        migration = executor.loader.get_migration(\"migrations\", \"0001_initial\")\n+        self.assertIs(executor.detect_soft_applied(None, migration)[0], True)\n+        migration = executor.loader.get_migration(\"migrations\", \"0002_initial\")\n+        self.assertIs(executor.detect_soft_applied(None, migration)[0], False)\n+\n+        # Create the tables for both migrations but make it look like neither\n+        # has been applied.\n+        executor.loader.build_graph()\n+        executor.migrate([(\"migrations\", \"0001_initial\")], fake=True)\n+        executor.migrate([(\"migrations\", \"0002_initial\")])\n+        executor.loader.build_graph()\n+        executor.migrate([(\"migrations\", None)], fake=True)\n+        # Table detection sees 0002 is applied.\n+        migration = executor.loader.get_migration(\"migrations\", \"0002_initial\")\n+        self.assertIs(executor.detect_soft_applied(None, migration)[0], True)\n+\n+        # Leave the tables for 0001 except the many-to-many table. That missing\n+        # table should cause detect_soft_applied() to return False.\n+        with connection.schema_editor() as editor:\n+            for table in tables[2:]:\n+                editor.execute(editor.sql_delete_table % {\"table\": table})\n+        migration = executor.loader.get_migration(\"migrations\", \"0001_initial\")\n+        self.assertIs(executor.detect_soft_applied(None, migration)[0], False)\n+\n+        # Cleanup by removing the remaining tables.\n+        with connection.schema_editor() as editor:\n+            for table in tables[:2]:\n+                editor.execute(editor.sql_delete_table % {\"table\": table})\n+        for table in tables:\n+            self.assertTableNotExists(table)\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"migrations.migrations_test_apps.lookuperror_a\",\n+            \"migrations.migrations_test_apps.lookuperror_b\",\n+            \"migrations.migrations_test_apps.lookuperror_c\"\n+        ]\n+    )\n+    def test_unrelated_model_lookups_forwards(self):\n+        \"\"\"\n+        #24123 - All models of apps already applied which are\n+        unrelated to the first app being applied are part of the initial model\n+        state.\n+        \"\"\"\n+        try:\n+            executor = MigrationExecutor(connection)\n+            self.assertTableNotExists(\"lookuperror_a_a1\")\n+            self.assertTableNotExists(\"lookuperror_b_b1\")\n+            self.assertTableNotExists(\"lookuperror_c_c1\")\n+            executor.migrate([(\"lookuperror_b\", \"0003_b3\")])\n+            self.assertTableExists(\"lookuperror_b_b3\")\n+            # Rebuild the graph to reflect the new DB state\n+            executor.loader.build_graph()\n+\n+            # Migrate forwards -- This led to a lookup LookupErrors because\n+            # lookuperror_b.B2 is already applied\n+            executor.migrate([\n+                (\"lookuperror_a\", \"0004_a4\"),\n+                (\"lookuperror_c\", \"0003_c3\"),\n+            ])\n+            self.assertTableExists(\"lookuperror_a_a4\")\n+            self.assertTableExists(\"lookuperror_c_c3\")\n+\n+            # Rebuild the graph to reflect the new DB state\n+            executor.loader.build_graph()\n+        finally:\n+            # Cleanup\n+            executor.migrate([\n+                (\"lookuperror_a\", None),\n+                (\"lookuperror_b\", None),\n+                (\"lookuperror_c\", None),\n+            ])\n+            self.assertTableNotExists(\"lookuperror_a_a1\")\n+            self.assertTableNotExists(\"lookuperror_b_b1\")\n+            self.assertTableNotExists(\"lookuperror_c_c1\")\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"migrations.migrations_test_apps.lookuperror_a\",\n+            \"migrations.migrations_test_apps.lookuperror_b\",\n+            \"migrations.migrations_test_apps.lookuperror_c\"\n+        ]\n+    )\n+    def test_unrelated_model_lookups_backwards(self):\n+        \"\"\"\n+        #24123 - All models of apps being unapplied which are\n+        unrelated to the first app being unapplied are part of the initial\n+        model state.\n+        \"\"\"\n+        try:\n+            executor = MigrationExecutor(connection)\n+            self.assertTableNotExists(\"lookuperror_a_a1\")\n+            self.assertTableNotExists(\"lookuperror_b_b1\")\n+            self.assertTableNotExists(\"lookuperror_c_c1\")\n+            executor.migrate([\n+                (\"lookuperror_a\", \"0004_a4\"),\n+                (\"lookuperror_b\", \"0003_b3\"),\n+                (\"lookuperror_c\", \"0003_c3\"),\n+            ])\n+            self.assertTableExists(\"lookuperror_b_b3\")\n+            self.assertTableExists(\"lookuperror_a_a4\")\n+            self.assertTableExists(\"lookuperror_c_c3\")\n+            # Rebuild the graph to reflect the new DB state\n+            executor.loader.build_graph()\n+\n+            # Migrate backwards -- This led to a lookup LookupErrors because\n+            # lookuperror_b.B2 is not in the initial state (unrelated to app c)\n+            executor.migrate([(\"lookuperror_a\", None)])\n+\n+            # Rebuild the graph to reflect the new DB state\n+            executor.loader.build_graph()\n+        finally:\n+            # Cleanup\n+            executor.migrate([\n+                (\"lookuperror_b\", None),\n+                (\"lookuperror_c\", None)\n+            ])\n+            self.assertTableNotExists(\"lookuperror_a_a1\")\n+            self.assertTableNotExists(\"lookuperror_b_b1\")\n+            self.assertTableNotExists(\"lookuperror_c_c1\")\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            'migrations.migrations_test_apps.mutate_state_a',\n+            'migrations.migrations_test_apps.mutate_state_b',\n+        ]\n+    )\n+    def test_unrelated_applied_migrations_mutate_state(self):\n+        \"\"\"\n+        #26647 - Unrelated applied migrations should be part of the final\n+        state in both directions.\n+        \"\"\"\n+        executor = MigrationExecutor(connection)\n+        executor.migrate([\n+            ('mutate_state_b', '0002_add_field'),\n+        ])\n+        # Migrate forward.\n+        executor.loader.build_graph()\n+        state = executor.migrate([\n+            ('mutate_state_a', '0001_initial'),\n+        ])\n+        self.assertIn('added', state.models['mutate_state_b', 'b'].fields)\n+        executor.loader.build_graph()\n+        # Migrate backward.\n+        state = executor.migrate([\n+            ('mutate_state_a', None),\n+        ])\n+        self.assertIn('added', state.models['mutate_state_b', 'b'].fields)\n+        executor.migrate([\n+            ('mutate_state_b', None),\n+        ])\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_process_callback(self):\n+        \"\"\"\n+        #24129 - Tests callback process\n+        \"\"\"\n+        call_args_list = []\n+\n+        def callback(*args):\n+            call_args_list.append(args)\n+\n+        executor = MigrationExecutor(connection, progress_callback=callback)\n+        # Were the tables there before?\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_tribble\")\n+        executor.migrate([\n+            (\"migrations\", \"0001_initial\"),\n+            (\"migrations\", \"0002_second\"),\n+        ])\n+        # Rebuild the graph to reflect the new DB state\n+        executor.loader.build_graph()\n+\n+        executor.migrate([\n+            (\"migrations\", None),\n+            (\"migrations\", None),\n+        ])\n+        self.assertTableNotExists(\"migrations_author\")\n+        self.assertTableNotExists(\"migrations_tribble\")\n+\n+        migrations = executor.loader.graph.nodes\n+        expected = [\n+            (\"render_start\",),\n+            (\"render_success\",),\n+            (\"apply_start\", migrations['migrations', '0001_initial'], False),\n+            (\"apply_success\", migrations['migrations', '0001_initial'], False),\n+            (\"apply_start\", migrations['migrations', '0002_second'], False),\n+            (\"apply_success\", migrations['migrations', '0002_second'], False),\n+            (\"render_start\",),\n+            (\"render_success\",),\n+            (\"unapply_start\", migrations['migrations', '0002_second'], False),\n+            (\"unapply_success\", migrations['migrations', '0002_second'], False),\n+            (\"unapply_start\", migrations['migrations', '0001_initial'], False),\n+            (\"unapply_success\", migrations['migrations', '0001_initial'], False),\n+        ]\n+        self.assertEqual(call_args_list, expected)\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"migrations.migrations_test_apps.alter_fk.author_app\",\n+            \"migrations.migrations_test_apps.alter_fk.book_app\",\n+        ]\n+    )\n+    def test_alter_id_type_with_fk(self):\n+        try:\n+            executor = MigrationExecutor(connection)\n+            self.assertTableNotExists(\"author_app_author\")\n+            self.assertTableNotExists(\"book_app_book\")\n+            # Apply initial migrations\n+            executor.migrate([\n+                (\"author_app\", \"0001_initial\"),\n+                (\"book_app\", \"0001_initial\"),\n+            ])\n+            self.assertTableExists(\"author_app_author\")\n+            self.assertTableExists(\"book_app_book\")\n+            # Rebuild the graph to reflect the new DB state\n+            executor.loader.build_graph()\n+\n+            # Apply PK type alteration\n+            executor.migrate([(\"author_app\", \"0002_alter_id\")])\n+\n+            # Rebuild the graph to reflect the new DB state\n+            executor.loader.build_graph()\n+        finally:\n+            # We can't simply unapply the migrations here because there is no\n+            # implicit cast from VARCHAR to INT on the database level.\n+            with connection.schema_editor() as editor:\n+                editor.execute(editor.sql_delete_table % {\"table\": \"book_app_book\"})\n+                editor.execute(editor.sql_delete_table % {\"table\": \"author_app_author\"})\n+            self.assertTableNotExists(\"author_app_author\")\n+            self.assertTableNotExists(\"book_app_book\")\n+            executor.migrate([(\"author_app\", None)], fake=True)\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"})\n+    def test_apply_all_replaced_marks_replacement_as_applied(self):\n+        \"\"\"\n+        Applying all replaced migrations marks replacement as applied (#24628).\n+        \"\"\"\n+        recorder = MigrationRecorder(connection)\n+        # Place the database in a state where the replaced migrations are\n+        # partially applied: 0001 is applied, 0002 is not.\n+        recorder.record_applied(\"migrations\", \"0001_initial\")\n+        executor = MigrationExecutor(connection)\n+        # Use fake because we don't actually have the first migration\n+        # applied, so the second will fail. And there's no need to actually\n+        # create/modify tables here, we're just testing the\n+        # MigrationRecord, which works the same with or without fake.\n+        executor.migrate([(\"migrations\", \"0002_second\")], fake=True)\n+\n+        # Because we've now applied 0001 and 0002 both, their squashed\n+        # replacement should be marked as applied.\n+        self.assertIn(\n+            (\"migrations\", \"0001_squashed_0002\"),\n+            recorder.applied_migrations(),\n+        )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"})\n+    def test_migrate_marks_replacement_applied_even_if_it_did_nothing(self):\n+        \"\"\"\n+        A new squash migration will be marked as applied even if all its\n+        replaced migrations were previously already applied (#24628).\n+        \"\"\"\n+        recorder = MigrationRecorder(connection)\n+        # Record all replaced migrations as applied\n+        recorder.record_applied(\"migrations\", \"0001_initial\")\n+        recorder.record_applied(\"migrations\", \"0002_second\")\n+        executor = MigrationExecutor(connection)\n+        executor.migrate([(\"migrations\", \"0001_squashed_0002\")])\n+\n+        # Because 0001 and 0002 are both applied, even though this migrate run\n+        # didn't apply anything new, their squashed replacement should be\n+        # marked as applied.\n+        self.assertIn(\n+            (\"migrations\", \"0001_squashed_0002\"),\n+            recorder.applied_migrations(),\n+        )\n+\n+    # When the feature is False, the operation and the record won't be\n+    # performed in a transaction and the test will systematically pass.\n+    @skipUnlessDBFeature('can_rollback_ddl')\n+    def test_migrations_applied_and_recorded_atomically(self):\n+        \"\"\"Migrations are applied and recorded atomically.\"\"\"\n+        class Migration(migrations.Migration):\n+            operations = [\n+                migrations.CreateModel('model', [\n+                    ('id', models.AutoField(primary_key=True)),\n+                ]),\n+            ]\n+\n+        executor = MigrationExecutor(connection)\n+        with mock.patch('django.db.migrations.executor.MigrationExecutor.record_migration') as record_migration:\n+            record_migration.side_effect = RuntimeError('Recording migration failed.')\n+            with self.assertRaisesMessage(RuntimeError, 'Recording migration failed.'):\n+                executor.apply_migration(\n+                    ProjectState(),\n+                    Migration('0001_initial', 'record_migration'),\n+                )\n+                executor.migrate([('migrations', '0001_initial')])\n+        # The migration isn't recorded as applied since it failed.\n+        migration_recorder = MigrationRecorder(connection)\n+        self.assertIs(\n+            migration_recorder.migration_qs.filter(\n+                app='record_migration', name='0001_initial',\n+            ).exists(),\n+            False,\n+        )\n+        self.assertTableNotExists('record_migration_model')\n+\n+    def test_migrations_not_applied_on_deferred_sql_failure(self):\n+        \"\"\"Migrations are not recorded if deferred SQL application fails.\"\"\"\n+        class DeferredSQL:\n+            def __str__(self):\n+                raise DatabaseError('Failed to apply deferred SQL')\n+\n+        class Migration(migrations.Migration):\n+            atomic = False\n+\n+            def apply(self, project_state, schema_editor, collect_sql=False):\n+                schema_editor.deferred_sql.append(DeferredSQL())\n+\n+        executor = MigrationExecutor(connection)\n+        with self.assertRaisesMessage(DatabaseError, 'Failed to apply deferred SQL'):\n+            executor.apply_migration(\n+                ProjectState(),\n+                Migration('0001_initial', 'deferred_sql'),\n+            )\n+        # The migration isn't recorded as applied since it failed.\n+        migration_recorder = MigrationRecorder(connection)\n+        self.assertIs(\n+            migration_recorder.migration_qs.filter(\n+                app='deferred_sql', name='0001_initial',\n+            ).exists(),\n+            False,\n+        )\n+\n+\n+class FakeLoader:\n+    def __init__(self, graph, applied):\n+        self.graph = graph\n+        self.applied_migrations = applied\n+\n+\n+class FakeMigration:\n+    \"\"\"Really all we need is any object with a debug-useful repr.\"\"\"\n+    def __init__(self, name):\n+        self.name = name\n+\n+    def __repr__(self):\n+        return 'M<%s>' % self.name\n+\n+\n+class ExecutorUnitTests(SimpleTestCase):\n+    \"\"\"(More) isolated unit tests for executor methods.\"\"\"\n+    def test_minimize_rollbacks(self):\n+        \"\"\"\n+        Minimize unnecessary rollbacks in connected apps.\n+\n+        When you say \"./manage.py migrate appA 0001\", rather than migrating to\n+        just after appA-0001 in the linearized migration plan (which could roll\n+        back migrations in other apps that depend on appA 0001, but don't need\n+        to be rolled back since we're not rolling back appA 0001), we migrate\n+        to just before appA-0002.\n+        \"\"\"\n+        a1_impl = FakeMigration('a1')\n+        a1 = ('a', '1')\n+        a2_impl = FakeMigration('a2')\n+        a2 = ('a', '2')\n+        b1_impl = FakeMigration('b1')\n+        b1 = ('b', '1')\n+        graph = MigrationGraph()\n+        graph.add_node(a1, a1_impl)\n+        graph.add_node(a2, a2_impl)\n+        graph.add_node(b1, b1_impl)\n+        graph.add_dependency(None, b1, a1)\n+        graph.add_dependency(None, a2, a1)\n+\n+        executor = MigrationExecutor(None)\n+        executor.loader = FakeLoader(graph, {\n+            a1: a1_impl,\n+            b1: b1_impl,\n+            a2: a2_impl,\n+        })\n+\n+        plan = executor.migration_plan({a1})\n+\n+        self.assertEqual(plan, [(a2_impl, True)])\n+\n+    def test_minimize_rollbacks_branchy(self):\n+        r\"\"\"\n+        Minimize rollbacks when target has multiple in-app children.\n+\n+        a: 1 <---- 3 <--\\\n+              \\ \\- 2 <--- 4\n+               \\       \\\n+        b:      \\- 1 <--- 2\n+        \"\"\"\n+        a1_impl = FakeMigration('a1')\n+        a1 = ('a', '1')\n+        a2_impl = FakeMigration('a2')\n+        a2 = ('a', '2')\n+        a3_impl = FakeMigration('a3')\n+        a3 = ('a', '3')\n+        a4_impl = FakeMigration('a4')\n+        a4 = ('a', '4')\n+        b1_impl = FakeMigration('b1')\n+        b1 = ('b', '1')\n+        b2_impl = FakeMigration('b2')\n+        b2 = ('b', '2')\n+        graph = MigrationGraph()\n+        graph.add_node(a1, a1_impl)\n+        graph.add_node(a2, a2_impl)\n+        graph.add_node(a3, a3_impl)\n+        graph.add_node(a4, a4_impl)\n+        graph.add_node(b1, b1_impl)\n+        graph.add_node(b2, b2_impl)\n+        graph.add_dependency(None, a2, a1)\n+        graph.add_dependency(None, a3, a1)\n+        graph.add_dependency(None, a4, a2)\n+        graph.add_dependency(None, a4, a3)\n+        graph.add_dependency(None, b2, b1)\n+        graph.add_dependency(None, b1, a1)\n+        graph.add_dependency(None, b2, a2)\n+\n+        executor = MigrationExecutor(None)\n+        executor.loader = FakeLoader(graph, {\n+            a1: a1_impl,\n+            b1: b1_impl,\n+            a2: a2_impl,\n+            b2: b2_impl,\n+            a3: a3_impl,\n+            a4: a4_impl,\n+        })\n+\n+        plan = executor.migration_plan({a1})\n+\n+        should_be_rolled_back = [b2_impl, a4_impl, a2_impl, a3_impl]\n+        exp = [(m, True) for m in should_be_rolled_back]\n+        self.assertEqual(plan, exp)\n+\n+    def test_backwards_nothing_to_do(self):\n+        r\"\"\"\n+        If the current state satisfies the given target, do nothing.\n+\n+        a: 1 <--- 2\n+        b:    \\- 1\n+        c:     \\- 1\n+\n+        If a1 is applied already and a2 is not, and we're asked to migrate to\n+        a1, don't apply or unapply b1 or c1, regardless of their current state.\n+        \"\"\"\n+        a1_impl = FakeMigration('a1')\n+        a1 = ('a', '1')\n+        a2_impl = FakeMigration('a2')\n+        a2 = ('a', '2')\n+        b1_impl = FakeMigration('b1')\n+        b1 = ('b', '1')\n+        c1_impl = FakeMigration('c1')\n+        c1 = ('c', '1')\n+        graph = MigrationGraph()\n+        graph.add_node(a1, a1_impl)\n+        graph.add_node(a2, a2_impl)\n+        graph.add_node(b1, b1_impl)\n+        graph.add_node(c1, c1_impl)\n+        graph.add_dependency(None, a2, a1)\n+        graph.add_dependency(None, b1, a1)\n+        graph.add_dependency(None, c1, a1)\n+\n+        executor = MigrationExecutor(None)\n+        executor.loader = FakeLoader(graph, {\n+            a1: a1_impl,\n+            b1: b1_impl,\n+        })\n+\n+        plan = executor.migration_plan({a1})\n+\n+        self.assertEqual(plan, [])\n"], "arch": "x86_64", "base_commit": "8c3bd0b708b488a1f6e8bd8cc6b96569904605be", "test_directives": ["migrations.test_executor_squashed_bug"], "coverage_files": ["django/db/migrations/executor.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.8", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/migrations/executor\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 migrations.test_executor_squashed_bug", "req_install_commands": ["conda create -n testbed python=3.8 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}