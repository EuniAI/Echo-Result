{"instance_id": "django__django-16256", "repo": "django/django", "version": "4.2", "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5", "patch_list": ["diff --git a/get_or_create/tests.py b/get_or_create/tests.py\nnew file mode 100644\nindex 0000000000..ab81fee044\n--- /dev/null\n+++ b/get_or_create/tests.py\n@@ -0,0 +1,716 @@\n+import time\n+import traceback\n+from datetime import date, datetime, timedelta\n+from threading import Thread\n+\n+from django.core.exceptions import FieldError\n+from django.db import DatabaseError, IntegrityError, connection\n+from django.test import TestCase, TransactionTestCase, skipUnlessDBFeature\n+from django.test.utils import CaptureQueriesContext\n+from django.utils.functional import lazy\n+\n+from .models import (\n+    Author,\n+    Book,\n+    DefaultPerson,\n+    Journalist,\n+    ManualPrimaryKeyTest,\n+    Person,\n+    Profile,\n+    Publisher,\n+    Tag,\n+    Thing,\n+)\n+\n+\n+class GetOrCreateTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        Person.objects.create(\n+            first_name=\"John\", last_name=\"Lennon\", birthday=date(1940, 10, 9)\n+        )\n+\n+    def test_get_or_create_method_with_get(self):\n+        created = Person.objects.get_or_create(\n+            first_name=\"John\",\n+            last_name=\"Lennon\",\n+            defaults={\"birthday\": date(1940, 10, 9)},\n+        )[1]\n+        self.assertFalse(created)\n+        self.assertEqual(Person.objects.count(), 1)\n+\n+    def test_get_or_create_method_with_create(self):\n+        created = Person.objects.get_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            defaults={\"birthday\": date(1943, 2, 25)},\n+        )[1]\n+        self.assertTrue(created)\n+        self.assertEqual(Person.objects.count(), 2)\n+\n+    def test_get_or_create_redundant_instance(self):\n+        \"\"\"\n+        If we execute the exact same statement twice, the second time,\n+        it won't create a Person.\n+        \"\"\"\n+        Person.objects.get_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            defaults={\"birthday\": date(1943, 2, 25)},\n+        )\n+        created = Person.objects.get_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            defaults={\"birthday\": date(1943, 2, 25)},\n+        )[1]\n+\n+        self.assertFalse(created)\n+        self.assertEqual(Person.objects.count(), 2)\n+\n+    def test_get_or_create_invalid_params(self):\n+        \"\"\"\n+        If you don't specify a value or default value for all required\n+        fields, you will get an error.\n+        \"\"\"\n+        with self.assertRaises(IntegrityError):\n+            Person.objects.get_or_create(first_name=\"Tom\", last_name=\"Smith\")\n+\n+    def test_get_or_create_with_pk_property(self):\n+        \"\"\"\n+        Using the pk property of a model is allowed.\n+        \"\"\"\n+        Thing.objects.get_or_create(pk=1)\n+\n+    def test_get_or_create_with_model_property_defaults(self):\n+        \"\"\"Using a property with a setter implemented is allowed.\"\"\"\n+        t, _ = Thing.objects.get_or_create(\n+            defaults={\"capitalized_name_property\": \"annie\"}, pk=1\n+        )\n+        self.assertEqual(t.name, \"Annie\")\n+\n+    def test_get_or_create_on_related_manager(self):\n+        p = Publisher.objects.create(name=\"Acme Publishing\", num_awards=1)\n+        # Create a book through the publisher.\n+        book, created = p.books.get_or_create(name=\"The Book of Ed & Fred\")\n+        self.assertTrue(created)\n+        # The publisher should have one book.\n+        self.assertEqual(p.books.count(), 1)\n+\n+        # Try get_or_create again, this time nothing should be created.\n+        book, created = p.books.get_or_create(name=\"The Book of Ed & Fred\")\n+        self.assertFalse(created)\n+        # And the publisher should still have one book.\n+        self.assertEqual(p.books.count(), 1)\n+\n+        # Add an author to the book.\n+        ed, created = book.authors.get_or_create(name=\"Ed\")\n+        self.assertTrue(created)\n+        # The book should have one author.\n+        self.assertEqual(book.authors.count(), 1)\n+\n+        # Try get_or_create again, this time nothing should be created.\n+        ed, created = book.authors.get_or_create(name=\"Ed\")\n+        self.assertFalse(created)\n+        # And the book should still have one author.\n+        self.assertEqual(book.authors.count(), 1)\n+\n+        # Add a second author to the book.\n+        fred, created = book.authors.get_or_create(name=\"Fred\")\n+        self.assertTrue(created)\n+\n+        # The book should have two authors now.\n+        self.assertEqual(book.authors.count(), 2)\n+\n+        # Create an Author not tied to any books.\n+        Author.objects.create(name=\"Ted\")\n+\n+        # There should be three Authors in total. The book object should have two.\n+        self.assertEqual(Author.objects.count(), 3)\n+        self.assertEqual(book.authors.count(), 2)\n+\n+        # Try creating a book through an author.\n+        _, created = ed.books.get_or_create(name=\"Ed's Recipes\", publisher=p)\n+        self.assertTrue(created)\n+\n+        # Now Ed has two Books, Fred just one.\n+        self.assertEqual(ed.books.count(), 2)\n+        self.assertEqual(fred.books.count(), 1)\n+\n+        # Use the publisher's primary key value instead of a model instance.\n+        _, created = ed.books.get_or_create(\n+            name=\"The Great Book of Ed\", publisher_id=p.id\n+        )\n+        self.assertTrue(created)\n+\n+        # Try get_or_create again, this time nothing should be created.\n+        _, created = ed.books.get_or_create(\n+            name=\"The Great Book of Ed\", publisher_id=p.id\n+        )\n+        self.assertFalse(created)\n+\n+        # The publisher should have three books.\n+        self.assertEqual(p.books.count(), 3)\n+\n+    def test_defaults_exact(self):\n+        \"\"\"\n+        If you have a field named defaults and want to use it as an exact\n+        lookup, you need to use 'defaults__exact'.\n+        \"\"\"\n+        obj, created = Person.objects.get_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            defaults__exact=\"testing\",\n+            defaults={\n+                \"birthday\": date(1943, 2, 25),\n+                \"defaults\": \"testing\",\n+            },\n+        )\n+        self.assertTrue(created)\n+        self.assertEqual(obj.defaults, \"testing\")\n+        obj2, created = Person.objects.get_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            defaults__exact=\"testing\",\n+            defaults={\n+                \"birthday\": date(1943, 2, 25),\n+                \"defaults\": \"testing\",\n+            },\n+        )\n+        self.assertFalse(created)\n+        self.assertEqual(obj, obj2)\n+\n+    def test_callable_defaults(self):\n+        \"\"\"\n+        Callables in `defaults` are evaluated if the instance is created.\n+        \"\"\"\n+        obj, created = Person.objects.get_or_create(\n+            first_name=\"George\",\n+            defaults={\"last_name\": \"Harrison\", \"birthday\": lambda: date(1943, 2, 25)},\n+        )\n+        self.assertTrue(created)\n+        self.assertEqual(date(1943, 2, 25), obj.birthday)\n+\n+    def test_callable_defaults_not_called(self):\n+        def raise_exception():\n+            raise AssertionError\n+\n+        obj, created = Person.objects.get_or_create(\n+            first_name=\"John\",\n+            last_name=\"Lennon\",\n+            defaults={\"birthday\": lambda: raise_exception()},\n+        )\n+\n+    def test_defaults_not_evaluated_unless_needed(self):\n+        \"\"\"`defaults` aren't evaluated if the instance isn't created.\"\"\"\n+\n+        def raise_exception():\n+            raise AssertionError\n+\n+        obj, created = Person.objects.get_or_create(\n+            first_name=\"John\",\n+            defaults=lazy(raise_exception, object)(),\n+        )\n+        self.assertFalse(created)\n+\n+\n+class GetOrCreateTestsWithManualPKs(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        ManualPrimaryKeyTest.objects.create(id=1, data=\"Original\")\n+\n+    def test_create_with_duplicate_primary_key(self):\n+        \"\"\"\n+        If you specify an existing primary key, but different other fields,\n+        then you will get an error and data will not be updated.\n+        \"\"\"\n+        with self.assertRaises(IntegrityError):\n+            ManualPrimaryKeyTest.objects.get_or_create(id=1, data=\"Different\")\n+        self.assertEqual(ManualPrimaryKeyTest.objects.get(id=1).data, \"Original\")\n+\n+    def test_get_or_create_raises_IntegrityError_plus_traceback(self):\n+        \"\"\"\n+        get_or_create should raise IntegrityErrors with the full traceback.\n+        This is tested by checking that a known method call is in the traceback.\n+        We cannot use assertRaises here because we need to inspect\n+        the actual traceback. Refs #16340.\n+        \"\"\"\n+        try:\n+            ManualPrimaryKeyTest.objects.get_or_create(id=1, data=\"Different\")\n+        except IntegrityError:\n+            formatted_traceback = traceback.format_exc()\n+            self.assertIn(\"obj.save\", formatted_traceback)\n+\n+    def test_savepoint_rollback(self):\n+        \"\"\"\n+        The database connection is still usable after a DatabaseError in\n+        get_or_create() (#20463).\n+        \"\"\"\n+        Tag.objects.create(text=\"foo\")\n+        with self.assertRaises(DatabaseError):\n+            # pk 123456789 doesn't exist, so the tag object will be created.\n+            # Saving triggers a unique constraint violation on 'text'.\n+            Tag.objects.get_or_create(pk=123456789, defaults={\"text\": \"foo\"})\n+        # Tag objects can be created after the error.\n+        Tag.objects.create(text=\"bar\")\n+\n+    def test_get_or_create_empty(self):\n+        \"\"\"\n+        If all the attributes on a model have defaults, get_or_create() doesn't\n+        require any arguments.\n+        \"\"\"\n+        DefaultPerson.objects.get_or_create()\n+\n+\n+class GetOrCreateTransactionTests(TransactionTestCase):\n+\n+    available_apps = [\"get_or_create\"]\n+\n+    def test_get_or_create_integrityerror(self):\n+        \"\"\"\n+        Regression test for #15117. Requires a TransactionTestCase on\n+        databases that delay integrity checks until the end of transactions,\n+        otherwise the exception is never raised.\n+        \"\"\"\n+        try:\n+            Profile.objects.get_or_create(person=Person(id=1))\n+        except IntegrityError:\n+            pass\n+        else:\n+            self.skipTest(\"This backend does not support integrity checks.\")\n+\n+\n+class GetOrCreateThroughManyToMany(TestCase):\n+    def test_get_get_or_create(self):\n+        tag = Tag.objects.create(text=\"foo\")\n+        a_thing = Thing.objects.create(name=\"a\")\n+        a_thing.tags.add(tag)\n+        obj, created = a_thing.tags.get_or_create(text=\"foo\")\n+\n+        self.assertFalse(created)\n+        self.assertEqual(obj.pk, tag.pk)\n+\n+    def test_create_get_or_create(self):\n+        a_thing = Thing.objects.create(name=\"a\")\n+        obj, created = a_thing.tags.get_or_create(text=\"foo\")\n+\n+        self.assertTrue(created)\n+        self.assertEqual(obj.text, \"foo\")\n+        self.assertIn(obj, a_thing.tags.all())\n+\n+    def test_something(self):\n+        Tag.objects.create(text=\"foo\")\n+        a_thing = Thing.objects.create(name=\"a\")\n+        with self.assertRaises(IntegrityError):\n+            a_thing.tags.get_or_create(text=\"foo\")\n+\n+\n+class UpdateOrCreateTests(TestCase):\n+    def test_update(self):\n+        Person.objects.create(\n+            first_name=\"John\", last_name=\"Lennon\", birthday=date(1940, 10, 9)\n+        )\n+        p, created = Person.objects.update_or_create(\n+            first_name=\"John\",\n+            last_name=\"Lennon\",\n+            defaults={\"birthday\": date(1940, 10, 10)},\n+        )\n+        self.assertFalse(created)\n+        self.assertEqual(p.first_name, \"John\")\n+        self.assertEqual(p.last_name, \"Lennon\")\n+        self.assertEqual(p.birthday, date(1940, 10, 10))\n+\n+    def test_create(self):\n+        p, created = Person.objects.update_or_create(\n+            first_name=\"John\",\n+            last_name=\"Lennon\",\n+            defaults={\"birthday\": date(1940, 10, 10)},\n+        )\n+        self.assertTrue(created)\n+        self.assertEqual(p.first_name, \"John\")\n+        self.assertEqual(p.last_name, \"Lennon\")\n+        self.assertEqual(p.birthday, date(1940, 10, 10))\n+\n+    def test_create_twice(self):\n+        params = {\n+            \"first_name\": \"John\",\n+            \"last_name\": \"Lennon\",\n+            \"birthday\": date(1940, 10, 10),\n+        }\n+        Person.objects.update_or_create(**params)\n+        # If we execute the exact same statement, it won't create a Person.\n+        p, created = Person.objects.update_or_create(**params)\n+        self.assertFalse(created)\n+\n+    def test_integrity(self):\n+        \"\"\"\n+        If you don't specify a value or default value for all required\n+        fields, you will get an error.\n+        \"\"\"\n+        with self.assertRaises(IntegrityError):\n+            Person.objects.update_or_create(first_name=\"Tom\", last_name=\"Smith\")\n+\n+    def test_manual_primary_key_test(self):\n+        \"\"\"\n+        If you specify an existing primary key, but different other fields,\n+        then you will get an error and data will not be updated.\n+        \"\"\"\n+        ManualPrimaryKeyTest.objects.create(id=1, data=\"Original\")\n+        with self.assertRaises(IntegrityError):\n+            ManualPrimaryKeyTest.objects.update_or_create(id=1, data=\"Different\")\n+        self.assertEqual(ManualPrimaryKeyTest.objects.get(id=1).data, \"Original\")\n+\n+    def test_with_pk_property(self):\n+        \"\"\"\n+        Using the pk property of a model is allowed.\n+        \"\"\"\n+        Thing.objects.update_or_create(pk=1)\n+\n+    def test_update_or_create_with_model_property_defaults(self):\n+        \"\"\"Using a property with a setter implemented is allowed.\"\"\"\n+        t, _ = Thing.objects.update_or_create(\n+            defaults={\"capitalized_name_property\": \"annie\"}, pk=1\n+        )\n+        self.assertEqual(t.name, \"Annie\")\n+\n+    def test_error_contains_full_traceback(self):\n+        \"\"\"\n+        update_or_create should raise IntegrityErrors with the full traceback.\n+        This is tested by checking that a known method call is in the traceback.\n+        We cannot use assertRaises/assertRaises here because we need to inspect\n+        the actual traceback. Refs #16340.\n+        \"\"\"\n+        try:\n+            ManualPrimaryKeyTest.objects.update_or_create(id=1, data=\"Different\")\n+        except IntegrityError:\n+            formatted_traceback = traceback.format_exc()\n+            self.assertIn(\"obj.save\", formatted_traceback)\n+\n+    def test_create_with_related_manager(self):\n+        \"\"\"\n+        Should be able to use update_or_create from the related manager to\n+        create a book. Refs #23611.\n+        \"\"\"\n+        p = Publisher.objects.create(name=\"Acme Publishing\", num_awards=1)\n+        book, created = p.books.update_or_create(name=\"The Book of Ed & Fred\")\n+        self.assertTrue(created)\n+        self.assertEqual(p.books.count(), 1)\n+\n+    def test_update_with_related_manager(self):\n+        \"\"\"\n+        Should be able to use update_or_create from the related manager to\n+        update a book. Refs #23611.\n+        \"\"\"\n+        p = Publisher.objects.create(name=\"Acme Publishing\", num_awards=1)\n+        book = Book.objects.create(name=\"The Book of Ed & Fred\", publisher=p)\n+        self.assertEqual(p.books.count(), 1)\n+        name = \"The Book of Django\"\n+        book, created = p.books.update_or_create(defaults={\"name\": name}, id=book.id)\n+        self.assertFalse(created)\n+        self.assertEqual(book.name, name)\n+        self.assertEqual(p.books.count(), 1)\n+\n+    def test_create_with_many(self):\n+        \"\"\"\n+        Should be able to use update_or_create from the m2m related manager to\n+        create a book. Refs #23611.\n+        \"\"\"\n+        p = Publisher.objects.create(name=\"Acme Publishing\", num_awards=1)\n+        author = Author.objects.create(name=\"Ted\")\n+        book, created = author.books.update_or_create(\n+            name=\"The Book of Ed & Fred\", publisher=p\n+        )\n+        self.assertTrue(created)\n+        self.assertEqual(author.books.count(), 1)\n+\n+    def test_update_with_many(self):\n+        \"\"\"\n+        Should be able to use update_or_create from the m2m related manager to\n+        update a book. Refs #23611.\n+        \"\"\"\n+        p = Publisher.objects.create(name=\"Acme Publishing\", num_awards=1)\n+        author = Author.objects.create(name=\"Ted\")\n+        book = Book.objects.create(name=\"The Book of Ed & Fred\", publisher=p)\n+        book.authors.add(author)\n+        self.assertEqual(author.books.count(), 1)\n+        name = \"The Book of Django\"\n+        book, created = author.books.update_or_create(\n+            defaults={\"name\": name}, id=book.id\n+        )\n+        self.assertFalse(created)\n+        self.assertEqual(book.name, name)\n+        self.assertEqual(author.books.count(), 1)\n+\n+    def test_defaults_exact(self):\n+        \"\"\"\n+        If you have a field named defaults and want to use it as an exact\n+        lookup, you need to use 'defaults__exact'.\n+        \"\"\"\n+        obj, created = Person.objects.update_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            defaults__exact=\"testing\",\n+            defaults={\n+                \"birthday\": date(1943, 2, 25),\n+                \"defaults\": \"testing\",\n+            },\n+        )\n+        self.assertTrue(created)\n+        self.assertEqual(obj.defaults, \"testing\")\n+        obj, created = Person.objects.update_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            defaults__exact=\"testing\",\n+            defaults={\n+                \"birthday\": date(1943, 2, 25),\n+                \"defaults\": \"another testing\",\n+            },\n+        )\n+        self.assertFalse(created)\n+        self.assertEqual(obj.defaults, \"another testing\")\n+\n+    def test_create_callable_default(self):\n+        obj, created = Person.objects.update_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            defaults={\"birthday\": lambda: date(1943, 2, 25)},\n+        )\n+        self.assertIs(created, True)\n+        self.assertEqual(obj.birthday, date(1943, 2, 25))\n+\n+    def test_update_callable_default(self):\n+        Person.objects.update_or_create(\n+            first_name=\"George\",\n+            last_name=\"Harrison\",\n+            birthday=date(1942, 2, 25),\n+        )\n+        obj, created = Person.objects.update_or_create(\n+            first_name=\"George\",\n+            defaults={\"last_name\": lambda: \"NotHarrison\"},\n+        )\n+        self.assertIs(created, False)\n+        self.assertEqual(obj.last_name, \"NotHarrison\")\n+\n+    def test_defaults_not_evaluated_unless_needed(self):\n+        \"\"\"`defaults` aren't evaluated if the instance isn't created.\"\"\"\n+        Person.objects.create(\n+            first_name=\"John\", last_name=\"Lennon\", birthday=date(1940, 10, 9)\n+        )\n+\n+        def raise_exception():\n+            raise AssertionError\n+\n+        obj, created = Person.objects.update_or_create(\n+            first_name=\"John\",\n+            last_name=\"Lennon\",\n+            defaults=lazy(raise_exception, object)(),\n+        )\n+        self.assertFalse(created)\n+\n+    def test_update_fields_and_pre_save(self):\n+        p, _ = Journalist.objects.update_or_create(\n+            name=\"John\", defaults={\"sex\": \"M\", \"company\": \"The Times\"}\n+        )\n+        self.assertEqual(p.company, \"The Times\")\n+\n+        p, _ = Journalist.objects.update_or_create(\n+            name=\"John\", defaults={\"company\": \"The Sun\"}\n+        )\n+        self.assertEqual(p.company, \"The Sun\")\n+\n+    def test_update_fields_and_pre_save_inheritance(self):\n+        class ChildJournalist(Journalist):\n+            class Meta:\n+                proxy = True\n+\n+        p, _ = ChildJournalist.objects.update_or_create(\n+            name=\"John\", defaults={\"sex\": \"M\", \"company\": \"The Times\"}\n+        )\n+        self.assertEqual(p.company, \"The Times\")\n+\n+        p, _ = ChildJournalist.objects.update_or_create(\n+            name=\"John\", defaults={\"company\": \"The Sun\"}\n+        )\n+        self.assertEqual(p.company, \"The Sun\")\n+\n+    def test_update_or_create_on_related_manager_with_through_defaults(self):\n+        p = Publisher.objects.create(name=\"Acme Publishing\", num_awards=1)\n+        author = Author.objects.create(name=\"Ted\")\n+        msg = (\n+            \"update_or_create() got an unexpected keyword argument \"\n+            \"'through_defaults'\"\n+        )\n+        with self.assertRaisesMessage(TypeError, msg):\n+            author.books.update_or_create(\n+                name=\"The Book of Ed & Fred\",\n+                publisher=p,\n+                through_defaults={\"is_bestseller\": True},\n+            )\n+\n+\n+class ConcurrencyTests(TransactionTestCase):\n+\n+    available_apps = [\"get_or_create\"]\n+\n+    def test_concurrent_get_or_create(self):\n+        \"\"\"\n+        Concurrent get_or_create() calls don't result in a race condition.\n+        \"\"\"\n+        # This is a sad state of affairs. The test is not really testing\n+        # anything other than the fact that the DB is in a consistent\n+        # state after the transaction. The test is not concurrent in any\n+        # way. The DB state is checked only after both threads have finished.\n+        threads = []\n+        for i in range(2):\n+            thread = Thread(\n+                target=Person.objects.get_or_create,\n+                kwargs={\n+                    \"first_name\": \"Concurrent\",\n+                    \"last_name\": \"Person\",\n+                    \"defaults\": {\"birthday\": date(1943, 2, 25)},\n+                },\n+            )\n+            threads.append(thread)\n+            thread.start()\n+        for thread in threads:\n+            thread.join()\n+        self.assertEqual(\n+            Person.objects.filter(\n+                first_name=\"Concurrent\", last_name=\"Person\"\n+            ).count(),\n+            1,\n+        )\n+\n+    def test_get_or_create_duplicate_custom_pk(self):\n+        \"\"\"\n+        IntegrityError is raised when get_or_create fails to create a\n+        record due to a duplicate custom primary key.\n+        \"\"\"\n+\n+\n+        class ThreadWithExc(Thread):\n+            def run(self):\n+                self.exc = None\n+                try:\n+                    super().run()\n+                except Exception as e:\n+                    self.exc = e\n+\n+        threads = []\n+        for i in range(2):\n+            thread = ThreadWithExc(\n+                target=ManualPrimaryKeyTest.objects.get_or_create,\n+                kwargs={\"id\": i, \"data\": \"thread-data\"},\n+            )\n+            threads.append(thread)\n+            thread.start()\n+        for thread in threads:\n+            thread.join()\n+            if thread.exc:\n+                raise thread.exc\n+\n+    @skipUnlessDBFeature(\"has_select_for_update\")\n+    def test_concurrent_update_or_create(self):\n+        \"\"\"\n+        Concurrent update_or_create() calls don't result in a race\n+        condition.\n+        \"\"\"\n+        person, _ = Person.objects.update_or_create(\n+            first_name=\"Concurrent\",\n+            last_name=\"Person\",\n+            defaults={\"birthday\": date(1943, 2, 25)},\n+        )\n+        threads = []\n+        for i in range(5):\n+            thread = Thread(\n+                target=Person.objects.update_or_create,\n+                kwargs={\n+                    \"pk\": person.pk,\n+                    \"defaults\": {\"birthday\": date(1943, 2, 25) + timedelta(days=i)},\n+                },\n+            )\n+            threads.append(thread)\n+        for thread in threads:\n+            # Stagger the threads to increase the chance of a race condition.\n+            thread.start()\n+            time.sleep(0.01)\n+        for thread in threads:\n+            thread.join()\n+        self.assertEqual(\n+            Person.objects.filter(\n+                first_name=\"Concurrent\", last_name=\"Person\"\n+            ).count(),\n+            1,\n+        )\n+\n+\n+class FieldErrorTests(TestCase):\n+    def test_field_error(self):\n+        \"\"\"\n+        FieldError is raised if a keyword argument isn't a field in the model.\n+        \"\"\"\n+        with self.assertRaisesMessage(\n+            FieldError, \"Invalid field name(s) for model Person: 'firstname'.\"\n+        ):\n+            Person.objects.get_or_create(firstname=\"John\")\n+        with self.assertRaisesMessage(\n+            FieldError, \"Invalid field name(s) for model Person: 'firstname'.\"\n+        ):\n+            Person.objects.update_or_create(firstname=\"John\")\n+\n+\n+class SelectRelatedTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.person = Person.objects.create(\n+            first_name=\"John\", last_name=\"Lennon\", birthday=date(1940, 10, 9)\n+        )\n+        cls.profile = Profile.objects.create(person=cls.person)\n+\n+    def test_get_or_create(self):\n+        with CaptureQueriesContext(connection) as queries:\n+            profile, created = Profile.objects.select_related(\"person\").get_or_create(\n+                person=self.person\n+            )\n+        self.assertFalse(created)\n+        self.assertEqual(len(queries), 1)\n+        self.assertEqual(profile, self.profile)\n+        with self.assertNumQueries(0):\n+            self.assertEqual(profile.person, self.person)\n+\n+    def test_update_or_create(self):\n+        with CaptureQueriesContext(connection) as queries:\n+            (\n+                profile,\n+                created,\n+            ) = Profile.objects.select_related(\"person\").update_or_create(\n+                person=self.person\n+            )\n+        self.assertFalse(created)\n+        # One query for select_for_update(), and one for the update.\n+        self.assertEqual(len(queries), 2)\n+        self.assertEqual(profile, self.profile)\n+        with self.assertNumQueries(0):\n+            self.assertEqual(profile.person, self.person)\n+\n+class AsyncRelatedManagerTests(TestCase):\n+    async def test_acreate_on_many_to_many_manager(self):\n+        \"\"\"\n+        acreate() on a ManyToMany related manager should create the object\n+        and the relationship.\n+        \"\"\"\n+        # Use unique names to avoid collisions with other tests.\n+        publisher = await Publisher.objects.acreate(\n+            name=\"Async M2M Test Publisher\", num_awards=5\n+        )\n+        book = await Book.objects.acreate(\n+            name=\"Async M2M Test Book\", publisher=publisher\n+        )\n+\n+        # Before the fix, this calls QuerySet.acreate(), which creates an\n+        # Author object but does not create the M2M relationship with the book.\n+        author = await book.authors.acreate(name=\"Async M2M Test Author\")\n+\n+        # This assertion will fail before the fix, because the author has not\n+        # been added to the book's authors set. After the patch, the\n+        # relationship will be correctly created, and the assertion will pass.\n+        self.assertTrue(await book.authors.filter(pk=author.pk).aexists())\n\\ No newline at end of file\n"], "arch": "x86_64", "base_commit": "76e37513e22f4d9a01c7f15eee36fe44388e6670", "test_directives": ["get_or_create.tests"], "coverage_files": ["django/contrib/contenttypes/fields.py", "django/db/models/fields/related_descriptors.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.9", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/contrib/contenttypes/fields\\.py|django/db/models/fields/related_descriptors\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 get_or_create.tests", "req_install_commands": ["conda create -n testbed python=3.9 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\naiosmtpd\nasgiref >= 3.6.0\nargon2-cffi >= 19.2.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\nblack\ndocutils\ngeoip2; python_version < '3.12'\njinja2 >= 2.11.0\nnumpy; python_version < '3.12'\nPillow >= 6.2.1; sys.platform != 'win32' or python_version < '3.12'\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.4.0\nselenium\nsqlparse >= 0.3.1\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}