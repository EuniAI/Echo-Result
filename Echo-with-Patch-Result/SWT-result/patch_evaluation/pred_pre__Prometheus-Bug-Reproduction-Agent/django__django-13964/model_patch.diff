diff --git a/tests/test_char_pk_fk_assignment.py b/tests/test_char_pk_fk_assignment.py
new file mode 100644
index 0000000000..f72f045438
--- /dev/null
+++ b/tests/test_char_pk_fk_assignment.py
@@ -0,0 +1,31 @@
+from django.db import models, transaction
+from django.test import TestCase
+
+
+class Product(models.Model):
+    sku = models.CharField(primary_key=True, max_length=50)
+
+
+class Order(models.Model):
+    product = models.ForeignKey(Product, on_delete=models.CASCADE)
+
+
+class CharPKFKAssignmentTests(TestCase):
+    def test_fk_assignment_char_pk_save(self):
+        """
+        Test that assigning a related object and then setting its CharField
+        primary key before saving doesn't result in data loss.
+        """
+        with transaction.atomic():
+            order = Order()
+            # Assign an empty Product instance first.
+            order.product = Product()
+            # Then, set the PK on the related Product.
+            order.product.sku = "foo"
+            order.product.save()
+            # Now, save the Order. The FK should be correctly pulled from the
+            # saved Product instance.
+            order.save()
+        # Before the fix, the order.product_id would be an empty string,
+        # causing this lookup to fail.
+        self.assertTrue(Order.objects.filter(product=order.product).exists())
