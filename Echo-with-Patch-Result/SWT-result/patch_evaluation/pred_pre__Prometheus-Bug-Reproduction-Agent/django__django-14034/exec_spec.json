{"instance_id": "django__django-14034", "repo": "django/django", "version": "4.0", "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4", "patch_list": ["diff --git a/tests/test_multivaluefield.py b/tests/test_multivaluefield.py\nnew file mode 100644\nindex 0000000000..4ba0332ad5\n--- /dev/null\n+++ b/tests/test_multivaluefield.py\n@@ -0,0 +1,206 @@\n+from datetime import datetime\n+\n+from django.core.exceptions import ValidationError\n+from django.forms import (\n+    CharField, Form, MultipleChoiceField, MultiValueField, MultiWidget,\n+    SelectMultiple, SplitDateTimeField, SplitDateTimeWidget, TextInput,\n+)\n+from django.test import SimpleTestCase\n+\n+beatles = (('J', 'John'), ('P', 'Paul'), ('G', 'George'), ('R', 'Ringo'))\n+\n+\n+class ComplexMultiWidget(MultiWidget):\n+    def __init__(self, attrs=None):\n+        widgets = (\n+            TextInput(),\n+            SelectMultiple(choices=beatles),\n+            SplitDateTimeWidget(),\n+        )\n+        super().__init__(widgets, attrs)\n+\n+    def decompress(self, value):\n+        if value:\n+            data = value.split(',')\n+            return [\n+                data[0],\n+                list(data[1]),\n+                datetime.strptime(data[2], \"%Y-%m-%d %H:%M:%S\"),\n+            ]\n+        return [None, None, None]\n+\n+\n+class ComplexField(MultiValueField):\n+    def __init__(self, **kwargs):\n+        fields = (\n+            CharField(),\n+            MultipleChoiceField(choices=beatles),\n+            SplitDateTimeField(),\n+        )\n+        super().__init__(fields, **kwargs)\n+\n+    def compress(self, data_list):\n+        if data_list:\n+            return '%s,%s,%s' % (data_list[0], ''.join(data_list[1]), data_list[2])\n+        return None\n+\n+\n+class ComplexFieldForm(Form):\n+    field1 = ComplexField(widget=ComplexMultiWidget())\n+\n+\n+class MultiValueFieldTest(SimpleTestCase):\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.field = ComplexField(widget=ComplexMultiWidget())\n+        super().setUpClass()\n+\n+    def test_clean(self):\n+        self.assertEqual(\n+            self.field.clean(['some text', ['J', 'P'], ['2007-04-25', '6:24:00']]),\n+            'some text,JP,2007-04-25 06:24:00',\n+        )\n+\n+    def test_clean_disabled_multivalue(self):\n+        class ComplexFieldForm(Form):\n+            f = ComplexField(disabled=True, widget=ComplexMultiWidget)\n+\n+        inputs = (\n+            'some text,JP,2007-04-25 06:24:00',\n+            ['some text', ['J', 'P'], ['2007-04-25', '6:24:00']],\n+        )\n+        for data in inputs:\n+            with self.subTest(data=data):\n+                form = ComplexFieldForm({}, initial={'f': data})\n+                form.full_clean()\n+                self.assertEqual(form.errors, {})\n+                self.assertEqual(form.cleaned_data, {'f': inputs[0]})\n+\n+    def test_bad_choice(self):\n+        msg = \"'Select a valid choice. X is not one of the available choices.'\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            self.field.clean(['some text', ['X'], ['2007-04-25', '6:24:00']])\n+\n+    def test_no_value(self):\n+        \"\"\"\n+        If insufficient data is provided, None is substituted.\n+        \"\"\"\n+        msg = \"'This field is required.'\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            self.field.clean(['some text', ['JP']])\n+\n+    def test_has_changed_no_initial(self):\n+        self.assertTrue(self.field.has_changed(None, ['some text', ['J', 'P'], ['2007-04-25', '6:24:00']]))\n+\n+    def test_has_changed_same(self):\n+        self.assertFalse(self.field.has_changed(\n+            'some text,JP,2007-04-25 06:24:00',\n+            ['some text', ['J', 'P'], ['2007-04-25', '6:24:00']],\n+        ))\n+\n+    def test_has_changed_first_widget(self):\n+        \"\"\"\n+        Test when the first widget's data has changed.\n+        \"\"\"\n+        self.assertTrue(self.field.has_changed(\n+            'some text,JP,2007-04-25 06:24:00',\n+            ['other text', ['J', 'P'], ['2007-04-25', '6:24:00']],\n+        ))\n+\n+    def test_has_changed_last_widget(self):\n+        \"\"\"\n+        Test when the last widget's data has changed. This ensures that it is\n+        not short circuiting while testing the widgets.\n+        \"\"\"\n+        self.assertTrue(self.field.has_changed(\n+            'some text,JP,2007-04-25 06:24:00',\n+            ['some text', ['J', 'P'], ['2009-04-25', '11:44:00']],\n+        ))\n+\n+    def test_disabled_has_changed(self):\n+        f = MultiValueField(fields=(CharField(), CharField()), disabled=True)\n+        self.assertIs(f.has_changed(['x', 'x'], ['y', 'y']), False)\n+\n+    def test_form_as_table(self):\n+        form = ComplexFieldForm()\n+        self.assertHTMLEqual(\n+            form.as_table(),\n+            '''\n+            <tr><th><label for=\"id_field1_0\">Field1:</label></th>\n+            <td><input type=\"text\" name=\"field1_0\" id=\"id_field1_0\" required>\n+            <select multiple name=\"field1_1\" id=\"id_field1_1\" required>\n+            <option value=\"J\">John</option>\n+            <option value=\"P\">Paul</option>\n+            <option value=\"G\">George</option>\n+            <option value=\"R\">Ringo</option>\n+            </select>\n+            <input type=\"text\" name=\"field1_2_0\" id=\"id_field1_2_0\" required>\n+            <input type=\"text\" name=\"field1_2_1\" id=\"id_field1_2_1\" required></td></tr>\n+            ''',\n+        )\n+\n+    def test_form_as_table_data(self):\n+        form = ComplexFieldForm({\n+            'field1_0': 'some text',\n+            'field1_1': ['J', 'P'],\n+            'field1_2_0': '2007-04-25',\n+            'field1_2_1': '06:24:00',\n+        })\n+        self.assertHTMLEqual(\n+            form.as_table(),\n+            '''\n+            <tr><th><label for=\"id_field1_0\">Field1:</label></th>\n+            <td><input type=\"text\" name=\"field1_0\" value=\"some text\" id=\"id_field1_0\" required>\n+            <select multiple name=\"field1_1\" id=\"id_field1_1\" required>\n+            <option value=\"J\" selected>John</option>\n+            <option value=\"P\" selected>Paul</option>\n+            <option value=\"G\">George</option>\n+            <option value=\"R\">Ringo</option>\n+            </select>\n+            <input type=\"text\" name=\"field1_2_0\" value=\"2007-04-25\" id=\"id_field1_2_0\" required>\n+            <input type=\"text\" name=\"field1_2_1\" value=\"06:24:00\" id=\"id_field1_2_1\" required></td></tr>\n+            ''',\n+        )\n+\n+    def test_form_cleaned_data(self):\n+        form = ComplexFieldForm({\n+            'field1_0': 'some text',\n+            'field1_1': ['J', 'P'],\n+            'field1_2_0': '2007-04-25',\n+            'field1_2_1': '06:24:00',\n+        })\n+        form.is_valid()\n+        self.assertEqual(form.cleaned_data['field1'], 'some text,JP,2007-04-25 06:24:00')\n+\n+    def test_required_subfield_not_ignored_when_all_fields_empty(self):\n+        \"\"\"\n+        A MultiValueField with require_all_fields=False should not ignore a\n+        required subfield when all submitted values are empty.\n+        \"\"\"\n+        class MyMultiValueField(MultiValueField):\n+            def __init__(self, **kwargs):\n+                fields = [\n+                    CharField(required=False),\n+                    CharField(required=True),\n+                ]\n+                widget = MultiWidget(widgets=[f.widget for f in fields])\n+                super().__init__(\n+                    fields=fields,\n+                    widget=widget,\n+                    require_all_fields=False,\n+                    required=False,\n+                    **kwargs\n+                )\n+\n+            def compress(self, value):\n+                return value\n+\n+        class MyForm(Form):\n+            mf = MyMultiValueField()\n+\n+        form = MyForm({\n+            'mf_0': '',\n+            'mf_1': '',\n+        })\n+        self.assertFalse(form.is_valid())\n"], "arch": "x86_64", "base_commit": "db1fc5cd3c5d36cdb5d0fe4404efd6623dd3e8fb", "test_directives": ["test_multivaluefield"], "coverage_files": ["django/forms/boundfield.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.8", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/forms/boundfield\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 test_multivaluefield", "req_install_commands": ["conda create -n testbed python=3.8 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}