{"instance_id": "django__django-11299", "repo": "django/django", "version": "3.0", "environment_setup_commit": "419a78300f7cd27611196e1e464d50fd0385ff27", "patch_list": ["diff --git a/tests/db/models/test_constraints.py b/tests/db/models/test_constraints.py\nnew file mode 100644\nindex 0000000000..62d875fbd9\n--- /dev/null\n+++ b/tests/db/models/test_constraints.py\n@@ -0,0 +1,219 @@\n+from django.core.exceptions import ValidationError\n+from django.db import IntegrityError, connection, models\n+from django.db.models import Q\n+from django.db.models.constraints import BaseConstraint\n+from django.test import (\n+    SimpleTestCase, TestCase, TransactionTestCase, skipUnlessDBFeature,\n+)\n+\n+from .models import Product\n+\n+\n+def get_constraints(table):\n+    with connection.cursor() as cursor:\n+        return connection.introspection.get_constraints(cursor, table)\n+\n+\n+class BaseConstraintTests(SimpleTestCase):\n+    def test_constraint_sql(self):\n+        c = BaseConstraint('name')\n+        msg = 'This method must be implemented by a subclass.'\n+        with self.assertRaisesMessage(NotImplementedError, msg):\n+            c.constraint_sql(None, None)\n+\n+    def test_create_sql(self):\n+        c = BaseConstraint('name')\n+        msg = 'This method must be implemented by a subclass.'\n+        with self.assertRaisesMessage(NotImplementedError, msg):\n+            c.create_sql(None, None)\n+\n+    def test_remove_sql(self):\n+        c = BaseConstraint('name')\n+        msg = 'This method must be implemented by a subclass.'\n+        with self.assertRaisesMessage(NotImplementedError, msg):\n+            c.remove_sql(None, None)\n+\n+\n+class CheckConstraintTests(TestCase):\n+    def test_eq(self):\n+        check1 = models.Q(price__gt=models.F('discounted_price'))\n+        check2 = models.Q(price__lt=models.F('discounted_price'))\n+        self.assertEqual(\n+            models.CheckConstraint(check=check1, name='price'),\n+            models.CheckConstraint(check=check1, name='price'),\n+        )\n+        self.assertNotEqual(\n+            models.CheckConstraint(check=check1, name='price'),\n+            models.CheckConstraint(check=check1, name='price2'),\n+        )\n+        self.assertNotEqual(\n+            models.CheckConstraint(check=check1, name='price'),\n+            models.CheckConstraint(check=check2, name='price'),\n+        )\n+        self.assertNotEqual(models.CheckConstraint(check=check1, name='price'), 1)\n+\n+    def test_repr(self):\n+        check = models.Q(price__gt=models.F('discounted_price'))\n+        name = 'price_gt_discounted_price'\n+        constraint = models.CheckConstraint(check=check, name=name)\n+        self.assertEqual(\n+            repr(constraint),\n+            \"<CheckConstraint: check='{}' name='{}'>\".format(check, name),\n+        )\n+\n+    def test_deconstruction(self):\n+        check = models.Q(price__gt=models.F('discounted_price'))\n+        name = 'price_gt_discounted_price'\n+        constraint = models.CheckConstraint(check=check, name=name)\n+        path, args, kwargs = constraint.deconstruct()\n+        self.assertEqual(path, 'django.db.models.CheckConstraint')\n+        self.assertEqual(args, ())\n+        self.assertEqual(kwargs, {'check': check, 'name': name})\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_database_constraint(self):\n+        Product.objects.create(name='Valid', price=10, discounted_price=5)\n+        with self.assertRaises(IntegrityError):\n+            Product.objects.create(name='Invalid', price=10, discounted_price=20)\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_name(self):\n+        constraints = get_constraints(Product._meta.db_table)\n+        expected_name = 'price_gt_discounted_price'\n+        self.assertIn(expected_name, constraints)\n+\n+\n+class CheckConstraintOROperatorTests(TransactionTestCase):\n+    available_apps = ['constraints']\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_or_operator_sql(self):\n+        class TestModel(models.Model):\n+            field_1 = models.IntegerField(blank=True, null=True)\n+            flag = models.BooleanField()\n+\n+            class Meta:\n+                app_label = 'constraints'\n+                managed = False\n+\n+        constraint = models.CheckConstraint(\n+            check=models.Q(flag=True, field_1__isnull=False) | models.Q(flag=False),\n+            name='field_1_has_value_if_flag_set',\n+        )\n+\n+        with connection.schema_editor() as editor:\n+            constraint_sql = constraint.constraint_sql(TestModel, editor)\n+\n+        self.assertNotIn(\n+            '\"%s\"' % TestModel._meta.db_table,\n+            constraint_sql,\n+        )\n+\n+\n+class UniqueConstraintTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.p1, cls.p2 = Product.objects.bulk_create([\n+            Product(name='p1', color='red'),\n+            Product(name='p2'),\n+        ])\n+\n+    def test_eq(self):\n+        self.assertEqual(\n+            models.UniqueConstraint(fields=['foo', 'bar'], name='unique'),\n+            models.UniqueConstraint(fields=['foo', 'bar'], name='unique'),\n+        )\n+        self.assertNotEqual(\n+            models.UniqueConstraint(fields=['foo', 'bar'], name='unique'),\n+            models.UniqueConstraint(fields=['foo', 'bar'], name='unique2'),\n+        )\n+        self.assertNotEqual(\n+            models.UniqueConstraint(fields=['foo', 'bar'], name='unique'),\n+            models.UniqueConstraint(fields=['foo', 'baz'], name='unique'),\n+        )\n+        self.assertNotEqual(models.UniqueConstraint(fields=['foo', 'bar'], name='unique'), 1)\n+\n+    def test_eq_with_condition(self):\n+        self.assertEqual(\n+            models.UniqueConstraint(\n+                fields=['foo', 'bar'], name='unique',\n+                condition=models.Q(foo=models.F('bar'))\n+            ),\n+            models.UniqueConstraint(\n+                fields=['foo', 'bar'], name='unique',\n+                condition=models.Q(foo=models.F('bar'))),\n+        )\n+        self.assertNotEqual(\n+            models.UniqueConstraint(\n+                fields=['foo', 'bar'],\n+                name='unique',\n+                condition=models.Q(foo=models.F('bar'))\n+            ),\n+            models.UniqueConstraint(\n+                fields=['foo', 'bar'],\n+                name='unique',\n+                condition=models.Q(foo=models.F('baz'))\n+            ),\n+        )\n+\n+    def test_repr(self):\n+        fields = ['foo', 'bar']\n+        name = 'unique_fields'\n+        constraint = models.UniqueConstraint(fields=fields, name=name)\n+        self.assertEqual(\n+            repr(constraint),\n+            \"<UniqueConstraint: fields=('foo', 'bar') name='unique_fields'>\",\n+        )\n+\n+    def test_repr_with_condition(self):\n+        constraint = models.UniqueConstraint(\n+            fields=['foo', 'bar'],\n+            name='unique_fields',\n+            condition=models.Q(foo=models.F('bar')),\n+        )\n+        self.assertEqual(\n+            repr(constraint),\n+            \"<UniqueConstraint: fields=('foo', 'bar') name='unique_fields' \"\n+            \"condition=(AND: ('foo', F(bar)))>\",\n+        )\n+\n+    def test_deconstruction(self):\n+        fields = ['foo', 'bar']\n+        name = 'unique_fields'\n+        constraint = models.UniqueConstraint(fields=fields, name=name)\n+        path, args, kwargs = constraint.deconstruct()\n+        self.assertEqual(path, 'django.db.models.UniqueConstraint')\n+        self.assertEqual(args, ())\n+        self.assertEqual(kwargs, {'fields': tuple(fields), 'name': name})\n+\n+    def test_deconstruction_with_condition(self):\n+        fields = ['foo', 'bar']\n+        name = 'unique_fields'\n+        condition = models.Q(foo=models.F('bar'))\n+        constraint = models.UniqueConstraint(fields=fields, name=name, condition=condition)\n+        path, args, kwargs = constraint.deconstruct()\n+        self.assertEqual(path, 'django.db.models.UniqueConstraint')\n+        self.assertEqual(args, ())\n+        self.assertEqual(kwargs, {'fields': tuple(fields), 'name': name, 'condition': condition})\n+\n+    def test_database_constraint(self):\n+        with self.assertRaises(IntegrityError):\n+            Product.objects.create(name=self.p1.name, color=self.p1.color)\n+\n+    def test_model_validation(self):\n+        with self.assertRaisesMessage(ValidationError, 'Product with this Name and Color already exists.'):\n+            Product(name=self.p1.name, color=self.p1.color).validate_unique()\n+\n+    def test_model_validation_with_condition(self):\n+        \"\"\"Partial unique constraints are ignored by Model.validate_unique().\"\"\"\n+        Product(name=self.p1.name, color='blue').validate_unique()\n+        Product(name=self.p2.name).validate_unique()\n+\n+    def test_name(self):\n+        constraints = get_constraints(Product._meta.db_table)\n+        expected_name = 'name_color_uniq'\n+        self.assertIn(expected_name, constraints)\n+\n+    def test_condition_must_be_q(self):\n+        with self.assertRaisesMessage(ValueError, 'UniqueConstraint.condition must be a Q instance.'):\n+            models.UniqueConstraint(name='uniq', fields=['name'], condition='invalid')\n"], "arch": "x86_64", "base_commit": "6866c91b638de5368c18713fa851bfe56253ea55", "test_directives": ["db.models.test_constraints"], "coverage_files": ["django/db/models/sql/query.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/db/models/sql/query\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 db.models.test_constraints", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref ~= 3.2\nargon2-cffi >= 16.1.0\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow != 5.4.0\npylibmc; sys.platform != 'win32'\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}