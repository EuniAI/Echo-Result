{"instance_id": "django__django-13344", "repo": "django/django", "version": "3.2", "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d", "patch_list": ["diff --git a/asgi/test_middleware_response.py b/asgi/test_middleware_response.py\nnew file mode 100644\nindex 0000000000..6e41d390e2\n--- /dev/null\n+++ b/asgi/test_middleware_response.py\n@@ -0,0 +1,296 @@\n+import asyncio\n+import sys\n+import threading\n+from pathlib import Path\n+from unittest import skipIf\n+\n+from asgiref.sync import SyncToAsync\n+from asgiref.testing import ApplicationCommunicator\n+\n+from django.contrib.staticfiles.handlers import ASGIStaticFilesHandler\n+from django.core.asgi import get_asgi_application\n+from django.core.signals import request_finished, request_started\n+from django.db import close_old_connections\n+from django.http import HttpResponse\n+from django.test import (\n+    AsyncRequestFactory, SimpleTestCase, modify_settings, override_settings,\n+)\n+from django.urls import path\n+from django.utils.deprecation import MiddlewareMixin\n+from django.utils.http import http_date\n+\n+from .urls import test_filename\n+\n+TEST_STATIC_ROOT = Path(__file__).parent / 'project' / 'static'\n+\n+# --- Test setup for the bug reproduction ---\n+# Global storage to capture data from inside the middleware for assertion.\n+middleware_test_storage = {}\n+\n+\n+class CaptureResponseTypeMiddleware(MiddlewareMixin):\n+    \"\"\"\n+    This middleware is placed first in the chain. It captures the actual\n+    `response` object it receives so the test can inspect it.\n+    \"\"\"\n+    def process_response(self, request, response):\n+        middleware_test_storage['response_object'] = response\n+        return response\n+\n+\n+def simple_bug_repro_view(request):\n+    \"\"\"A simple view for the test's self-contained URL configuration.\"\"\"\n+    return HttpResponse(\"OK\")\n+\n+\n+# A self-contained URL configuration for the bug reproduction test.\n+urlpatterns = [\n+    path('bug-repro-route/', simple_bug_repro_view),\n+]\n+# --- End of test setup ---\n+\n+\n+@skipIf(sys.platform == 'win32' and (3, 8, 0) < sys.version_info < (3, 8, 1), 'https://bugs.python.org/issue38563')\n+@override_settings(ROOT_URLCONF='asgi.urls')\n+class ASGITest(SimpleTestCase):\n+    async_request_factory = AsyncRequestFactory()\n+\n+    def setUp(self):\n+        request_started.disconnect(close_old_connections)\n+        middleware_test_storage.clear()\n+\n+    def tearDown(self):\n+        request_started.connect(close_old_connections)\n+\n+    @override_settings(\n+        ROOT_URLCONF=__name__,\n+        MIDDLEWARE=[\n+            'asgi.tests.CaptureResponseTypeMiddleware',\n+            'django.middleware.security.SecurityMiddleware',\n+            'django.middleware.common.CommonMiddleware',\n+        ]\n+    )\n+    async def test_first_middleware_receives_httpresponse_not_coroutine(self):\n+        \"\"\"\n+        Tests that the first middleware's process_response() receives an\n+        HttpResponse, not a coroutine. This test will fail on unpatched code.\n+        \"\"\"\n+        application = get_asgi_application()\n+        scope = self.async_request_factory._base_scope(path='/bug-repro-route/')\n+        communicator = ApplicationCommunicator(application, scope)\n+\n+        await communicator.send_input({'type': 'http.request'})\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['status'], 200)\n+        await communicator.receive_output()  # Consume body.\n+        await communicator.wait()\n+\n+        # This assertion now correctly fails when the bug is present.\n+        self.assertIn('response_object', middleware_test_storage)\n+        response_obj = middleware_test_storage['response_object']\n+        self.assertFalse(\n+            asyncio.iscoroutine(response_obj),\n+            'First middleware received a coroutine instead of an HttpResponse.'\n+        )\n+\n+    async def test_get_asgi_application(self):\n+        \"\"\"\n+        get_asgi_application() returns a functioning ASGI callable.\n+        \"\"\"\n+        application = get_asgi_application()\n+        # Construct HTTP request.\n+        scope = self.async_request_factory._base_scope(path='/')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        # Read the response.\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', b'12'),\n+                (b'Content-Type', b'text/html; charset=utf-8'),\n+            },\n+        )\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], b'Hello World!')\n+\n+    async def test_file_response(self):\n+        \"\"\"\n+        Makes sure that FileResponse works over ASGI.\n+        \"\"\"\n+        application = get_asgi_application()\n+        # Construct HTTP request.\n+        scope = self.async_request_factory._base_scope(path='/file/')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        # Get the file content.\n+        with open(test_filename, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+        # Read the response.\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain' if sys.platform == 'win32' else b'text/x-python'),\n+                (b'Content-Disposition', b'inline; filename=\"urls.py\"'),\n+            },\n+        )\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], test_file_contents)\n+        # Allow response.close() to finish.\n+        await communicator.wait()\n+\n+    @modify_settings(INSTALLED_APPS={'append': 'django.contrib.staticfiles'})\n+    @override_settings(\n+        STATIC_URL='/static/',\n+        STATIC_ROOT=TEST_STATIC_ROOT,\n+        STATICFILES_DIRS=[TEST_STATIC_ROOT],\n+        STATICFILES_FINDERS=[\n+            'django.contrib.staticfiles.finders.FileSystemFinder',\n+        ],\n+    )\n+    async def test_static_file_response(self):\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        # Construct HTTP request.\n+        scope = self.async_request_factory._base_scope(path='/static/file.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        # Get the file content.\n+        file_path = TEST_STATIC_ROOT / 'file.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+        # Read the response.\n+        stat = file_path.stat()\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain'),\n+                (b'Content-Disposition', b'inline; filename=\"file.txt\"'),\n+                (b'Last-Modified', http_date(stat.st_mtime).encode('ascii')),\n+            },\n+        )\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], test_file_contents)\n+        # Allow response.close() to finish.\n+        await communicator.wait()\n+\n+    async def test_headers(self):\n+        application = get_asgi_application()\n+        communicator = ApplicationCommunicator(\n+            application,\n+            self.async_request_factory._base_scope(\n+                path='/meta/',\n+                headers=[\n+                    [b'content-type', b'text/plain; charset=utf-8'],\n+                    [b'content-length', b'77'],\n+                    [b'referer', b'Scotland'],\n+                    [b'referer', b'Wales'],\n+                ],\n+            ),\n+        )\n+        await communicator.send_input({'type': 'http.request'})\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', b'19'),\n+                (b'Content-Type', b'text/plain; charset=utf-8'),\n+            },\n+        )\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], b'From Scotland,Wales')\n+\n+    async def test_get_query_string(self):\n+        application = get_asgi_application()\n+        for query_string in (b'name=Andrew', 'name=Andrew'):\n+            with self.subTest(query_string=query_string):\n+                scope = self.async_request_factory._base_scope(\n+                    path='/',\n+                    query_string=query_string,\n+                )\n+                communicator = ApplicationCommunicator(application, scope)\n+                await communicator.send_input({'type': 'http.request'})\n+                response_start = await communicator.receive_output()\n+                self.assertEqual(response_start['type'], 'http.response.start')\n+                self.assertEqual(response_start['status'], 200)\n+                response_body = await communicator.receive_output()\n+                self.assertEqual(response_body['type'], 'http.response.body')\n+                self.assertEqual(response_body['body'], b'Hello Andrew!')\n+\n+    async def test_disconnect(self):\n+        application = get_asgi_application()\n+        scope = self.async_request_factory._base_scope(path='/')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.disconnect'})\n+        with self.assertRaises(asyncio.TimeoutError):\n+            await communicator.receive_output()\n+\n+    async def test_wrong_connection_type(self):\n+        application = get_asgi_application()\n+        scope = self.async_request_factory._base_scope(path='/', type='other')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        msg = 'Django can only handle ASGI/HTTP connections, not other.'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            await communicator.receive_output()\n+\n+    async def test_non_unicode_query_string(self):\n+        application = get_asgi_application()\n+        scope = self.async_request_factory._base_scope(path='/', query_string=b'\\xff')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 400)\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], b'')\n+\n+    async def test_request_lifecycle_signals_dispatched_with_thread_sensitive(self):\n+        class SignalHandler:\n+            \"\"\"Track threads handler is dispatched on.\"\"\"\n+            threads = []\n+\n+            def __call__(self, **kwargs):\n+                self.threads.append(threading.current_thread())\n+\n+        signal_handler = SignalHandler()\n+        request_started.connect(signal_handler)\n+        request_finished.connect(signal_handler)\n+\n+        # Perform a basic request.\n+        application = get_asgi_application()\n+        scope = self.async_request_factory._base_scope(path='/')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['status'], 200)\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], b'Hello World!')\n+        # Give response.close() time to finish.\n+        await communicator.wait()\n+\n+        # At this point, AsyncToSync does not have a current executor. Thus\n+        # SyncToAsync falls-back to .single_thread_executor.\n+        target_thread = next(iter(SyncToAsync.single_thread_executor._threads))\n+        request_started_thread, request_finished_thread = signal_handler.threads\n+        self.assertEqual(request_started_thread, target_thread)\n+        self.assertEqual(request_finished_thread, target_thread)\n+        request_started.disconnect(signal_handler)\n+        request_finished.disconnect(signal_handler)\n"], "arch": "x86_64", "base_commit": "e39e727ded673e74016b5d3658d23cbe20234d11", "test_directives": ["asgi.test_middleware_response"], "coverage_files": ["django/middleware/security.py", "django/middleware/cache.py", "django/contrib/sessions/middleware.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "requirements.txt", "install": "python -m pip install -e .", "eval_commands": ["sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen", "export LANG=en_US.UTF-8", "export LANGUAGE=en_US:en", "export LC_ALL=en_US.UTF-8"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/middleware/security\\.py|django/middleware/cache\\.py|django/contrib/sessions/middleware\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 asgi.test_middleware_response", "req_install_commands": ["conda create -n testbed python=3.6 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}