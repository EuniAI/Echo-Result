{"instance_id": "django__django-14011", "repo": "django/django", "version": "4.0", "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4", "patch_list": ["diff --git a/tests/test_connection_handling.py b/tests/test_connection_handling.py\nnew file mode 100644\nindex 0000000000..5b61eb61ed\n--- /dev/null\n+++ b/tests/test_connection_handling.py\n@@ -0,0 +1,71 @@\n+from urllib.request import urlopen\n+\n+from django.db import connections, DEFAULT_DB_ALIAS\n+from django.http import HttpResponse\n+from django.test import LiveServerTestCase, override_settings\n+from django.urls import path\n+\n+# A global dict to hold objects from the request-handler thread, preventing\n+# them from being garbage-collected when the thread terminates.\n+THREAD_STATE = {}\n+\n+\n+def db_accessing_view(request):\n+    \"\"\"\n+    A view that opens a database connection and then stores references to the\n+    connection object and the connection handler in a global dict.\n+    \"\"\"\n+    conn = connections[DEFAULT_DB_ALIAS]\n+    conn.cursor()  # Ensure the connection is open.\n+    # Store the connection wrapper from this thread.\n+    THREAD_STATE[\"conn_obj\"] = conn\n+    # Store the connection handler from this thread to prevent its __del__\n+    # method (which calls close_all()) from running when the thread exits.\n+    # This is key to deterministically reproducing the bug.\n+    THREAD_STATE[\"handler\"] = connections\n+    return HttpResponse(\"OK\")\n+\n+\n+# A minimal URLconf for the test case.\n+urlpatterns = [\n+    path(\"db_access/\", db_accessing_view),\n+]\n+\n+\n+@override_settings(ROOT_URLCONF=__name__)\n+class LiveServerThreadConnectionHandlingTest(LiveServerTestCase):\n+    \"\"\"\n+    Test that connections opened by request handlers in the LiveServerThread\n+    are closed immediately after the request, not just by garbage collection.\n+    \"\"\"\n+\n+    available_apps = []\n+\n+    def tearDown(self):\n+        # Clean up global state after the test.\n+        THREAD_STATE.clear()\n+        super().tearDown()\n+\n+    def test_handler_thread_closes_connection(self):\n+        \"\"\"\n+        The connection used in a request handler thread should be closed\n+        after the request is complete.\n+        \"\"\"\n+        self.assertNotIn(\"conn_obj\", THREAD_STATE)\n+\n+        # Make a request to the view. urlopen blocks until the request is complete.\n+        with urlopen(self.live_server_url + \"/db_access/\"):\n+            pass\n+\n+        # The view should have stored the connection object.\n+        self.assertIn(\"conn_obj\", THREAD_STATE)\n+        thread_conn = THREAD_STATE[\"conn_obj\"]\n+\n+        # This is the core assertion.\n+        # With the patch, the server wrapper calls `connections.close_all()` at\n+        # the end of the request, which sets `thread_conn.connection` to None.\n+        # Without the patch, this doesn't happen. Because we are holding a\n+        # reference to the thread's connection handler, the connection is\n+        # not closed by garbage collection, so `thread_conn.connection`\n+        # remains a connection object.\n+        self.assertIsNone(thread_conn.connection)\n"], "arch": "x86_64", "base_commit": "e4430f22c8e3d29ce5d9d0263fba57121938d06d", "test_directives": ["test_connection_handling"], "coverage_files": ["django/core/servers/basehttp.py", "django/db/backends/sqlite3/features.py"], "env_name": "testbed", "run_id": "patch_evaluation", "patch_id": "pred_pre__Prometheus-Bug-Reproduction-Agent", "timeout": 1800, "rm_image": false, "force_rebuild": true, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.8", "packages": "requirements.txt", "install": "python -m pip install -e ."}, "cache_level": "instance", "test_command": "python3 /root/trace.py --count -C coverage.cover --include-pattern '/testbed/(django/core/servers/basehttp\\.py|django/db/backends/sqlite3/features\\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 test_connection_handling", "req_install_commands": ["conda create -n testbed python=3.8 -y", "cat <<'EOF_59812759871' > $HOME/requirements.txt\nasgiref >= 3.3.2\nargon2-cffi >= 16.1.0\nbackports.zoneinfo; python_version < '3.9'\nbcrypt\ndocutils\ngeoip2\njinja2 >= 2.9.2\nnumpy\nPillow >= 6.2.0\npylibmc; sys.platform != 'win32'\npymemcache >= 3.4.0\npython-memcached >= 1.59\npytz\npywatchman; sys.platform != 'win32'\nPyYAML\nredis >= 3.0.0\nselenium\nsqlparse >= 0.2.2\ntblib >= 1.5.0\ntzdata\ncolorama; sys.platform == 'win32'\n\nEOF_59812759871", "conda activate testbed && python -m pip install -r $HOME/requirements.txt", "rm $HOME/requirements.txt"]}